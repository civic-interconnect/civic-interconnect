{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"en/","title":"Project Documentation","text":"<p>Documentation for civic-interconnect.</p> <p>Use the navigation menu to explore available modules and APIs.</p> <ul> <li>The API Reference section includes autogenerated docs from the source code.</li> <li>This home page will always be served at <code>/</code>.</li> </ul> <p>To learn more, visit the GitHub repository.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"en/api/#civic_interconnect","title":"civic_interconnect","text":""},{"location":"en/api/#civic_interconnect.cep","title":"cep","text":"<p>Top-level package for Civic Interconnect CEP Python helpers.</p> <p>This module intentionally avoids importing submodules at import time to prevent circular imports. Callers should import subpackages explicitly, e.g.:</p> <pre><code>from ci_cep.localization import load_localization\nfrom ci_cep.adapters.us_mn_municipality import build_municipality_entity\nfrom ci_cep.entity.api import build_entity_from_raw\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters","title":"adapters","text":"<p>Adapters package for civic-interconnect CEP.</p> <p>This package contains adapter implementations for external integrations.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.fec_csv","title":"fec_csv","text":"<p>FEC CSV adapter for the Civic Engagement Platform.</p> <p>This module provides adapters for reading and processing Federal Election Commission (FEC) CSV data files.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.state_portal_example","title":"state_portal_example","text":"<p>State portal example adapter for the CEP system.</p> <p>This module provides an example adapter implementation for connecting to state portals and retrieving civic engagement data.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality","title":"us_ca_municipality","text":"<p>Adapter for US California municipality data sources.</p> <p>This module provides adapters for connecting to and retrieving data from California municipal government systems and data sources.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-CA\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-CA',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-CA\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality","title":"us_mn_municipality","text":"<p>Adapter for US Minnesota municipality data sources.</p> <p>This module provides adapters for connecting to and transforming data from Minnesota municipal government systems into normalized CEP-ready payloads.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-MN\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-MN',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-MN\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality","title":"us_ny_municipality","text":"<p>Adapter for US New York State municipality data sources.</p> <p>This module provides adapters for connecting to and retrieving data from New York State municipal government systems and data sources.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-NY\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-NY',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-NY\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen","title":"codegen","text":"<p>Code generation module for CEP (Complex Event Processing).</p> <p>This module provides utilities and classes for generating code related to complex event processing operations.</p>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated","title":"rust_generated","text":"<p>Code generation utilities for creating Rust structs from JSON Schema.</p> <p>This module provides functions to: - Convert JSON Schema files into Rust struct definitions - Map JSON Schema types to Rust types - Generate serde-compatible field attributes - Handle nullable and optional fields</p>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated.generate_rust_struct","title":"generate_rust_struct","text":"<pre><code>generate_rust_struct(\n    schema_path: Path, struct_name: str\n) -&gt; str\n</code></pre> <p>Generate a single Rust struct from a JSON Schema file.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/rust_generated.py</code> <pre><code>def generate_rust_struct(schema_path: Path, struct_name: str) -&gt; str:\n    \"\"\"Generate a single Rust struct from a JSON Schema file.\"\"\"\n    root: dict[str, Any] = _load_schema_for_codegen(schema_path)\n\n    # Flatten via allOf + local $refs for the main record.\n    flat: dict[str, Any] = {}\n    _flatten_schema(root, root, flat)\n\n    properties: dict[str, Any] = flat.get(\"properties\", {})\n    description = root.get(\"description\", \"\")\n\n    lines: list[str] = [RUST_HEADER]\n\n    # special_types maps JSON field names to explicit Rust types.\n    special_types: dict[str, str] = {}\n\n    # Optional: RecordKind enum from envelope's recordKind enum.\n    record_kind_enum = _generate_record_kind_enum(root)\n    if record_kind_enum:\n        lines.append(record_kind_enum)\n        special_types[\"recordKind\"] = \"RecordKind\"\n\n    # Envelope structs + StatusCode enum (if $defs present).\n    envelope_items = _generate_envelope_items(root, special_types)\n    if envelope_items:\n        lines.append(envelope_items)\n\n    # Typed identifiers map alias if the schema uses \"identifiers\".\n    identifiers_alias = \"\"\n    if \"identifiers\" in properties:\n        identifiers_alias = (\n            \"pub type Identifiers = \"\n            \"std::collections::HashMap&lt;String, std::collections::HashMap&lt;String, String&gt;&gt;;\\n\\n\"\n        )\n        special_types[\"identifiers\"] = \"Identifiers\"\n\n    if identifiers_alias:\n        lines.append(identifiers_alias)\n\n    # Emit the main record struct.\n    if description:\n        lines.append(\"/// \" + description + \"\\n\")\n\n    lines.append(\"#[derive(Debug, Clone, Serialize, Deserialize)]\")\n    lines.append('#[serde(rename_all = \"camelCase\")]')\n    lines.append(\"pub struct \" + struct_name + \" {\")\n\n    for name, prop_schema in properties.items():\n        lines.append(_field_line(name, prop_schema, flat, special_types))\n\n    lines.append(\"}\")\n    lines.append(\"\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated.write_generated_rust","title":"write_generated_rust","text":"<pre><code>write_generated_rust(\n    schema_path: Path, struct_name: str, out_path: Path\n) -&gt; None\n</code></pre> <p>Generate Rust code from schema_path and write to out_path.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/rust_generated.py</code> <pre><code>def write_generated_rust(\n    schema_path: Path,\n    struct_name: str,\n    out_path: Path,\n) -&gt; None:\n    \"\"\"Generate Rust code from schema_path and write to out_path.\"\"\"\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    rust_code = generate_rust_struct(schema_path, struct_name)\n    out_path.write_text(rust_code, encoding=\"utf-8\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core","title":"core","text":"<p>CEP Core - Core primitives for the Civic Exchange Protocol.</p> <p>This package provides the foundational types used by all CEP record types:</p> <ul> <li>CanonicalTimestamp: Microsecond-precision UTC timestamps</li> <li>CanonicalHash: SHA-256 hash values</li> <li>Canonicalize: Base class for deterministic serialization</li> <li>Attestation: Cryptographic proof of record integrity</li> <li>Schema Registry: Central schema loading and validation support</li> </ul>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.attestation","title":"attestation","text":"<p>Attestation and cryptographic proof types for CEP records.</p> <p>Every CEP record includes an attestation block that proves: - Who attested to the record (attestor_id) - When it was attested (attestation_timestamp) - Cryptographic proof of integrity (proof_type, proof_value, verification_method_uri)</p>"},{"location":"en/api/#civic_interconnect.cep.core.attestation.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre> canonical_fields \u00b6 <pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre> new <code>classmethod</code> \u00b6 <pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre> with_anchor \u00b6 <pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre> with_purpose \u00b6 <pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.attestation.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre> as_str \u00b6 <pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical","title":"canonical","text":"<p>Canonical serialization for CEP records.</p> <p>This module provides the base class and utilities for generating deterministic canonical strings from CEP records. The canonical string is the input to SHA-256 hashing for record integrity verification.</p> <p>Canonicalization Rules: 1. Field Order: Fields MUST be serialized in alphabetical order. 2. Null/Empty Omission: Fields with None or empty string values    MUST be omitted entirely from the canonical string. 3. Timestamp Format: All timestamps MUST use YYYY-MM-DDTHH:MM:SS.ffffffZ    with exactly 6 decimal places for microseconds. 4. Numeric Format: Monetary amounts MUST use exactly 2 decimal places.    Integers MUST NOT have decimal points. 5. String Escaping: Strings are NOT JSON-escaped in the canonical form.    The canonical string is a simple key:value concatenation. 6. Encoding: The canonical string MUST be UTF-8 encoded.</p>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre> calculate_hash \u00b6 <pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre> canonical_fields <code>abstractmethod</code> \u00b6 <pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre> to_canonical_string \u00b6 <pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error","title":"error","text":"<p>Error types for CEP operations.</p>"},{"location":"en/api/#civic_interconnect.cep.core.error.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre> __init__ \u00b6 <pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.hash","title":"hash","text":"<p>Cryptographic hashing utilities for CEP records.</p> <p>All CEP hashes are SHA-256, represented as lowercase hexadecimal strings.</p>"},{"location":"en/api/#civic_interconnect.cep.core.hash.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre> __hash__ \u00b6 <pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre> __init__ \u00b6 <pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre> __repr__ \u00b6 <pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre> __str__ \u00b6 <pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre> as_bytes \u00b6 <pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre> as_hex \u00b6 <pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre> from_canonical_string <code>classmethod</code> \u00b6 <pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre> from_hex <code>classmethod</code> \u00b6 <pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry","title":"schema_registry","text":"<p>Central schema registry for CEP validation.</p>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.timestamp","title":"timestamp","text":"<p>Canonical timestamp handling for CEP records.</p> <p>All CEP timestamps MUST be: - UTC timezone (indicated by 'Z' suffix) - ISO 8601 format - Microsecond precision (exactly 6 decimal places)</p> <p>Example: 2025-11-28T14:30:00.000000Z</p>"},{"location":"en/api/#civic_interconnect.cep.core.timestamp.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre> __ge__ \u00b6 <pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre> __gt__ \u00b6 <pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre> __hash__ \u00b6 <pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre> __init__ \u00b6 <pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre> __le__ \u00b6 <pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre> __lt__ \u00b6 <pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre> __repr__ \u00b6 <pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre> __str__ \u00b6 <pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre> as_datetime \u00b6 <pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre> now <code>classmethod</code> \u00b6 <pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre> parse <code>classmethod</code> \u00b6 <pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre> to_canonical_string \u00b6 <pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.version","title":"version","text":"<p>CEP version constants.</p>"},{"location":"en/api/#civic_interconnect.cep.entity","title":"entity","text":"<p>Entity module for civic-interconnect CEP.</p> <p>This module contains entity classes and related functionality.</p>"},{"location":"en/api/#civic_interconnect.cep.entity.api","title":"api","text":"<p>CEP Entity builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Entity records from normalized adapter payloads.</p> <p>Adapters should call build_entity_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p>"},{"location":"en/api/#civic_interconnect.cep.entity.api.build_entity_from_raw","title":"build_entity_from_raw","text":"<pre><code>build_entity_from_raw(\n    raw: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert a normalized adapter payload into a full CEP Entity record.</p> <p>Expected raw keys: - jurisdictionIso: ISO 3166 style jurisdiction code, for example \"US-MN\" - legalName: canonical or near-canonical name from source - legalNameNormalized: normalized form used for SNFEI - snfei: SNFEI hash computed by the adapter - entityType: domain type label such as \"municipality\", \"school_district\", etc.</p> <p>This function: - applies schema-level defaults - constructs verifiableId - attaches identifiers and status - populates an initial attestation block</p> <p>If the cep_py native extension is available, this function delegates to Rust. Otherwise, it uses a pure Python implementation.</p> Source code in <code>src/python/src/civic_interconnect/cep/entity/api.py</code> <pre><code>def build_entity_from_raw(raw: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Convert a normalized adapter payload into a full CEP Entity record.\n\n    Expected raw keys:\n    - jurisdictionIso: ISO 3166 style jurisdiction code, for example \"US-MN\"\n    - legalName: canonical or near-canonical name from source\n    - legalNameNormalized: normalized form used for SNFEI\n    - snfei: SNFEI hash computed by the adapter\n    - entityType: domain type label such as \"municipality\", \"school_district\", etc.\n\n    This function:\n    - applies schema-level defaults\n    - constructs verifiableId\n    - attaches identifiers and status\n    - populates an initial attestation block\n\n    If the cep_py native extension is available, this function delegates\n    to Rust. Otherwise, it uses a pure Python implementation.\n    \"\"\"\n    # Basic validation of the normalized payload\n    required_keys = [\n        \"jurisdictionIso\",\n        \"legalName\",\n        \"legalNameNormalized\",\n        \"snfei\",\n        \"entityType\",\n    ]\n    missing = [k for k in required_keys if k not in raw]\n    if missing:\n        raise ValueError(f\"Normalized entity payload is missing keys: {missing}\")\n\n    # Prefer native backend when available, but never crash if it fails.\n    if HAS_NATIVE_BACKEND and _build_entity_json_native is not None:\n        try:\n            input_json = json.dumps(raw, sort_keys=True)\n            output_json = _build_entity_json_native(input_json)  # type: ignore[misc]\n            return json.loads(output_json)\n        except Exception as exc:\n            # Defensive fallback: log-friendly message and drop back to Python.\n            # You can replace this print with proper logging later.\n            print(\n                f\"[ci_cep.entity.api] Warning: native backend failed \"\n                f\"({exc!r}); falling back to pure Python builder.\"\n            )\n\n    # Fallback: pure Python builder\n    return _build_entity_from_raw_python(raw)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.exchange","title":"exchange","text":""},{"location":"en/api/#civic_interconnect.cep.exchange.api","title":"api","text":"<p>CEP Exchange builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Exchange records from normalized adapter payloads.</p> <p>Adapters should call build_exchange_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p>"},{"location":"en/api/#civic_interconnect.cep.localization","title":"localization","text":"<p>Apply localization configurations for different jurisdictions.</p>"},{"location":"en/api/#civic_interconnect.cep.localization.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for jurisdiction-specific localization settings.</p> <p>jurisdiction : str     The jurisdiction code (e.g., 'BASE', 'US', 'US-MN'). parent : str | None     The parent jurisdiction from which this config inherits. version : str     The version of this localization configuration. updated_timestamp : str     ISO timestamp of when this configuration was last updated. config_hash : str | None     Optional hash of the configuration for versioning. abbreviations : dict[str, str]     Mapping of abbreviations to their expanded forms. agency_names : dict[str, str]     Mapping of agency name aliases to canonical names. entity_types : dict[str, str]     Mapping of entity type aliases to canonical types. rules : list[dict[str, Any]]     List of jurisdiction-specific rules. stop_words : list[str]     List of words to ignore during normalization.</p> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for jurisdiction-specific localization settings.\n\n    Attributes:\n    jurisdiction : str\n        The jurisdiction code (e.g., 'BASE', 'US', 'US-MN').\n    parent : str | None\n        The parent jurisdiction from which this config inherits.\n    version : str\n        The version of this localization configuration.\n    updated_timestamp : str\n        ISO timestamp of when this configuration was last updated.\n    config_hash : str | None\n        Optional hash of the configuration for versioning.\n    abbreviations : dict[str, str]\n        Mapping of abbreviations to their expanded forms.\n    agency_names : dict[str, str]\n        Mapping of agency name aliases to canonical names.\n    entity_types : dict[str, str]\n        Mapping of entity type aliases to canonical types.\n    rules : list[dict[str, Any]]\n        List of jurisdiction-specific rules.\n    stop_words : list[str]\n        List of words to ignore during normalization.\n    \"\"\"\n\n    jurisdiction: str\n    parent: str | None\n    version: str\n    updated_timestamp: str\n    config_hash: str | None\n    abbreviations: dict[str, str]\n    agency_names: dict[str, str]\n    entity_types: dict[str, str]\n    rules: list[dict[str, Any]]\n    stop_words: list[str]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.localization.load_localization","title":"load_localization","text":"<pre><code>load_localization(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Public entry point: get a cascaded LocalizationConfig, with caching.</p> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>def load_localization(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Public entry point: get a cascaded LocalizationConfig, with caching.\"\"\"\n    if jurisdiction in _LOCALIZATION_CACHE:\n        return _LOCALIZATION_CACHE[jurisdiction]\n    cfg = _build_localization_config(jurisdiction)\n    _LOCALIZATION_CACHE[jurisdiction] = cfg\n    return cfg\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.localization.normalize_name","title":"normalize_name","text":"<pre><code>normalize_name(\n    raw_name: str, config: LocalizationConfig\n) -&gt; str\n</code></pre> <p>Very simple first-pass normalizer.</p> <ul> <li>lowercases</li> <li>strips leading/trailing whitespace</li> <li>replaces abbreviations as whole-word tokens when possible</li> <li>trims stop words</li> <li>applies simple agency_names mapping if exact match</li> </ul> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>def normalize_name(raw_name: str, config: LocalizationConfig) -&gt; str:\n    \"\"\"Very simple first-pass normalizer.\n\n    - lowercases\n    - strips leading/trailing whitespace\n    - replaces abbreviations as whole-word tokens when possible\n    - trims stop words\n    - applies simple agency_names mapping if exact match\n    \"\"\"\n    if not raw_name:\n        return \"\"\n\n    text = raw_name.strip().lower()\n\n    # Exact agency name override first (common for \"nyc\", \"mn\", etc.).\n    if text in config.agency_names:\n        return config.agency_names[text]\n\n    # Tokenize on whitespace.\n    tokens = text.split()\n\n    # Expand abbreviations and drop stop words.\n    expanded_tokens: list[str] = []\n    for tok in tokens:\n        if tok in config.stop_words:\n            continue\n        if tok in config.abbreviations:\n            expanded_tokens.extend(config.abbreviations[tok].split())\n        else:\n            expanded_tokens.append(tok)\n\n    normalized = \" \".join(expanded_tokens)\n\n    # Apply agency_names again in case expansion matched a known alias.\n    if normalized in config.agency_names:\n        return config.agency_names[normalized]\n\n    return normalized\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.relationship","title":"relationship","text":""},{"location":"en/api/#civic_interconnect.cep.relationship.api","title":"api","text":"<p>CEP Relationship builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Relationship records from normalized adapter payloads.</p> <p>Adapters should call build_relationship_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p>"},{"location":"en/api/#civic_interconnect.cep.snfei","title":"snfei","text":"<p>CEP Core Linker: Entity Resolution and SNFEI Generation.</p> <p>This package implements the Normalizing Functor architecture for generating deterministic entity identifiers (SNFEIs) from heterogeneous source data.</p> Architecture <p>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  Raw Entity  \u2502     \u2502  Intermediate  \u2502     \u2502  Canonical  \u2502 \u2502    Data      \u2502\u2500\u2500\u2500&gt; \u2502    Canonical   \u2502\u2500\u2500\u2500&gt; \u2502   Entity    \u2502 \u2502              \u2502  L  \u2502                \u2502  N  \u2502             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                     \u2502                                                     \u2502 SHA-256                                                     V                                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                             \u2502    SNFEI     \u2502                                             \u2502  (64-char)   \u2502                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</p> <p>L = Localization Functor (jurisdiction-specific transforms) N = Normalizing Functor (universal normalization)</p> Usage <p>from civic_exchange_protocol.core_linker import (     generate_snfei,     normalize_legal_name,     apply_localization, )</p>"},{"location":"en/api/#civic_interconnect.cep.snfei--simple-snfei-generation","title":"Simple SNFEI generation","text":"<p>snfei, inputs = generate_snfei(     legal_name=\"Springfield USD #12\",     country_code=\"US\",     address=\"123 Main St\", )</p>"},{"location":"en/api/#civic_interconnect.cep.snfei--with-jurisdiction-specific-localization","title":"With jurisdiction-specific localization","text":"<p>from civic_exchange_protocol.core_linker import apply_localization localized = apply_localization(\"MTA\", \"us/ny\")</p>"},{"location":"en/api/#civic_interconnect.cep.snfei---metropolitan-transportation-authority","title":"-&gt; \"metropolitan transportation authority\"","text":""},{"location":"en/api/#civic_interconnect.cep.snfei.CanonicalInput","title":"CanonicalInput  <code>dataclass</code>","text":"<p>Normalized input for SNFEI hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>@dataclass\nclass CanonicalInput:\n    \"\"\"Normalized input for SNFEI hashing.\"\"\"\n\n    legal_name_normalized: str\n    address_normalized: str | None\n    country_code: str\n    registration_date: str | None\n\n    def to_hash_string(self) -&gt; str:\n        \"\"\"Generate the concatenated string for hashing.\n\n        Format:\n            legal_name_normalized|address_normalized|country_code|registration_date\n\n        Empty/None fields are included as empty strings to maintain\n        consistent field positions.\n        \"\"\"\n        parts = [\n            self.legal_name_normalized,\n            self.address_normalized or \"\",\n            self.country_code,\n            self.registration_date or \"\",\n        ]\n        return \"|\".join(parts)\n\n    def to_hash_string_v2(self) -&gt; str:\n        \"\"\"Alternative format that omits empty fields.\n\n        This produces shorter strings but requires all implementations\n        to handle optional fields identically.\n        \"\"\"\n        parts = [self.legal_name_normalized]\n        if self.address_normalized:\n            parts.append(self.address_normalized)\n        parts.append(self.country_code)\n        if self.registration_date:\n            parts.append(self.registration_date)\n        return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.CanonicalInput.to_hash_string","title":"to_hash_string","text":"<pre><code>to_hash_string() -&gt; str\n</code></pre> <p>Generate the concatenated string for hashing.</p> Format <p>legal_name_normalized|address_normalized|country_code|registration_date</p> <p>Empty/None fields are included as empty strings to maintain consistent field positions.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def to_hash_string(self) -&gt; str:\n    \"\"\"Generate the concatenated string for hashing.\n\n    Format:\n        legal_name_normalized|address_normalized|country_code|registration_date\n\n    Empty/None fields are included as empty strings to maintain\n    consistent field positions.\n    \"\"\"\n    parts = [\n        self.legal_name_normalized,\n        self.address_normalized or \"\",\n        self.country_code,\n        self.registration_date or \"\",\n    ]\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.CanonicalInput.to_hash_string_v2","title":"to_hash_string_v2","text":"<pre><code>to_hash_string_v2() -&gt; str\n</code></pre> <p>Alternative format that omits empty fields.</p> <p>This produces shorter strings but requires all implementations to handle optional fields identically.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def to_hash_string_v2(self) -&gt; str:\n    \"\"\"Alternative format that omits empty fields.\n\n    This produces shorter strings but requires all implementations\n    to handle optional fields identically.\n    \"\"\"\n    parts = [self.legal_name_normalized]\n    if self.address_normalized:\n        parts.append(self.address_normalized)\n    parts.append(self.country_code)\n    if self.registration_date:\n        parts.append(self.registration_date)\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for a specific jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for a specific jurisdiction.\"\"\"\n\n    jurisdiction: str  # e.g., \"us/ca\", \"ca/on\"\n    parent: str | None  # Parent jurisdiction for inheritance\n\n    # Transformation maps\n    abbreviations: dict[str, str] = field(default_factory=dict)\n    agency_names: dict[str, str] = field(default_factory=dict)\n    entity_types: dict[str, str] = field(default_factory=dict)\n\n    # Additional rules\n    rules: list[LocalizationRule] = field(default_factory=list)\n\n    # Stop words specific to this jurisdiction\n    stop_words: set[str] = field(default_factory=set)\n\n    def apply_to_name(self, name: str) -&gt; str:\n        \"\"\"Apply jurisdiction-specific transformations to a name.\n\n        Order of application:\n        1. Agency name expansions\n        2. Abbreviation expansions\n        3. Entity type standardization\n        4. Custom rules\n        \"\"\"\n        result = name.lower()\n\n        # 1. Agency names (exact match, case-insensitive)\n        for abbrev, full in self.agency_names.items():\n            # Word boundary matching\n            import re\n\n            pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n            result = re.sub(pattern, full.lower(), result)\n\n        # 2. Abbreviations\n        tokens = result.split()\n        expanded = []\n        for token in tokens:\n            if token in self.abbreviations:\n                expanded.append(self.abbreviations[token].lower())\n            else:\n                expanded.append(token)\n        result = \" \".join(expanded)\n\n        # 3. Entity types\n        for local_type, canonical_type in self.entity_types.items():\n            import re\n\n            pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n            result = re.sub(pattern, canonical_type.lower(), result)\n\n        # 4. Custom rules\n        for rule in self.rules:\n            if rule.is_regex:\n                import re\n\n                result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n            else:\n                result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n        return result\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationConfig.apply_to_name","title":"apply_to_name","text":"<pre><code>apply_to_name(name: str) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific transformations to a name.</p> <p>Order of application: 1. Agency name expansions 2. Abbreviation expansions 3. Entity type standardization 4. Custom rules</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_to_name(self, name: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific transformations to a name.\n\n    Order of application:\n    1. Agency name expansions\n    2. Abbreviation expansions\n    3. Entity type standardization\n    4. Custom rules\n    \"\"\"\n    result = name.lower()\n\n    # 1. Agency names (exact match, case-insensitive)\n    for abbrev, full in self.agency_names.items():\n        # Word boundary matching\n        import re\n\n        pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n        result = re.sub(pattern, full.lower(), result)\n\n    # 2. Abbreviations\n    tokens = result.split()\n    expanded = []\n    for token in tokens:\n        if token in self.abbreviations:\n            expanded.append(self.abbreviations[token].lower())\n        else:\n            expanded.append(token)\n    result = \" \".join(expanded)\n\n    # 3. Entity types\n    for local_type, canonical_type in self.entity_types.items():\n        import re\n\n        pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n        result = re.sub(pattern, canonical_type.lower(), result)\n\n    # 4. Custom rules\n    for rule in self.rules:\n        if rule.is_regex:\n            import re\n\n            result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n        else:\n            result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n    return result\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationRegistry","title":"LocalizationRegistry","text":"<p>Registry for loading and caching localization configurations.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>class LocalizationRegistry:\n    \"\"\"Registry for loading and caching localization configurations.\"\"\"\n\n    def __init__(self, config_dir: Path | None = None):\n        \"\"\"Initialize the registry.\n\n        Args:\n            config_dir: Optional path to localization YAML files.\n                       If None, only built-in configs are available.\n        \"\"\"\n        self.config_dir = config_dir\n        self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n\n    def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n        \"\"\"Get localization config for a jurisdiction.\n\n        Falls back through parent jurisdictions if specific config not found.\n        Merges child config with parent config for inheritance.\n\n        Args:\n            jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                         Case-insensitive - will be normalized to lowercase.\n\n        Returns:\n            LocalizationConfig for the jurisdiction (merged with parent).\n        \"\"\"\n        # Normalize to lowercase\n        jurisdiction = jurisdiction.lower()\n\n        # Check if we have a merged config cached\n        cache_key = f\"_merged_{jurisdiction}\"\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Get the base config for this jurisdiction\n        if jurisdiction in self._cache:\n            config = self._cache[jurisdiction]\n        elif self.config_dir:\n            config = self._load_yaml(jurisdiction)\n            if config:\n                self._cache[jurisdiction] = config\n            else:\n                config = None\n        else:\n            config = None\n\n        # If no config found, fall back to parent\n        if config is None:\n            if \"/\" in jurisdiction:\n                parent = jurisdiction.rsplit(\"/\", 1)[0]\n                return self.get_config(parent)\n            # Return empty config as last resort\n            return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n        # If config has a parent, merge with parent config\n        if config.parent:\n            parent_config = self.get_config(config.parent)\n            merged = self.merge_configs(config, parent_config)\n            self._cache[cache_key] = merged\n            return merged\n\n        return config\n\n    def _load_yaml(self, jurisdiction: str) -&gt; LocalizationConfig | None:\n        \"\"\"Load config from YAML file.\n\n        Expected paths:\n            - {config_dir}/{country}/base.yaml for country-level (e.g., US, CA)\n            - {config_dir}/{country}/{region}.yaml for region-level (e.g., us/ca, ca/on)\n        \"\"\"\n        if not self.config_dir:\n            return None\n\n        # Determine the YAML file path\n        if \"/\" in jurisdiction:\n            # Region-level: us/ca -&gt; us/ca.yaml\n            parts = jurisdiction.split(\"/\")\n            yaml_path = self.config_dir / parts[0] / f\"{parts[1]}.yaml\"\n        else:\n            # Country-level: US -&gt; us/base.yaml\n            yaml_path = self.config_dir / jurisdiction / \"base.yaml\"\n\n        if not yaml_path.exists():\n            return None\n\n        try:\n            with yaml_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n\n            if not data:\n                return None\n\n            # Parse rules if present\n            rules = []\n            for rule_data in data.get(\"rules\", []):\n                rules.append(\n                    LocalizationRule(\n                        pattern=rule_data.get(\"pattern\", \"\"),\n                        replacement=rule_data.get(\"replacement\", \"\"),\n                        is_regex=rule_data.get(\"is_regex\", False),\n                        context=rule_data.get(\"context\"),\n                    )\n                )\n\n            return LocalizationConfig(\n                jurisdiction=data.get(\"jurisdiction\", jurisdiction),\n                parent=data.get(\"parent\"),\n                abbreviations=data.get(\"abbreviations\", {}),\n                agency_names=data.get(\"agency_names\", {}),\n                entity_types=data.get(\"entity_types\", {}),\n                rules=rules,\n                stop_words=set(data.get(\"stop_words\", [])),\n            )\n        except Exception as e:\n            # Log error but don't crash\n            print(f\"Warning: Failed to load localization YAML {yaml_path}: {e}\")\n            return None\n\n    def merge_configs(\n        self, child: LocalizationConfig, parent: LocalizationConfig\n    ) -&gt; LocalizationConfig:\n        \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n        merged_abbrevs = dict(parent.abbreviations)\n        merged_abbrevs.update(child.abbreviations)\n\n        merged_agencies = dict(parent.agency_names)\n        merged_agencies.update(child.agency_names)\n\n        merged_types = dict(parent.entity_types)\n        merged_types.update(child.entity_types)\n\n        return LocalizationConfig(\n            jurisdiction=child.jurisdiction,\n            parent=parent.jurisdiction,\n            abbreviations=merged_abbrevs,\n            agency_names=merged_agencies,\n            entity_types=merged_types,\n            rules=parent.rules + child.rules,\n            stop_words=parent.stop_words | child.stop_words,\n        )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationRegistry.__init__","title":"__init__","text":"<pre><code>__init__(config_dir: Path | None = None)\n</code></pre> <p>Initialize the registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>Path | None</code> <p>Optional path to localization YAML files.        If None, only built-in configs are available.</p> <code>None</code> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def __init__(self, config_dir: Path | None = None):\n    \"\"\"Initialize the registry.\n\n    Args:\n        config_dir: Optional path to localization YAML files.\n                   If None, only built-in configs are available.\n    \"\"\"\n    self.config_dir = config_dir\n    self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationRegistry.get_config","title":"get_config","text":"<pre><code>get_config(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction.</p> <p>Falls back through parent jurisdictions if specific config not found. Merges child config with parent config for inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\", \"ca/on\").          Case-insensitive - will be normalized to lowercase.</p> required <p>Returns:</p> Type Description <code>LocalizationConfig</code> <p>LocalizationConfig for the jurisdiction (merged with parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction.\n\n    Falls back through parent jurisdictions if specific config not found.\n    Merges child config with parent config for inheritance.\n\n    Args:\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                     Case-insensitive - will be normalized to lowercase.\n\n    Returns:\n        LocalizationConfig for the jurisdiction (merged with parent).\n    \"\"\"\n    # Normalize to lowercase\n    jurisdiction = jurisdiction.lower()\n\n    # Check if we have a merged config cached\n    cache_key = f\"_merged_{jurisdiction}\"\n    if cache_key in self._cache:\n        return self._cache[cache_key]\n\n    # Get the base config for this jurisdiction\n    if jurisdiction in self._cache:\n        config = self._cache[jurisdiction]\n    elif self.config_dir:\n        config = self._load_yaml(jurisdiction)\n        if config:\n            self._cache[jurisdiction] = config\n        else:\n            config = None\n    else:\n        config = None\n\n    # If no config found, fall back to parent\n    if config is None:\n        if \"/\" in jurisdiction:\n            parent = jurisdiction.rsplit(\"/\", 1)[0]\n            return self.get_config(parent)\n        # Return empty config as last resort\n        return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n    # If config has a parent, merge with parent config\n    if config.parent:\n        parent_config = self.get_config(config.parent)\n        merged = self.merge_configs(config, parent_config)\n        self._cache[cache_key] = merged\n        return merged\n\n    return config\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationRegistry.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(\n    child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig\n</code></pre> <p>Merge child config with parent (child overrides parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def merge_configs(\n    self, child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig:\n    \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n    merged_abbrevs = dict(parent.abbreviations)\n    merged_abbrevs.update(child.abbreviations)\n\n    merged_agencies = dict(parent.agency_names)\n    merged_agencies.update(child.agency_names)\n\n    merged_types = dict(parent.entity_types)\n    merged_types.update(child.entity_types)\n\n    return LocalizationConfig(\n        jurisdiction=child.jurisdiction,\n        parent=parent.jurisdiction,\n        abbreviations=merged_abbrevs,\n        agency_names=merged_agencies,\n        entity_types=merged_types,\n        rules=parent.rules + child.rules,\n        stop_words=parent.stop_words | child.stop_words,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.LocalizationRule","title":"LocalizationRule  <code>dataclass</code>","text":"<p>A single localization transformation rule.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationRule:\n    \"\"\"A single localization transformation rule.\"\"\"\n\n    pattern: str  # Text to match (case-insensitive)\n    replacement: str  # Replacement text\n    is_regex: bool = False  # Whether pattern is a regex\n    context: str | None = None  # Optional context (e.g., \"agency\", \"school\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>A validated SNFEI (64-character lowercase hex string).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"A validated SNFEI (64-character lowercase hex string).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate SNFEI format after initialization.\"\"\"\n        if len(self.value) != 64:\n            raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n        if not all(c in \"0123456789abcdef\" for c in self.value):\n            raise ValueError(\"SNFEI must be lowercase hex\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of SNFEI.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n        return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the hash value (for API compatibility).\"\"\"\n        return self.value\n\n    def short(self, length: int = 12) -&gt; str:\n        \"\"\"Return a shortened version for display.\"\"\"\n        return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate SNFEI format after initialization.\"\"\"\n    if len(self.value) != 64:\n        raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n    if not all(c in \"0123456789abcdef\" for c in self.value):\n        raise ValueError(\"SNFEI must be lowercase hex\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return abbreviated representation of SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n    return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of SNFEI.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the hash value (for API compatibility).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the hash value (for API compatibility).\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.Snfei.short","title":"short","text":"<pre><code>short(length: int = 12) -&gt; str\n</code></pre> <p>Return a shortened version for display.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def short(self, length: int = 12) -&gt; str:\n    \"\"\"Return a shortened version for display.\"\"\"\n    return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.SnfeiResult","title":"SnfeiResult  <code>dataclass</code>","text":"<p>Result of SNFEI generation with confidence metadata.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>@dataclass\nclass SnfeiResult:\n    \"\"\"Result of SNFEI generation with confidence metadata.\"\"\"\n\n    snfei: Snfei\n    canonical: CanonicalInput\n    confidence_score: float  # 0.0 to 1.0\n    tier: int  # 1, 2, or 3\n    fields_used: list  # Which fields contributed\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert result to dictionary for serialization.\"\"\"\n        return {\n            \"snfei\": self.snfei.value,\n            \"confidence_score\": self.confidence_score,\n            \"tier\": self.tier,\n            \"fields_used\": self.fields_used,\n            \"canonical\": {\n                \"legal_name_normalized\": self.canonical.legal_name_normalized,\n                \"address_normalized\": self.canonical.address_normalized,\n                \"country_code\": self.canonical.country_code,\n                \"registration_date\": self.canonical.registration_date,\n            },\n        }\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.SnfeiResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert result to dictionary for serialization.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert result to dictionary for serialization.\"\"\"\n    return {\n        \"snfei\": self.snfei.value,\n        \"confidence_score\": self.confidence_score,\n        \"tier\": self.tier,\n        \"fields_used\": self.fields_used,\n        \"canonical\": {\n            \"legal_name_normalized\": self.canonical.legal_name_normalized,\n            \"address_normalized\": self.canonical.address_normalized,\n            \"country_code\": self.canonical.country_code,\n            \"registration_date\": self.canonical.registration_date,\n        },\n    }\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.apply_localization","title":"apply_localization","text":"<pre><code>apply_localization(name: str, jurisdiction: str) -&gt; str\n</code></pre> <p>Apply localization transforms to a name.</p> <p>This is the Localization Functor L.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw entity name.</p> required <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name with jurisdiction-specific transforms applied.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_localization(name: str, jurisdiction: str) -&gt; str:\n    \"\"\"Apply localization transforms to a name.\n\n    This is the Localization Functor L.\n\n    Args:\n        name: Raw entity name.\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\").\n\n    Returns:\n        Name with jurisdiction-specific transforms applied.\n    \"\"\"\n    config = get_localization_config(jurisdiction)\n    return config.apply_to_name(name)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical input structure from raw entity data.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration/formation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput with all fields normalized.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical input structure from raw entity data.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration/formation date.\n\n    Returns:\n        CanonicalInput with all fields normalized.\n    \"\"\"\n    return CanonicalInput(\n        legal_name_normalized=normalize_legal_name(legal_name),\n        address_normalized=normalize_address(address) if address else None,\n        country_code=country_code.upper(),\n        registration_date=normalize_registration_date(registration_date)\n        if registration_date\n        else None,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(canonical: CanonicalInput) -&gt; Snfei\n</code></pre> <p>Compute SNFEI from canonical input.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>CanonicalInput</code> <p>Normalized input structure.</p> required <p>Returns:</p> Type Description <code>Snfei</code> <p>Computed SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def compute_snfei(canonical: CanonicalInput) -&gt; Snfei:\n    \"\"\"Compute SNFEI from canonical input.\n\n    Args:\n        canonical: Normalized input structure.\n\n    Returns:\n        Computed SNFEI.\n    \"\"\"\n    hash_input = canonical.to_hash_string()\n    hash_bytes = hashlib.sha256(hash_input.encode(\"utf-8\")).hexdigest().lower()\n    return Snfei(hash_bytes)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generate_snfei","title":"generate_snfei","text":"<pre><code>generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate an SNFEI from raw entity attributes.</p> <p>This is the main entry point for SNFEI generation. It applies the Normalizing Functor to all inputs before hashing.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional formation/registration date.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult for verification.</p> Example <p>snfei, inputs = generate_snfei( ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\", ...     country_code=\"US\", ...     address=\"123 Main St., Suite 100\", ...     registration_date=\"01/15/1985\", ... ) print(snfei) a1b2c3d4... print(inputs.legal_name_normalized) springfield unified school district incorporated</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate an SNFEI from raw entity attributes.\n\n    This is the main entry point for SNFEI generation. It applies the\n    Normalizing Functor to all inputs before hashing.\n\n    Args:\n        legal_name: Raw legal name from source system.\n        country_code: ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").\n        address: Optional primary street address.\n        registration_date: Optional formation/registration date.\n\n    Returns:\n        SnfeiResult for verification.\n\n    Example:\n        &gt;&gt;&gt; snfei, inputs = generate_snfei(\n        ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\",\n        ...     country_code=\"US\",\n        ...     address=\"123 Main St., Suite 100\",\n        ...     registration_date=\"01/15/1985\",\n        ... )\n        &gt;&gt;&gt; print(snfei)\n        a1b2c3d4...\n        &gt;&gt;&gt; print(inputs.legal_name_normalized)\n        springfield unified school district incorporated\n    \"\"\"\n    canonical = build_canonical_input(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=address,\n        registration_date=registration_date,\n    )\n    snfei = compute_snfei(canonical)\n\n    # Determine fields used from what's present in canonical\n    fields_used = [\"legal_name\", \"country_code\"]\n    if canonical.address_normalized:\n        fields_used.append(\"address\")\n    if canonical.registration_date:\n        fields_used.append(\"registration_date\")\n\n    # Basic confidence: Tier 3, score based on fields\n    confidence = 0.5\n    if canonical.address_normalized:\n        confidence += 0.2\n    if canonical.registration_date:\n        confidence += 0.2\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generate_snfei_simple","title":"generate_snfei_simple","text":"<pre><code>generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str\n</code></pre> <p>Generate SNFEI as a simple hex string.</p> <p>Convenience function that returns just the hash value.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>64-character lowercase hex SNFEI string.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str:\n    \"\"\"Generate SNFEI as a simple hex string.\n\n    Convenience function that returns just the hash value.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional primary street address.\n\n    Returns:\n        64-character lowercase hex SNFEI string.\n    \"\"\"\n    result = generate_snfei(legal_name, country_code, address)\n    return result.snfei.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generate_snfei_with_confidence","title":"generate_snfei_with_confidence","text":"<pre><code>generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate SNFEI with confidence scoring and tier classification.</p> <p>Tier Classification: - Tier 1: Entity has LEI (global identifier) - confidence 1.0 - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95 - Tier 3: Entity uses SNFEI (computed hash) - confidence varies</p> <p>Tier 3 Confidence Scoring: - Base: 0.5 (name + country only) - +0.2 if address is provided - +0.2 if registration_date is provided - +0.1 if name is reasonably long (&gt;3 words)</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration date.</p> <code>None</code> <code>lei</code> <code>str | None</code> <p>Optional LEI (Legal Entity Identifier).</p> <code>None</code> <code>sam_uei</code> <code>str | None</code> <p>Optional SAM.gov Unique Entity Identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult with SNFEI, confidence score, and metadata.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate SNFEI with confidence scoring and tier classification.\n\n    Tier Classification:\n    - Tier 1: Entity has LEI (global identifier) - confidence 1.0\n    - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95\n    - Tier 3: Entity uses SNFEI (computed hash) - confidence varies\n\n    Tier 3 Confidence Scoring:\n    - Base: 0.5 (name + country only)\n    - +0.2 if address is provided\n    - +0.2 if registration_date is provided\n    - +0.1 if name is reasonably long (&gt;3 words)\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration date.\n        lei: Optional LEI (Legal Entity Identifier).\n        sam_uei: Optional SAM.gov Unique Entity Identifier.\n\n    Returns:\n        SnfeiResult with SNFEI, confidence score, and metadata.\n    \"\"\"\n    fields_used = [\"legal_name\", \"country_code\"]\n\n    # Tier 1: LEI available\n    if lei and len(lei) == 20:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        # For Tier 1, we still compute SNFEI but confidence is 1.0\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=1.0,\n            tier=1,\n            fields_used=[\"lei\"] + fields_used,\n        )\n\n    # Tier 2: SAM UEI available\n    if sam_uei and len(sam_uei) == 12:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=0.95,\n            tier=2,\n            fields_used=[\"sam_uei\"] + fields_used,\n        )\n\n    # Tier 3: Compute SNFEI from attributes\n    canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n    snfei = compute_snfei(canonical)\n\n    # Calculate confidence score\n    confidence = 0.5  # Base score\n\n    if address:\n        fields_used.append(\"address\")\n        confidence += 0.2\n\n    if registration_date:\n        fields_used.append(\"registration_date\")\n        confidence += 0.2\n\n    # Bonus for longer, more specific names\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n\n    # Cap at 0.9 for Tier 3\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.get_localization_config","title":"get_localization_config","text":"<pre><code>get_localization_config(\n    jurisdiction: str,\n) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction (convenience function).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_localization_config(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction (convenience function).\"\"\"\n    return _registry.get_config(jurisdiction)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(\n    address: str, remove_secondary: bool = True\n) -&gt; str\n</code></pre> <p>Normalize a street address for SNFEI hashing.</p> <p>Pipeline: 1. Lowercase 2. ASCII transliteration 3. Remove secondary unit designators (apt, suite, etc.) 4. Remove punctuation 5. Expand postal abbreviations 6. Collapse whitespace</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Raw street address.</p> required <code>remove_secondary</code> <code>bool</code> <p>Whether to remove apartment/suite numbers.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized address string.</p> Example <p>normalize_address(\"123 N. Main St., Suite 400\") \"123 north main street\"</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_address(\n    address: str,\n    remove_secondary: bool = True,\n) -&gt; str:\n    \"\"\"Normalize a street address for SNFEI hashing.\n\n    Pipeline:\n    1. Lowercase\n    2. ASCII transliteration\n    3. Remove secondary unit designators (apt, suite, etc.)\n    4. Remove punctuation\n    5. Expand postal abbreviations\n    6. Collapse whitespace\n\n    Args:\n        address: Raw street address.\n        remove_secondary: Whether to remove apartment/suite numbers.\n\n    Returns:\n        Normalized address string.\n\n    Example:\n        &gt;&gt;&gt; normalize_address(\"123 N. Main St., Suite 400\")\n        \"123 north main street\"\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # 1. Lowercase\n    text = address.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove secondary unit designators\n    if remove_secondary:\n        for pattern in SECONDARY_UNIT_PATTERNS:\n            text = re.sub(pattern, \"\", text, flags=re.IGNORECASE)\n\n    # 4. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 5. Collapse whitespace first\n    text = _collapse_whitespace(text)\n\n    # 6. Expand postal abbreviations\n    tokens = text.split()\n    expanded = []\n    for token in tokens:\n        if token in US_ADDRESS_EXPANSIONS:\n            expanded.append(US_ADDRESS_EXPANSIONS[token])\n        else:\n            expanded.append(token)\n    text = \" \".join(expanded)\n\n    # 7. Final trim\n    return text.strip()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str\n</code></pre> <p>Apply the universal normalization pipeline to a legal name.</p> <p>Pipeline (in order): 1. Convert to lowercase 2. ASCII transliteration 3. Remove punctuation 4. Collapse whitespace 5. Expand abbreviations 6. Remove stop words (optional) 7. Final trim</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>remove_stop_words</code> <code>bool</code> <p>Whether to filter out stop words.</p> <code>True</code> <code>preserve_initial_stop</code> <code>bool</code> <p>If True, preserve stop word at start of name.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized name suitable for SNFEI hashing.</p> Example <p>normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\") \"springfield unified school district incorporated\"</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str:\n    \"\"\"Apply the universal normalization pipeline to a legal name.\n\n    Pipeline (in order):\n    1. Convert to lowercase\n    2. ASCII transliteration\n    3. Remove punctuation\n    4. Collapse whitespace\n    5. Expand abbreviations\n    6. Remove stop words (optional)\n    7. Final trim\n\n    Args:\n        name: Raw legal name from source system.\n        remove_stop_words: Whether to filter out stop words.\n        preserve_initial_stop: If True, preserve stop word at start of name.\n\n    Returns:\n        Normalized name suitable for SNFEI hashing.\n\n    Example:\n        &gt;&gt;&gt; normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\")\n        \"springfield unified school district incorporated\"\n    \"\"\"\n    if not name:\n        return \"\"\n\n    # 1. Lowercase\n    text = name.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 4. Collapse whitespace\n    text = _collapse_whitespace(text)\n\n    # 5. Expand abbreviations\n    text = _expand_abbreviations(text)\n\n    # 6. Remove stop words\n    if remove_stop_words:\n        text = _remove_stop_words(text, preserve_initial=preserve_initial_stop)\n\n    # 7. Final collapse and trim\n    return _collapse_whitespace(text)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(date_str: str) -&gt; str | None\n</code></pre> <p>Normalize a registration date to ISO 8601 format.</p> <p>Returns None if date cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string in various formats.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO 8601 date string (YYYY-MM-DD) or None.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_registration_date(date_str: str) -&gt; str | None:\n    \"\"\"Normalize a registration date to ISO 8601 format.\n\n    Returns None if date cannot be parsed.\n\n    Args:\n        date_str: Date string in various formats.\n\n    Returns:\n        ISO 8601 date string (YYYY-MM-DD) or None.\n    \"\"\"\n    if not date_str:\n        return None\n\n    # Remove extra whitespace\n    date_str = date_str.strip()\n\n    # Try common date patterns\n\n    patterns = [\n        # ISO format\n        (r\"^(\\d{4})-(\\d{2})-(\\d{2})$\", \"%Y-%m-%d\"),\n        # US format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%m/%d/%Y\"),\n        (r\"^(\\d{1,2})-(\\d{1,2})-(\\d{4})$\", \"%m-%d-%Y\"),\n        # European format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%d/%m/%Y\"),\n        # Year only\n        (r\"^(\\d{4})$\", \"%Y\"),\n    ]\n\n    for pattern, fmt in patterns:\n        if re.match(pattern, date_str):\n            try:\n                if fmt == \"%Y\":\n                    # Year only - use January 1\n                    return f\"{date_str}-01-01\"\n                dt = datetime.strptime(date_str, fmt)\n                return dt.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n    return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator","title":"generator","text":"<p>SNFEI Hash Generation.</p> <p>This module computes the final SNFEI (Sub-National Federated Entity Identifier) from normalized entity attributes.</p> The SNFEI formula <p>SNFEI = SHA256(Concatenate[     legal_name_normalized,     address_normalized,     country_code,     registration_date ])</p> <p>All inputs must pass through the Normalizing Functor before hashing.</p>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>A validated SNFEI (64-character lowercase hex string).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"A validated SNFEI (64-character lowercase hex string).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate SNFEI format after initialization.\"\"\"\n        if len(self.value) != 64:\n            raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n        if not all(c in \"0123456789abcdef\" for c in self.value):\n            raise ValueError(\"SNFEI must be lowercase hex\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of SNFEI.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n        return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the hash value (for API compatibility).\"\"\"\n        return self.value\n\n    def short(self, length: int = 12) -&gt; str:\n        \"\"\"Return a shortened version for display.\"\"\"\n        return self.value[:length]\n</code></pre> __post_init__ \u00b6 <pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate SNFEI format after initialization.\"\"\"\n    if len(self.value) != 64:\n        raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n    if not all(c in \"0123456789abcdef\" for c in self.value):\n        raise ValueError(\"SNFEI must be lowercase hex\")\n</code></pre> __repr__ \u00b6 <pre><code>__repr__() -&gt; str\n</code></pre> <p>Return abbreviated representation of SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n    return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n</code></pre> __str__ \u00b6 <pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of SNFEI.\"\"\"\n    return self.value\n</code></pre> as_str \u00b6 <pre><code>as_str() -&gt; str\n</code></pre> <p>Return the hash value (for API compatibility).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the hash value (for API compatibility).\"\"\"\n    return self.value\n</code></pre> short \u00b6 <pre><code>short(length: int = 12) -&gt; str\n</code></pre> <p>Return a shortened version for display.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def short(self, length: int = 12) -&gt; str:\n    \"\"\"Return a shortened version for display.\"\"\"\n    return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.SnfeiResult","title":"SnfeiResult  <code>dataclass</code>","text":"<p>Result of SNFEI generation with confidence metadata.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>@dataclass\nclass SnfeiResult:\n    \"\"\"Result of SNFEI generation with confidence metadata.\"\"\"\n\n    snfei: Snfei\n    canonical: CanonicalInput\n    confidence_score: float  # 0.0 to 1.0\n    tier: int  # 1, 2, or 3\n    fields_used: list  # Which fields contributed\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert result to dictionary for serialization.\"\"\"\n        return {\n            \"snfei\": self.snfei.value,\n            \"confidence_score\": self.confidence_score,\n            \"tier\": self.tier,\n            \"fields_used\": self.fields_used,\n            \"canonical\": {\n                \"legal_name_normalized\": self.canonical.legal_name_normalized,\n                \"address_normalized\": self.canonical.address_normalized,\n                \"country_code\": self.canonical.country_code,\n                \"registration_date\": self.canonical.registration_date,\n            },\n        }\n</code></pre> to_dict \u00b6 <pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert result to dictionary for serialization.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert result to dictionary for serialization.\"\"\"\n    return {\n        \"snfei\": self.snfei.value,\n        \"confidence_score\": self.confidence_score,\n        \"tier\": self.tier,\n        \"fields_used\": self.fields_used,\n        \"canonical\": {\n            \"legal_name_normalized\": self.canonical.legal_name_normalized,\n            \"address_normalized\": self.canonical.address_normalized,\n            \"country_code\": self.canonical.country_code,\n            \"registration_date\": self.canonical.registration_date,\n        },\n    }\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(canonical: CanonicalInput) -&gt; Snfei\n</code></pre> <p>Compute SNFEI from canonical input.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>CanonicalInput</code> <p>Normalized input structure.</p> required <p>Returns:</p> Type Description <code>Snfei</code> <p>Computed SNFEI.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def compute_snfei(canonical: CanonicalInput) -&gt; Snfei:\n    \"\"\"Compute SNFEI from canonical input.\n\n    Args:\n        canonical: Normalized input structure.\n\n    Returns:\n        Computed SNFEI.\n    \"\"\"\n    hash_input = canonical.to_hash_string()\n    hash_bytes = hashlib.sha256(hash_input.encode(\"utf-8\")).hexdigest().lower()\n    return Snfei(hash_bytes)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.generate_snfei","title":"generate_snfei","text":"<pre><code>generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate an SNFEI from raw entity attributes.</p> <p>This is the main entry point for SNFEI generation. It applies the Normalizing Functor to all inputs before hashing.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional formation/registration date.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult for verification.</p> Example <p>snfei, inputs = generate_snfei( ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\", ...     country_code=\"US\", ...     address=\"123 Main St., Suite 100\", ...     registration_date=\"01/15/1985\", ... ) print(snfei) a1b2c3d4... print(inputs.legal_name_normalized) springfield unified school district incorporated</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate an SNFEI from raw entity attributes.\n\n    This is the main entry point for SNFEI generation. It applies the\n    Normalizing Functor to all inputs before hashing.\n\n    Args:\n        legal_name: Raw legal name from source system.\n        country_code: ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").\n        address: Optional primary street address.\n        registration_date: Optional formation/registration date.\n\n    Returns:\n        SnfeiResult for verification.\n\n    Example:\n        &gt;&gt;&gt; snfei, inputs = generate_snfei(\n        ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\",\n        ...     country_code=\"US\",\n        ...     address=\"123 Main St., Suite 100\",\n        ...     registration_date=\"01/15/1985\",\n        ... )\n        &gt;&gt;&gt; print(snfei)\n        a1b2c3d4...\n        &gt;&gt;&gt; print(inputs.legal_name_normalized)\n        springfield unified school district incorporated\n    \"\"\"\n    canonical = build_canonical_input(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=address,\n        registration_date=registration_date,\n    )\n    snfei = compute_snfei(canonical)\n\n    # Determine fields used from what's present in canonical\n    fields_used = [\"legal_name\", \"country_code\"]\n    if canonical.address_normalized:\n        fields_used.append(\"address\")\n    if canonical.registration_date:\n        fields_used.append(\"registration_date\")\n\n    # Basic confidence: Tier 3, score based on fields\n    confidence = 0.5\n    if canonical.address_normalized:\n        confidence += 0.2\n    if canonical.registration_date:\n        confidence += 0.2\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.generate_snfei_simple","title":"generate_snfei_simple","text":"<pre><code>generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str\n</code></pre> <p>Generate SNFEI as a simple hex string.</p> <p>Convenience function that returns just the hash value.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>64-character lowercase hex SNFEI string.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str:\n    \"\"\"Generate SNFEI as a simple hex string.\n\n    Convenience function that returns just the hash value.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional primary street address.\n\n    Returns:\n        64-character lowercase hex SNFEI string.\n    \"\"\"\n    result = generate_snfei(legal_name, country_code, address)\n    return result.snfei.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generator.generate_snfei_with_confidence","title":"generate_snfei_with_confidence","text":"<pre><code>generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate SNFEI with confidence scoring and tier classification.</p> <p>Tier Classification: - Tier 1: Entity has LEI (global identifier) - confidence 1.0 - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95 - Tier 3: Entity uses SNFEI (computed hash) - confidence varies</p> <p>Tier 3 Confidence Scoring: - Base: 0.5 (name + country only) - +0.2 if address is provided - +0.2 if registration_date is provided - +0.1 if name is reasonably long (&gt;3 words)</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration date.</p> <code>None</code> <code>lei</code> <code>str | None</code> <p>Optional LEI (Legal Entity Identifier).</p> <code>None</code> <code>sam_uei</code> <code>str | None</code> <p>Optional SAM.gov Unique Entity Identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult with SNFEI, confidence score, and metadata.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/generator.py</code> <pre><code>def generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate SNFEI with confidence scoring and tier classification.\n\n    Tier Classification:\n    - Tier 1: Entity has LEI (global identifier) - confidence 1.0\n    - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95\n    - Tier 3: Entity uses SNFEI (computed hash) - confidence varies\n\n    Tier 3 Confidence Scoring:\n    - Base: 0.5 (name + country only)\n    - +0.2 if address is provided\n    - +0.2 if registration_date is provided\n    - +0.1 if name is reasonably long (&gt;3 words)\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration date.\n        lei: Optional LEI (Legal Entity Identifier).\n        sam_uei: Optional SAM.gov Unique Entity Identifier.\n\n    Returns:\n        SnfeiResult with SNFEI, confidence score, and metadata.\n    \"\"\"\n    fields_used = [\"legal_name\", \"country_code\"]\n\n    # Tier 1: LEI available\n    if lei and len(lei) == 20:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        # For Tier 1, we still compute SNFEI but confidence is 1.0\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=1.0,\n            tier=1,\n            fields_used=[\"lei\"] + fields_used,\n        )\n\n    # Tier 2: SAM UEI available\n    if sam_uei and len(sam_uei) == 12:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=0.95,\n            tier=2,\n            fields_used=[\"sam_uei\"] + fields_used,\n        )\n\n    # Tier 3: Compute SNFEI from attributes\n    canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n    snfei = compute_snfei(canonical)\n\n    # Calculate confidence score\n    confidence = 0.5  # Base score\n\n    if address:\n        fields_used.append(\"address\")\n        confidence += 0.2\n\n    if registration_date:\n        fields_used.append(\"registration_date\")\n        confidence += 0.2\n\n    # Bonus for longer, more specific names\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n\n    # Cap at 0.9 for Tier 3\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization","title":"localization","text":"<p>Localization Functor: Jurisdiction-Specific Transformations.</p> <p>This module loads and applies jurisdiction-specific normalization rules BEFORE the universal Normalizing Functor is applied.</p> <p>The Localization Functor L transforms raw local data into a canonical intermediate form that the universal normalizer can process:</p> <pre><code>L: RawLocal \u2192 IntermediateCanonical\nN: IntermediateCanonical \u2192 FinalCanonical\n\nSNFEI = Hash(N(L(raw_data)))\n</code></pre> Directory Structure <p>/localization/     base.yaml           # Default/fallback rules     us/         base.yaml       # US-wide rules         ca.yaml         # California-specific         ny.yaml         # New York-specific     ca/         base.yaml       # Canada-wide rules         on.yaml         # Ontario-specific         qc.yaml         # Quebec-specific</p>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for a specific jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for a specific jurisdiction.\"\"\"\n\n    jurisdiction: str  # e.g., \"us/ca\", \"ca/on\"\n    parent: str | None  # Parent jurisdiction for inheritance\n\n    # Transformation maps\n    abbreviations: dict[str, str] = field(default_factory=dict)\n    agency_names: dict[str, str] = field(default_factory=dict)\n    entity_types: dict[str, str] = field(default_factory=dict)\n\n    # Additional rules\n    rules: list[LocalizationRule] = field(default_factory=list)\n\n    # Stop words specific to this jurisdiction\n    stop_words: set[str] = field(default_factory=set)\n\n    def apply_to_name(self, name: str) -&gt; str:\n        \"\"\"Apply jurisdiction-specific transformations to a name.\n\n        Order of application:\n        1. Agency name expansions\n        2. Abbreviation expansions\n        3. Entity type standardization\n        4. Custom rules\n        \"\"\"\n        result = name.lower()\n\n        # 1. Agency names (exact match, case-insensitive)\n        for abbrev, full in self.agency_names.items():\n            # Word boundary matching\n            import re\n\n            pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n            result = re.sub(pattern, full.lower(), result)\n\n        # 2. Abbreviations\n        tokens = result.split()\n        expanded = []\n        for token in tokens:\n            if token in self.abbreviations:\n                expanded.append(self.abbreviations[token].lower())\n            else:\n                expanded.append(token)\n        result = \" \".join(expanded)\n\n        # 3. Entity types\n        for local_type, canonical_type in self.entity_types.items():\n            import re\n\n            pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n            result = re.sub(pattern, canonical_type.lower(), result)\n\n        # 4. Custom rules\n        for rule in self.rules:\n            if rule.is_regex:\n                import re\n\n                result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n            else:\n                result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n        return result\n</code></pre> apply_to_name \u00b6 <pre><code>apply_to_name(name: str) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific transformations to a name.</p> <p>Order of application: 1. Agency name expansions 2. Abbreviation expansions 3. Entity type standardization 4. Custom rules</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_to_name(self, name: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific transformations to a name.\n\n    Order of application:\n    1. Agency name expansions\n    2. Abbreviation expansions\n    3. Entity type standardization\n    4. Custom rules\n    \"\"\"\n    result = name.lower()\n\n    # 1. Agency names (exact match, case-insensitive)\n    for abbrev, full in self.agency_names.items():\n        # Word boundary matching\n        import re\n\n        pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n        result = re.sub(pattern, full.lower(), result)\n\n    # 2. Abbreviations\n    tokens = result.split()\n    expanded = []\n    for token in tokens:\n        if token in self.abbreviations:\n            expanded.append(self.abbreviations[token].lower())\n        else:\n            expanded.append(token)\n    result = \" \".join(expanded)\n\n    # 3. Entity types\n    for local_type, canonical_type in self.entity_types.items():\n        import re\n\n        pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n        result = re.sub(pattern, canonical_type.lower(), result)\n\n    # 4. Custom rules\n    for rule in self.rules:\n        if rule.is_regex:\n            import re\n\n            result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n        else:\n            result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n    return result\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationRegistry","title":"LocalizationRegistry","text":"<p>Registry for loading and caching localization configurations.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>class LocalizationRegistry:\n    \"\"\"Registry for loading and caching localization configurations.\"\"\"\n\n    def __init__(self, config_dir: Path | None = None):\n        \"\"\"Initialize the registry.\n\n        Args:\n            config_dir: Optional path to localization YAML files.\n                       If None, only built-in configs are available.\n        \"\"\"\n        self.config_dir = config_dir\n        self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n\n    def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n        \"\"\"Get localization config for a jurisdiction.\n\n        Falls back through parent jurisdictions if specific config not found.\n        Merges child config with parent config for inheritance.\n\n        Args:\n            jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                         Case-insensitive - will be normalized to lowercase.\n\n        Returns:\n            LocalizationConfig for the jurisdiction (merged with parent).\n        \"\"\"\n        # Normalize to lowercase\n        jurisdiction = jurisdiction.lower()\n\n        # Check if we have a merged config cached\n        cache_key = f\"_merged_{jurisdiction}\"\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Get the base config for this jurisdiction\n        if jurisdiction in self._cache:\n            config = self._cache[jurisdiction]\n        elif self.config_dir:\n            config = self._load_yaml(jurisdiction)\n            if config:\n                self._cache[jurisdiction] = config\n            else:\n                config = None\n        else:\n            config = None\n\n        # If no config found, fall back to parent\n        if config is None:\n            if \"/\" in jurisdiction:\n                parent = jurisdiction.rsplit(\"/\", 1)[0]\n                return self.get_config(parent)\n            # Return empty config as last resort\n            return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n        # If config has a parent, merge with parent config\n        if config.parent:\n            parent_config = self.get_config(config.parent)\n            merged = self.merge_configs(config, parent_config)\n            self._cache[cache_key] = merged\n            return merged\n\n        return config\n\n    def _load_yaml(self, jurisdiction: str) -&gt; LocalizationConfig | None:\n        \"\"\"Load config from YAML file.\n\n        Expected paths:\n            - {config_dir}/{country}/base.yaml for country-level (e.g., US, CA)\n            - {config_dir}/{country}/{region}.yaml for region-level (e.g., us/ca, ca/on)\n        \"\"\"\n        if not self.config_dir:\n            return None\n\n        # Determine the YAML file path\n        if \"/\" in jurisdiction:\n            # Region-level: us/ca -&gt; us/ca.yaml\n            parts = jurisdiction.split(\"/\")\n            yaml_path = self.config_dir / parts[0] / f\"{parts[1]}.yaml\"\n        else:\n            # Country-level: US -&gt; us/base.yaml\n            yaml_path = self.config_dir / jurisdiction / \"base.yaml\"\n\n        if not yaml_path.exists():\n            return None\n\n        try:\n            with yaml_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n\n            if not data:\n                return None\n\n            # Parse rules if present\n            rules = []\n            for rule_data in data.get(\"rules\", []):\n                rules.append(\n                    LocalizationRule(\n                        pattern=rule_data.get(\"pattern\", \"\"),\n                        replacement=rule_data.get(\"replacement\", \"\"),\n                        is_regex=rule_data.get(\"is_regex\", False),\n                        context=rule_data.get(\"context\"),\n                    )\n                )\n\n            return LocalizationConfig(\n                jurisdiction=data.get(\"jurisdiction\", jurisdiction),\n                parent=data.get(\"parent\"),\n                abbreviations=data.get(\"abbreviations\", {}),\n                agency_names=data.get(\"agency_names\", {}),\n                entity_types=data.get(\"entity_types\", {}),\n                rules=rules,\n                stop_words=set(data.get(\"stop_words\", [])),\n            )\n        except Exception as e:\n            # Log error but don't crash\n            print(f\"Warning: Failed to load localization YAML {yaml_path}: {e}\")\n            return None\n\n    def merge_configs(\n        self, child: LocalizationConfig, parent: LocalizationConfig\n    ) -&gt; LocalizationConfig:\n        \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n        merged_abbrevs = dict(parent.abbreviations)\n        merged_abbrevs.update(child.abbreviations)\n\n        merged_agencies = dict(parent.agency_names)\n        merged_agencies.update(child.agency_names)\n\n        merged_types = dict(parent.entity_types)\n        merged_types.update(child.entity_types)\n\n        return LocalizationConfig(\n            jurisdiction=child.jurisdiction,\n            parent=parent.jurisdiction,\n            abbreviations=merged_abbrevs,\n            agency_names=merged_agencies,\n            entity_types=merged_types,\n            rules=parent.rules + child.rules,\n            stop_words=parent.stop_words | child.stop_words,\n        )\n</code></pre> __init__ \u00b6 <pre><code>__init__(config_dir: Path | None = None)\n</code></pre> <p>Initialize the registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>Path | None</code> <p>Optional path to localization YAML files.        If None, only built-in configs are available.</p> <code>None</code> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def __init__(self, config_dir: Path | None = None):\n    \"\"\"Initialize the registry.\n\n    Args:\n        config_dir: Optional path to localization YAML files.\n                   If None, only built-in configs are available.\n    \"\"\"\n    self.config_dir = config_dir\n    self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n</code></pre> get_config \u00b6 <pre><code>get_config(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction.</p> <p>Falls back through parent jurisdictions if specific config not found. Merges child config with parent config for inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\", \"ca/on\").          Case-insensitive - will be normalized to lowercase.</p> required <p>Returns:</p> Type Description <code>LocalizationConfig</code> <p>LocalizationConfig for the jurisdiction (merged with parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction.\n\n    Falls back through parent jurisdictions if specific config not found.\n    Merges child config with parent config for inheritance.\n\n    Args:\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                     Case-insensitive - will be normalized to lowercase.\n\n    Returns:\n        LocalizationConfig for the jurisdiction (merged with parent).\n    \"\"\"\n    # Normalize to lowercase\n    jurisdiction = jurisdiction.lower()\n\n    # Check if we have a merged config cached\n    cache_key = f\"_merged_{jurisdiction}\"\n    if cache_key in self._cache:\n        return self._cache[cache_key]\n\n    # Get the base config for this jurisdiction\n    if jurisdiction in self._cache:\n        config = self._cache[jurisdiction]\n    elif self.config_dir:\n        config = self._load_yaml(jurisdiction)\n        if config:\n            self._cache[jurisdiction] = config\n        else:\n            config = None\n    else:\n        config = None\n\n    # If no config found, fall back to parent\n    if config is None:\n        if \"/\" in jurisdiction:\n            parent = jurisdiction.rsplit(\"/\", 1)[0]\n            return self.get_config(parent)\n        # Return empty config as last resort\n        return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n    # If config has a parent, merge with parent config\n    if config.parent:\n        parent_config = self.get_config(config.parent)\n        merged = self.merge_configs(config, parent_config)\n        self._cache[cache_key] = merged\n        return merged\n\n    return config\n</code></pre> merge_configs \u00b6 <pre><code>merge_configs(\n    child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig\n</code></pre> <p>Merge child config with parent (child overrides parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def merge_configs(\n    self, child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig:\n    \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n    merged_abbrevs = dict(parent.abbreviations)\n    merged_abbrevs.update(child.abbreviations)\n\n    merged_agencies = dict(parent.agency_names)\n    merged_agencies.update(child.agency_names)\n\n    merged_types = dict(parent.entity_types)\n    merged_types.update(child.entity_types)\n\n    return LocalizationConfig(\n        jurisdiction=child.jurisdiction,\n        parent=parent.jurisdiction,\n        abbreviations=merged_abbrevs,\n        agency_names=merged_agencies,\n        entity_types=merged_types,\n        rules=parent.rules + child.rules,\n        stop_words=parent.stop_words | child.stop_words,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationRule","title":"LocalizationRule  <code>dataclass</code>","text":"<p>A single localization transformation rule.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationRule:\n    \"\"\"A single localization transformation rule.\"\"\"\n\n    pattern: str  # Text to match (case-insensitive)\n    replacement: str  # Replacement text\n    is_regex: bool = False  # Whether pattern is a regex\n    context: str | None = None  # Optional context (e.g., \"agency\", \"school\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.apply_localization","title":"apply_localization","text":"<pre><code>apply_localization(name: str, jurisdiction: str) -&gt; str\n</code></pre> <p>Apply localization transforms to a name.</p> <p>This is the Localization Functor L.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw entity name.</p> required <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name with jurisdiction-specific transforms applied.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_localization(name: str, jurisdiction: str) -&gt; str:\n    \"\"\"Apply localization transforms to a name.\n\n    This is the Localization Functor L.\n\n    Args:\n        name: Raw entity name.\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\").\n\n    Returns:\n        Name with jurisdiction-specific transforms applied.\n    \"\"\"\n    config = get_localization_config(jurisdiction)\n    return config.apply_to_name(name)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.get_localization_config","title":"get_localization_config","text":"<pre><code>get_localization_config(\n    jurisdiction: str,\n) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction (convenience function).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_localization_config(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction (convenience function).\"\"\"\n    return _registry.get_config(jurisdiction)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer","title":"normalizer","text":"<p>CEP Core Linker: The Normalizing Functor.</p> <p>This module implements the universal normalization pipeline that transforms entity attributes into hash-ready canonical form for SNFEI generation.</p> <p>The architecture follows the Category Theory foundation: - Localization Functor: Jurisdiction-specific transforms (YAML-driven) - Normalizing Functor: Universal normalization steps (this module) - SNFEI Hash: Final SHA-256 computation</p> Directory Structure <p>/snfei/     normalizer.py      # Universal normalization (this file)     generator.py       # SNFEI hash generation     localization.py    # Localization functor implementation /localization/     us/               # US state-specific rules         ca.yaml         ny.yaml     ca/               # Canada province-specific rules         on.yaml         qc.yaml     base.yaml         # Fallback rules</p> Mathematical Foundation <p>The Normalizing Functor N transforms the category of Raw Entity Data into the category of Canonical Entity Data:</p> <p>N: RawEntity \u2192 CanonicalEntity</p> <p>Where N preserves identity (same entity always maps to same canonical form) and composition (N(L(x)) = N \u2218 L(x) where L is the localization functor).</p>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.CanonicalInput","title":"CanonicalInput  <code>dataclass</code>","text":"<p>Normalized input for SNFEI hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>@dataclass\nclass CanonicalInput:\n    \"\"\"Normalized input for SNFEI hashing.\"\"\"\n\n    legal_name_normalized: str\n    address_normalized: str | None\n    country_code: str\n    registration_date: str | None\n\n    def to_hash_string(self) -&gt; str:\n        \"\"\"Generate the concatenated string for hashing.\n\n        Format:\n            legal_name_normalized|address_normalized|country_code|registration_date\n\n        Empty/None fields are included as empty strings to maintain\n        consistent field positions.\n        \"\"\"\n        parts = [\n            self.legal_name_normalized,\n            self.address_normalized or \"\",\n            self.country_code,\n            self.registration_date or \"\",\n        ]\n        return \"|\".join(parts)\n\n    def to_hash_string_v2(self) -&gt; str:\n        \"\"\"Alternative format that omits empty fields.\n\n        This produces shorter strings but requires all implementations\n        to handle optional fields identically.\n        \"\"\"\n        parts = [self.legal_name_normalized]\n        if self.address_normalized:\n            parts.append(self.address_normalized)\n        parts.append(self.country_code)\n        if self.registration_date:\n            parts.append(self.registration_date)\n        return \"|\".join(parts)\n</code></pre> to_hash_string \u00b6 <pre><code>to_hash_string() -&gt; str\n</code></pre> <p>Generate the concatenated string for hashing.</p> Format <p>legal_name_normalized|address_normalized|country_code|registration_date</p> <p>Empty/None fields are included as empty strings to maintain consistent field positions.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def to_hash_string(self) -&gt; str:\n    \"\"\"Generate the concatenated string for hashing.\n\n    Format:\n        legal_name_normalized|address_normalized|country_code|registration_date\n\n    Empty/None fields are included as empty strings to maintain\n    consistent field positions.\n    \"\"\"\n    parts = [\n        self.legal_name_normalized,\n        self.address_normalized or \"\",\n        self.country_code,\n        self.registration_date or \"\",\n    ]\n    return \"|\".join(parts)\n</code></pre> to_hash_string_v2 \u00b6 <pre><code>to_hash_string_v2() -&gt; str\n</code></pre> <p>Alternative format that omits empty fields.</p> <p>This produces shorter strings but requires all implementations to handle optional fields identically.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def to_hash_string_v2(self) -&gt; str:\n    \"\"\"Alternative format that omits empty fields.\n\n    This produces shorter strings but requires all implementations\n    to handle optional fields identically.\n    \"\"\"\n    parts = [self.legal_name_normalized]\n    if self.address_normalized:\n        parts.append(self.address_normalized)\n    parts.append(self.country_code)\n    if self.registration_date:\n        parts.append(self.registration_date)\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical input structure from raw entity data.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration/formation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput with all fields normalized.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical input structure from raw entity data.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration/formation date.\n\n    Returns:\n        CanonicalInput with all fields normalized.\n    \"\"\"\n    return CanonicalInput(\n        legal_name_normalized=normalize_legal_name(legal_name),\n        address_normalized=normalize_address(address) if address else None,\n        country_code=country_code.upper(),\n        registration_date=normalize_registration_date(registration_date)\n        if registration_date\n        else None,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(\n    address: str, remove_secondary: bool = True\n) -&gt; str\n</code></pre> <p>Normalize a street address for SNFEI hashing.</p> <p>Pipeline: 1. Lowercase 2. ASCII transliteration 3. Remove secondary unit designators (apt, suite, etc.) 4. Remove punctuation 5. Expand postal abbreviations 6. Collapse whitespace</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Raw street address.</p> required <code>remove_secondary</code> <code>bool</code> <p>Whether to remove apartment/suite numbers.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized address string.</p> Example <p>normalize_address(\"123 N. Main St., Suite 400\") \"123 north main street\"</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_address(\n    address: str,\n    remove_secondary: bool = True,\n) -&gt; str:\n    \"\"\"Normalize a street address for SNFEI hashing.\n\n    Pipeline:\n    1. Lowercase\n    2. ASCII transliteration\n    3. Remove secondary unit designators (apt, suite, etc.)\n    4. Remove punctuation\n    5. Expand postal abbreviations\n    6. Collapse whitespace\n\n    Args:\n        address: Raw street address.\n        remove_secondary: Whether to remove apartment/suite numbers.\n\n    Returns:\n        Normalized address string.\n\n    Example:\n        &gt;&gt;&gt; normalize_address(\"123 N. Main St., Suite 400\")\n        \"123 north main street\"\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # 1. Lowercase\n    text = address.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove secondary unit designators\n    if remove_secondary:\n        for pattern in SECONDARY_UNIT_PATTERNS:\n            text = re.sub(pattern, \"\", text, flags=re.IGNORECASE)\n\n    # 4. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 5. Collapse whitespace first\n    text = _collapse_whitespace(text)\n\n    # 6. Expand postal abbreviations\n    tokens = text.split()\n    expanded = []\n    for token in tokens:\n        if token in US_ADDRESS_EXPANSIONS:\n            expanded.append(US_ADDRESS_EXPANSIONS[token])\n        else:\n            expanded.append(token)\n    text = \" \".join(expanded)\n\n    # 7. Final trim\n    return text.strip()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str\n</code></pre> <p>Apply the universal normalization pipeline to a legal name.</p> <p>Pipeline (in order): 1. Convert to lowercase 2. ASCII transliteration 3. Remove punctuation 4. Collapse whitespace 5. Expand abbreviations 6. Remove stop words (optional) 7. Final trim</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>remove_stop_words</code> <code>bool</code> <p>Whether to filter out stop words.</p> <code>True</code> <code>preserve_initial_stop</code> <code>bool</code> <p>If True, preserve stop word at start of name.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized name suitable for SNFEI hashing.</p> Example <p>normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\") \"springfield unified school district incorporated\"</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str:\n    \"\"\"Apply the universal normalization pipeline to a legal name.\n\n    Pipeline (in order):\n    1. Convert to lowercase\n    2. ASCII transliteration\n    3. Remove punctuation\n    4. Collapse whitespace\n    5. Expand abbreviations\n    6. Remove stop words (optional)\n    7. Final trim\n\n    Args:\n        name: Raw legal name from source system.\n        remove_stop_words: Whether to filter out stop words.\n        preserve_initial_stop: If True, preserve stop word at start of name.\n\n    Returns:\n        Normalized name suitable for SNFEI hashing.\n\n    Example:\n        &gt;&gt;&gt; normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\")\n        \"springfield unified school district incorporated\"\n    \"\"\"\n    if not name:\n        return \"\"\n\n    # 1. Lowercase\n    text = name.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 4. Collapse whitespace\n    text = _collapse_whitespace(text)\n\n    # 5. Expand abbreviations\n    text = _expand_abbreviations(text)\n\n    # 6. Remove stop words\n    if remove_stop_words:\n        text = _remove_stop_words(text, preserve_initial=preserve_initial_stop)\n\n    # 7. Final collapse and trim\n    return _collapse_whitespace(text)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(date_str: str) -&gt; str | None\n</code></pre> <p>Normalize a registration date to ISO 8601 format.</p> <p>Returns None if date cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string in various formats.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO 8601 date string (YYYY-MM-DD) or None.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_registration_date(date_str: str) -&gt; str | None:\n    \"\"\"Normalize a registration date to ISO 8601 format.\n\n    Returns None if date cannot be parsed.\n\n    Args:\n        date_str: Date string in various formats.\n\n    Returns:\n        ISO 8601 date string (YYYY-MM-DD) or None.\n    \"\"\"\n    if not date_str:\n        return None\n\n    # Remove extra whitespace\n    date_str = date_str.strip()\n\n    # Try common date patterns\n\n    patterns = [\n        # ISO format\n        (r\"^(\\d{4})-(\\d{2})-(\\d{2})$\", \"%Y-%m-%d\"),\n        # US format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%m/%d/%Y\"),\n        (r\"^(\\d{1,2})-(\\d{1,2})-(\\d{4})$\", \"%m-%d-%Y\"),\n        # European format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%d/%m/%Y\"),\n        # Year only\n        (r\"^(\\d{4})$\", \"%Y\"),\n    ]\n\n    for pattern, fmt in patterns:\n        if re.match(pattern, date_str):\n            try:\n                if fmt == \"%Y\":\n                    # Year only - use January 1\n                    return f\"{date_str}-01-01\"\n                dt = datetime.strptime(date_str, fmt)\n                return dt.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n    return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.vocab","title":"vocab","text":"<p>Vocabulary module for civic-interconnect CEP.</p> <p>This module provides vocabulary-related functionality.</p>"},{"location":"en/api/#civic_interconnect.cli","title":"cli","text":""},{"location":"en/api/#civic_interconnect.cli.cli","title":"cli","text":"<p>Command-line interface for the Civic Exchange Protocol.</p> <p>This module provides CLI commands for: - snfei: Generate an SNFEI for an entity name and country - version: Display the package version - validate-json: Validate JSON files against CEP schemas - codegen-rust: Generate Rust types from CEP JSON Schemas</p>"},{"location":"en/api/#civic_interconnect.cli.cli.codegen_rust","title":"codegen_rust","text":"<pre><code>codegen_rust(\n    entity_schema: Path | None = None,\n    relationship_schema: Path | None = None,\n    exchange_schema: Path | None = None,\n    entity_out: Path | None = None,\n    relationship_out: Path | None = None,\n    exchange_out: Path | None = None,\n) -&gt; None\n</code></pre> <p>Generate Rust types from CEP JSON Schemas into generated.rs files.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command(\"codegen-rust\")\ndef codegen_rust(\n    entity_schema: Path | None = None,\n    relationship_schema: Path | None = None,\n    exchange_schema: Path | None = None,\n    entity_out: Path | None = None,\n    relationship_out: Path | None = None,\n    exchange_out: Path | None = None,\n) -&gt; None:\n    \"\"\"Generate Rust types from CEP JSON Schemas into generated.rs files.\"\"\"\n    if entity_schema is None:\n        entity_schema = DEFAULT_ENTITY_SCHEMA\n    if relationship_schema is None:\n        relationship_schema = DEFAULT_RELATIONSHIP_SCHEMA\n    if exchange_schema is None:\n        exchange_schema = DEFAULT_EXCHANGE_SCHEMA\n    if entity_out is None:\n        entity_out = DEFAULT_ENTITY_OUT\n    if relationship_out is None:\n        relationship_out = DEFAULT_RELATIONSHIP_OUT\n    if exchange_out is None:\n        exchange_out = DEFAULT_EXCHANGE_OUT\n\n    # Adjust struct names here if your Rust crates use different ones.\n    write_generated_rust(entity_schema, \"EntityRecord\", entity_out)\n    write_generated_rust(relationship_schema, \"RelationshipRecord\", relationship_out)\n    write_generated_rust(exchange_schema, \"ExchangeRecord\", exchange_out)\n\n    typer.echo(f\"Wrote {entity_out}\")\n    typer.echo(f\"Wrote {relationship_out}\")\n    typer.echo(f\"Wrote {exchange_out}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.snfei","title":"snfei","text":"<pre><code>snfei(\n    legal_name: str = typer.Argument(\n        ..., help='Raw legal name'\n    ),\n    country_code: str = typer.Option(\n        'US',\n        '--country-code',\n        '-c',\n        help='ISO country code',\n    ),\n) -&gt; None\n</code></pre> <p>Generate an SNFEI for an entity name and country.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef snfei(\n    legal_name: str = typer.Argument(..., help=\"Raw legal name\"),\n    country_code: str = typer.Option(\"US\", \"--country-code\", \"-c\", help=\"ISO country code\"),\n) -&gt; None:\n    \"\"\"Generate an SNFEI for an entity name and country.\"\"\"\n    result = generate_snfei_with_confidence(\n        legal_name=legal_name,\n        country_code=country_code,\n    )\n    typer.echo(f\"SNFEI: {result.snfei.value}\")\n    typer.echo(f\"Tier: {result.tier}, confidence: {result.confidence_score}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.validate_json","title":"validate_json","text":"<pre><code>validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        '--schema',\n        '-s',\n        help='Schema name (for example: entity, exchange, relationship, snfei).',\n    ),\n    recursive: bool = typer.Option(\n        False,\n        '--recursive',\n        '-r',\n        help='Recurse into subdirectories when validating a directory.',\n    ),\n) -&gt; None\n</code></pre> <p>Validate JSON file(s) against a CEP JSON Schema.</p> <p>Behavior: - If PATH is a file, validates that single JSON file. - If PATH is a directory, validates all *.json files within it.   Use --recursive to walk subdirectories.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        \"--schema\",\n        \"-s\",\n        help=\"Schema name (for example: entity, exchange, relationship, snfei).\",\n    ),\n    recursive: bool = typer.Option(\n        False,\n        \"--recursive\",\n        \"-r\",\n        help=\"Recurse into subdirectories when validating a directory.\",\n    ),\n) -&gt; None:\n    \"\"\"Validate JSON file(s) against a CEP JSON Schema.\n\n    Behavior:\n    - If PATH is a file, validates that single JSON file.\n    - If PATH is a directory, validates all *.json files within it.\n      Use --recursive to walk subdirectories.\n    \"\"\"\n    if path is None:\n        typer.echo(\"Error: Path argument is required.\")\n        raise typer.Exit(code=1)\n\n    summary: ValidationSummary = validate_json_path(\n        path=path,\n        schema_name=schema,\n        recursive=recursive,\n    )\n\n    if not summary.results:\n        typer.echo(\"No JSON files found to validate.\")\n        raise typer.Exit(code=1)\n\n    errors_found = False\n\n    for result in summary.results:\n        if result.ok:\n            typer.echo(f\"[OK] {result.path}\")\n        else:\n            errors_found = True\n            typer.echo(f\"[ERROR] {result.path}\")\n            for err in result.errors:\n                typer.echo(f\"  - {err}\")\n\n    if errors_found:\n        typer.echo(\"Validation completed with errors.\")\n        raise typer.Exit(code=1)\n\n    typer.echo(\"All files validated successfully.\")\n    raise typer.Exit(code=0)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.version_cmd","title":"version_cmd","text":"<pre><code>version_cmd() -&gt; None\n</code></pre> <p>Show package version.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef version_cmd() -&gt; None:\n    \"\"\"Show package version.\"\"\"\n    try:\n        v = version(\"civic-interconnect\")\n    except PackageNotFoundError:\n        v = \"0.0.0\"\n    typer.echo(v)\n</code></pre>"},{"location":"en/cli/","title":"CLI Reference","text":""},{"location":"en/cli/#quick-help","title":"Quick help","text":"<pre><code># Show top-level help\ncx --help\n\n# Show help for a subcommand\ncx &lt;subcommand&gt; --help\n</code></pre>"},{"location":"en/schemas/","title":"Civic Interconnect Schemas","text":"<p>These schemas are the source of truth for CEP:</p>"},{"location":"en/schemas/#schemas","title":"Schemas","text":""},{"location":"en/schemas/#github-raw-urls","title":"GitHub Raw URLs","text":"<p>All CEP schemas are intended to be resolved by their $id from GitHub raw URLs; examples of $ref assume that hosting pattern.</p>"},{"location":"en/schemas/#timestamp-requirements","title":"Timestamp Requirements","text":"<ul> <li>Timestamp regex is strict. Required: YYYY-MM-DDTHH:MM:SS.microsecondsZ exactly.</li> <li>Many systems will only give milliseconds or whole seconds.</li> <li>Round / pad when you only have millisecond or second precision.</li> <li>Implementers MUST canonicalize to exactly 6 digits (pad with zeros or round) before attestation.</li> </ul>"},{"location":"en/schemas/#resolution-confidence","title":"Resolution Confidence","text":"<p>If score &lt; 1.0, you SHOULD include methodUri and sourceRecordCount.</p>"},{"location":"en/schemas/#cep-schemas","title":"CEP Schemas","text":"Schema Description cep.entity.schema.json Entity records cep.entity.identifier-scheme.schema.json Identifier scheme metadata cep.relationship.schema.json Relationship records cep.exchange.schema.json Exchange records cep.record-envelope.schema.json Core envelope shared by all record families cep.vocabulary.schema.json Vocabulary definition meta-schema cep.p3tag.schema.json Per-post tagging model README.md Schema overview and documentation"},{"location":"en/concepts/category-theory-foundation/","title":"Category Theory Foundation for CEP","text":""},{"location":"en/concepts/category-theory-foundation/#overview","title":"Overview","text":"<p>This document provides a formal categorical semantics for the Civic Exchange Protocol (CEP). The goal is to prove that the system's design is mathematically sound, ensuring that compositions of civic relationships and exchanges behave predictably and that the Verifiable ID system constitutes a proper universal construction.</p>"},{"location":"en/concepts/category-theory-foundation/#1-the-category-civic","title":"1. The Category Civic","text":"<p>We define a category Civic as follows:</p>"},{"location":"en/concepts/category-theory-foundation/#objects","title":"Objects","text":"<p>The objects of Civic are attested civic entities. Each object E represents: - A verified legal entity (government agency, contractor, nonprofit, individual) - With a canonical Verifiable ID - At a specific point in time (revision number)</p> <p>Formally: <code>Ob(Civic) = { E | E is a valid CEP entity record }</code></p>"},{"location":"en/concepts/category-theory-foundation/#morphisms","title":"Morphisms","text":"<p>The morphisms in Civic are relationships and exchanges between entities. A morphism <code>f: A \u2192 B</code> represents a directed flow of legal obligation, value, or authority from entity A to entity B.</p> <p>There are two kinds of morphisms:</p> <ol> <li>Relationship morphisms: Represent the legal basis for interaction</li> <li><code>grant: FederalAgency \u2192 StateAgency</code></li> <li><code>contract: Agency \u2192 Contractor</code></li> <li> <p><code>subcontract: PrimeContractor \u2192 Subcontractor</code></p> </li> <li> <p>Exchange morphisms: Represent actual value flows within relationships</p> </li> <li><code>disburse: GrantingAgency \u2192 Grantee</code></li> <li><code>pay: ContractingOffice \u2192 Vendor</code></li> </ol>"},{"location":"en/concepts/category-theory-foundation/#identity-morphism","title":"Identity Morphism","text":"<p>For each entity E, the identity morphism <code>id_E: E \u2192 E</code> represents the entity's self-attestation\u2014the record where the entity attests to its own existence and status. This is the initial entity record with <code>previousRecordHash = null</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#composition","title":"Composition","text":"<p>Given morphisms <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code>, the composition <code>g \u2218 f: A \u2192 C</code> represents the compositional provenance chain.</p> <p>Example: Federal grant flows through a state to a local school district:</p> <pre><code>f: FederalDOE \u2192 StateEducationDept    (grant-award relationship)\ng: StateEducationDept \u2192 LocalDistrict  (subgrant relationship)\n\ng \u2218 f: FederalDOE \u2192 LocalDistrict      (derived provenance)\n</code></pre> <p>This composition is captured in the <code>provenanceChain.fundingChainTag</code> field as <code>FEDERAL&gt;STATE&gt;LOCAL</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#associativity","title":"Associativity","text":"<p>Composition must be associative: <code>(h \u2218 g) \u2218 f = h \u2218 (g \u2218 f)</code></p> <p>For provenance chains: <pre><code>FED \u2192 STATE \u2192 COUNTY \u2192 CONTRACTOR\n\n((FED \u2192 STATE) \u2192 COUNTY) \u2192 CONTRACTOR = (FED \u2192 STATE) \u2192 (COUNTY \u2192 CONTRACTOR)\n</code></pre></p> <p>Both yield the same ultimate provenance: funds originating from FED, flowing through STATE and COUNTY, to CONTRACTOR. The <code>fundingChainTag</code> is identical regardless of grouping.</p> <p>Implementation guarantee: The <code>parentRelationshipId</code> and <code>parentExchangeId</code> fields create an explicit linked list that ensures associativity. You can trace back from any exchange to its ultimate source by following the chain.</p>"},{"location":"en/concepts/category-theory-foundation/#2-the-verifiable-id-as-a-universal-property","title":"2. The Verifiable ID as a Universal Property","text":""},{"location":"en/concepts/category-theory-foundation/#the-problem-multiple-representations","title":"The Problem: Multiple Representations","text":"<p>A single real-world entity may appear in many source systems with different identifiers: - SAM.gov: <code>J6H4FB3N5YK7</code> - State campaign finance: <code>VENDOR-2024-0093</code> - County procurement: <code>Acme Consulting LLC</code> (no ID, just a name) - Federal LEI system: <code>5493001KJTIIGC8Y1R12</code></p> <p>Each source system defines its own category of records, call them SAM, StateCF, CountyProc, LEI.</p>"},{"location":"en/concepts/category-theory-foundation/#the-diagram-to-commute","title":"The Diagram to Commute","text":"<p>We have partial identity mappings (entity resolution functions) between these systems: <pre><code>        SAM\n         \u2191\n         |  \u03c6_sam\n         |\n      ENTITY  \u2190---------- LEI\n         |      \u03c6_lei\n         |\n         \u2193  \u03c6_county\n    CountyProc\n</code></pre></p> <p>Each <code>\u03c6_X</code> is a functor from the source category to Civic that maps source records to entities.</p>"},{"location":"en/concepts/category-theory-foundation/#the-limit-construction","title":"The Limit Construction","text":"<p>The Entity <code>verifiableId</code> acts as the limit (specifically, a product in the relevant slice category) of the diagram of source identifiers.</p> <p>Definition: For an entity E appearing in source systems S\u2081, S\u2082, ..., S\u2099 with identifiers id\u2081, id\u2082, ..., id\u2099 respectively, the Verifiable ID is the unique object V equipped with projections: <pre><code>\u03c0_1: V \u2192 S\u2081   (maps V to id\u2081)\n\u03c0_2: V \u2192 S\u2082   (maps V to id\u2082)\n...\n\u03c0_n: V \u2192 S\u2099   (maps V to id\u2099)\n</code></pre></p> <p>Such that for any other object W with maps to all S\u1d62, there exists a unique map <code>u: W \u2192 V</code> making all triangles commute.</p> <p>In CEP terms: The <code>identifiers</code> object in entity is exactly this limit, it holds all known identifiers for the entity:</p> <pre><code>\"identifiers\": {\n  \"samUei\": \"J6H4FB3N5YK7\",\n  \"lei\": \"5493001KJTIIGC8Y1R12\",\n  \"snfei\": \"a3b2c1d4e5f6...\",\n  \"additionalSchemes\": [\n    {\"schemeUri\": \"https://state.gov/cf\", \"value\": \"VENDOR-2024-0093\"}\n  ]\n}\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-universal-property-guarantee","title":"The Universal Property Guarantee","text":"<p>The <code>verifiableId</code> (<code>entity:{scheme}:{value}</code>) provides the universal property:</p> <ol> <li> <p>Existence: For any entity in any source system, there exists an entity record with a verifiableId that subsumes all its known identifiers.</p> </li> <li> <p>Uniqueness: If two entity records claim to represent the same entity (have overlapping source identifiers), they MUST have the same verifiableId\u2014or one is an error requiring resolution.</p> </li> <li> <p>Confidence-Weighted Resolution: The <code>resolutionConfidence.score</code> field acknowledges that in practice, entity resolution is probabilistic. A score of 1.0 indicates authoritative identity (the entity self-attested or the source is canonical). Lower scores indicate probabilistic matching.</p> </li> </ol>"},{"location":"en/concepts/category-theory-foundation/#3-functors-the-bridge-to-external-standards","title":"3. Functors: The Bridge to External Standards","text":""},{"location":"en/concepts/category-theory-foundation/#the-xbrl-functor","title":"The XBRL Functor","text":"<p>Define <code>F_xbrl: Civic \u2192 XBRL</code> as a functor mapping: - entities \u2192 XBRL reporting entities - exchanges \u2192 XBRL fact instances</p> <p>This functor must preserve composition: if <code>g \u2218 f</code> is a provenance chain in Civic, then <code>F(g) \u2218 F(f)</code> must be a valid XBRL reporting chain.</p> <p>Implementation: The <code>categorization.gtasAccountCode</code> field in exchange records provides the data needed for this functor to operate\u2014it maps CEP exchanges to Treasury reporting concepts.</p>"},{"location":"en/concepts/category-theory-foundation/#the-w3c-prov-functor","title":"The W3C PROV Functor","text":"<p>Define <code>F_prov: Civic \u2192 PROV</code> mapping: - entities \u2192 <code>prov:Entity</code> - relationships \u2192 <code>prov:Activity</code> (the act of establishing a relationship) - exchanges \u2192 <code>prov:Activity</code> (the act of exchanging value) - Attestations \u2192 <code>prov:Agent</code> + <code>prov:wasAttributedTo</code></p> <p>The <code>attestation</code> block in every CEP record provides exactly the data needed for this mapping: - <code>attestorId</code> \u2192 <code>prov:Agent</code> - <code>attestationTimestamp</code> \u2192 <code>prov:atTime</code> - <code>proofValue</code> \u2192 provenance integrity proof</p>"},{"location":"en/concepts/category-theory-foundation/#4-the-amendment-chain-as-a-categorical-construction","title":"4. The Amendment Chain as a Categorical Construction","text":""},{"location":"en/concepts/category-theory-foundation/#the-category-of-revisions","title":"The Category of Revisions","text":"<p>For a given entity E, define the category Rev(E) where: - Objects are revisions: E\u2081, E\u2082, E\u2083, ... - Morphisms are amendment relationships: <code>amend: E\u1d62 \u2192 E\u1d62\u208a\u2081</code></p> <p>This forms a total order (a thin category where there's at most one morphism between any two objects).</p>"},{"location":"en/concepts/category-theory-foundation/#hash-chains-as-functors","title":"Hash Chains as Functors","text":"<p>The <code>previousRecordHash</code> field defines a functor <code>H: Rev(E) \u2192 HashChain</code> where HashChain is the category of SHA-256 hash values with \"derived-from\" morphisms.</p> <p>Preservation property: If <code>E\u1d62 \u2192amend E\u1d62\u208a\u2081</code>, then <code>H(E\u1d62)</code> is embedded in <code>E\u1d62\u208a\u2081.previousRecordHash</code>, creating an immutable audit trail.</p> <p>This is the categorical equivalent of a blockchain's hash chain, but without requiring distributed consensus\u2014the attesting node is responsible for chain integrity.</p>"},{"location":"en/concepts/category-theory-foundation/#5-the-slice-category-for-jurisdictional-scoping","title":"5. The Slice Category for Jurisdictional Scoping","text":""},{"location":"en/concepts/category-theory-foundation/#jurisdictional-restriction","title":"Jurisdictional Restriction","text":"<p>For a given jurisdiction J (e.g., <code>US-CA</code>), define the slice category <code>Civic/J</code> where: - Objects are entities with <code>jurisdictionIso</code> compatible with J - Morphisms are relationships/exchanges within that jurisdiction</p> <p>This allows queries like \"show me all contracts in California\" to be formalized as working within <code>Civic/US-CA</code> rather than searching all of Civic.</p>"},{"location":"en/concepts/category-theory-foundation/#the-inclusion-functor","title":"The Inclusion Functor","text":"<p>The forgetful functor <code>U: Civic/J \u2192 Civic</code> embeds jurisdictional data back into the global category, enabling cross-jurisdictional queries while preserving local structure.</p>"},{"location":"en/concepts/category-theory-foundation/#6-verification-the-proof-subcategory","title":"6. Verification: The Proof Subcategory","text":""},{"location":"en/concepts/category-theory-foundation/#defining-verification","title":"Defining Verification","text":"<p>A verified object or morphism is one where: 1. The <code>attestation.proofValue</code> is cryptographically valid 2. The <code>attestation.verificationMethodUri</code> resolves to a valid public key 3. If <code>anchorUri</code> is provided, the anchor can be independently verified</p>"},{"location":"en/concepts/category-theory-foundation/#the-subcategory-of-verified-records","title":"The Subcategory of Verified Records","text":"<p>Define Civic_verified \u2282 Civic as the full subcategory of verified records.</p> <p>The inclusion <code>I: Civic_verified \u2192 Civic</code> is faithful (injective on morphisms), meaning verification status is preserved under composition.</p> <p>Practical implication: If both <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code> are verified, then <code>g \u2218 f: A \u2192 C</code> can be marked as having verified provenance\u2014the entire chain is trustworthy.</p>"},{"location":"en/concepts/category-theory-foundation/#7-summary-why-category-theory","title":"7. Summary: Why Category Theory?","text":"Categorical Concept CEP Implementation Benefit Objects entities Formalized identity Morphisms relationships, exchanges Typed, directed flows Composition <code>parentRelationshipId</code>, <code>fundingChainTag</code> Provenance tracing Identity Self-attestation (revision 1) Entity lifecycle start Limit/Universal Property Verifiable ID + <code>identifiers</code> Canonical identity resolution Functors XBRL, PROV mappings Interoperability Slice categories Jurisdictional scoping Efficient local queries Hash chain functor <code>previousRecordHash</code> Immutable audit trail"},{"location":"en/concepts/category-theory-foundation/#the-core-theorem","title":"The Core Theorem","text":"<p>Theorem: The CEP system, as defined by the entity, relationship, and exchange schemas with their attestation and hash chain requirements, forms a well-defined category Civic with: 1. A universal property for entity identity (the Verifiable ID limit) 2. Associative composition for provenance chains 3. Faithful functors to external standards (XBRL, PROV) 4. A verified subcategory preserving cryptographic integrity</p> <p>Corollary: Any implementation that correctly generates canonical strings and validates attestations will produce records that compose correctly in the categorical sense\u2014provenance chains will be traceable, amendments will be auditable, and cross-system identity will be resolvable.</p>"},{"location":"en/concepts/category-theory-foundation/#appendix-diagrammatic-notation","title":"Appendix: Diagrammatic Notation","text":""},{"location":"en/concepts/category-theory-foundation/#basic-composition","title":"Basic Composition","text":"<pre><code>    grant           subgrant\nFED -----\u2192 STATE ----------\u2192 LOCAL\n\n         composed to:\n\n         federal-to-local\nFED ------------------------\u2192 LOCAL\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-limit-diagram-for-verifiable-id","title":"The Limit Diagram for Verifiable ID","text":"<pre><code>                  \u250c\u2500\u2500\u2500 SAM.gov record\n                  \u2502\n                  \u2502    \u03c0_sam\n                  \u2193\n    LEI record \u2500\u2500\u2500\u2192 Entity (Verifiable ID) \u2190\u2500\u2500\u2500 County record\n                  \u2191\n                  \u2502    \u03c0_state  \n                  \u2502\n                  \u2514\u2500\u2500\u2500 State CF record\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-amendment-chain","title":"The Amendment Chain","text":"<pre><code>E\u2081 \u2500\u2500amend\u2500\u2500\u2192 E\u2082 \u2500\u2500amend\u2500\u2500\u2192 E\u2083 \u2500\u2500amend\u2500\u2500\u2192 E\u2084\n\u2502              \u2502              \u2502              \u2502\n\u2502 hash         \u2502 hash         \u2502 hash         \u2502\n\u2193              \u2193              \u2193              \u2193\nH\u2081 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2082 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2083 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2084\n     (H\u2081 in        (H\u2082 in        (H\u2083 in\n      E\u2082)           E\u2083)           E\u2084)\n</code></pre> <p>This completes the categorical foundation for CEP. The schemas implement these abstract structures concretely, and the test vectors verify that implementations preserve the categorical properties.</p>"},{"location":"en/concepts/interoperability/","title":"Interoperability","text":"<p>CEP is designed to integrate with: </p> <ul> <li>Popolo - the entity + political relationships backbone of nearly every open civics project worldwide (OCD, OpenStates, etc.) includes models for Person, Organization, Membership,  Post / Role, Area, Event, Motion / Vote, Legislative Activity and works for elected officials, models boards, committees, councils, includes membership graph.</li> <li>Open Civic Data</li> <li>Open Contracting Data Standard (OCDS) - international standard for public procurement, contracts, tenders, awards, suppliers, implementation and milestone tracking.</li> <li>Schema.org - includes Organization, Person, Place, GovernmentOrganization, Grant, MonetaryGrant,  Legislation, VoteAction and enables interoperability with Google datasets, machine readability.</li> <li>Financial Taxonomies (XBRL) - good for financial reporting, auditing, interoperability with Treasury and state finance systems</li> <li>W3C PROV - good for academics and auditors, PROV guides revision chains, attestation blocks, canonical timestamps, and hash-based integrity. CEP attestation maps to PROV wasGeneratedBy, wasAttributedTo, wasDerivedFrom and CEP previousRecordHash maps to PROV wasRevisionOf.</li> <li>Open Referral Human Services Data Specification (HSDS) - has Organization, Location, Service, Funding - enables connecting public funding to outcomes</li> <li>Financial Industry Business Ontology (FIBO) - map to loan-agreement, grant-award (loosely), subsidiary.</li> </ul>"},{"location":"en/concepts/interoperability/#cep-concept-mapping-table","title":"CEP Concept Mapping Table","text":"CEP Concept CEP Term / Field CEP Vocabulary / Schema External Standard External Concept / Class / Field Mapping Type Notes Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Popolo <code>Organization</code> exactMatch Government bodies (legislatures, councils, agencies). Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> OCD <code>ocd-jurisdiction</code> exactMatch Use in <code>identifiers.additionalSchemes</code> with OCD jurisdiction IDs. Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Schema.org <code>GovernmentOrganization</code> exactMatch For web/SEO and generic data consumers. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> OCD <code>ocd-division</code> + <code>ocd-jurisdiction</code> (school districts) broadMatch Division/jurisdiction pair identifies school districts. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> Schema.org <code>EducationalOrganization</code> / <code>SchoolDistrict</code> (where available) exactMatch For education analytics and public-facing data. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Popolo <code>Organization</code> with classification <code>nonprofit</code> broadMatch Nonprofits providing services, fiscal sponsors, etc. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Schema.org <code>NGO</code> / <code>Organization</code> relatedMatch Web-compatible representation of nonprofits. Entity (organization) <code>entityTypeUri = #vendor</code> <code>entity-type.json</code> OCDS <code>Party</code> with role <code>supplier</code> exactMatch Contractors / vendors in procurement. Entity (natural person) <code>entityTypeUri = #natural-person</code> <code>entity-type.json</code> Popolo <code>Person</code> exactMatch Politicians, officials, natural-person donors, etc. Entity (natural person) <code>entityTypeUri = #elected-official</code> <code>entity-type.json</code> Popolo <code>Person</code> + <code>Membership</code> in <code>Organization</code> exactMatch Derived from Popolo membership in a legislature / council. Entity (natural person) <code>entityTypeUri = #natural-person</code> / <code>#elected-official</code> <code>entity-type.json</code> Schema.org <code>Person</code> exactMatch Generic consumer-friendly alignment. Entity (division) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division/...</code> exactMatch Political geography for school districts, counties, states, etc. Entity (jurisdiction) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-jurisdiction/...</code> exactMatch Governing bodies over divisions. Entity (organization) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-organization/...</code> exactMatch Committees, councils, agencies, boards. Entity (person) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-person/...</code> exactMatch People in OCD-compatible civic graphs. Entity (financial) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI ISO 17442 Legal Entity Identifier exactMatch Global financial identity for entities in financial transactions. Entity (federal) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov Unique Entity Identifier exactMatch U.S. federal financial identity for entities. Entity (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) Hash-based Sub-National Federated Entity Identifier newConcept Bridges UEI/LEI to local civic entities; open-source identifier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> exactMatch Prime contract between government and supplier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> USAspending <code>contract</code> (glossary) exactMatch Alignment with USASpending contract awards. Relationship (subcontract) <code>relationshipTypeUri = #subcontract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> linked via <code>relatedProcesses</code> broadMatch Subcontracts under a prime contract. Relationship (grant) <code>relationshipTypeUri = #grant-award</code> <code>relationship-type.json</code> USAspending <code>grant</code> (glossary) exactMatch Federal grants / assistance awards. Relationship (subgrant) <code>relationshipTypeUri = #subgrant</code> <code>relationship-type.json</code> OCDS <code>Award</code> + <code>Implementation.transactions</code> for subawards broadMatch Pass-through grants from state to local entities. Relationship (coop agrmt) <code>relationshipTypeUri = #cooperative-agreement</code> <code>relationship-type.json</code> USAspending <code>cooperative agreement</code> exactMatch Cooperative federal assistance relationships. Relationship (interagency) <code>relationshipTypeUri = #interagency-agreement</code> <code>relationship-type.json</code> OCDS <code>Contract</code> or <code>Agreement</code> between government parties relatedMatch Transfer agreements between agencies. Relationship (MOU) <code>relationshipTypeUri = #memorandum-of-understanding</code> <code>relationship-type.json</code> Popolo <code>Membership</code> / <code>Organization</code> with informal cooperation relatedMatch Non-binding but structured relationships. Relationship (fiscal spon) <code>relationshipTypeUri = #fiscal-sponsorship</code> <code>relationship-type.json</code> HSDS <code>Funding</code> / <code>Service</code> provider/host relationship relatedMatch Connects projects to 501(c)(3) entities. Relationship (board) <code>relationshipTypeUri = #board-membership</code> <code>relationship-type.json</code> Popolo <code>Membership</code> (person \u2194 organization, role = board member) exactMatch Governance relationships. Relationship (employment) <code>relationshipTypeUri = #employment</code> <code>relationship-type.json</code> Popolo <code>Membership</code> or <code>Post</code> with classification <code>employment</code> exactMatch Staff roles in agencies, schools, vendors. Relationship (consulting) <code>relationshipTypeUri = #consulting-engagement</code> <code>relationship-type.json</code> Popolo <code>Membership</code> with classification <code>consultant</code> relatedMatch Non-employee professional services. Relationship (subsidiary) <code>relationshipTypeUri = #subsidiary</code> <code>relationship-type.json</code> Schema.org <code>subOrganization</code> relatedMatch Corporate ownership within civic vendor trees. Relationship (joint ven.) <code>relationshipTypeUri = #joint-venture</code> <code>relationship-type.json</code> FIBO Joint venture relationship relatedMatch Optional mapping for advanced financial/corporate semantics. Relationship (reg. reg.) <code>relationshipTypeUri = #regulatory-registration</code> <code>relationship-type.json</code> Schema.org <code>GovernmentOrganization</code> + <code>registration</code>-related properties relatedMatch Entities registered with regulatory bodies. Relationship (loan) <code>relationshipTypeUri = #loan-agreement</code> <code>relationship-type.json</code> FIBO Loan contract exactMatch For loans, bond-like instruments, and revolving credit. Relationship (bill-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Bill</code> object relatedMatch Relationship authorized or shaped by a bill. Relationship (vote-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Vote</code> object relatedMatch Relationship activated/approved by a vote. Relationship (event-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Event</code> object relatedMatch Relationship linked to hearings, meetings, signings. Exchange (grant) <code>exchangeTypeUri = #grant-disbursement</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type grant disbursement exactMatch Payment of grant funds under a grant-award relationship. Exchange (contract fee) <code>exchangeTypeUri = #contract-fee-payment</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type payment exactMatch Invoice payments under contracts. Exchange (subaward) <code>exchangeTypeUri = #subgrant-disbursement</code> <code>exchange-type.json</code> USAspending Subaward transactions exactMatch Pass-through disbursements to subrecipients. Exchange (donation) <code>exchangeTypeUri = #campaign-contribution</code> <code>exchange-type.json</code> Popolo / DIME Contribution records mapped to <code>Person</code> / <code>Organization</code> donors/recipients relatedMatch Campaign finance contributions tied into CEP graph. Exchange (in-kind) <code>value.valueTypeUri = #in-kind</code> <code>value-type.json</code> Schema.org <code>Offer</code> / <code>Grant</code> with non-monetary value relatedMatch Non-monetary goods/services tracked in CEP. Exchange (service-hours) <code>value.valueTypeUri = #service-hours</code> <code>value-type.json</code> HSDS <code>Service</code> + time-based contributions relatedMatch Volunteer or staff time as value. Exchange (categorization) <code>categorization.naicsCode</code> <code>cep.exchange.schema.json</code> NAICS NAICS industry codes exactMatch Standard economic activity classification for exchanges. Exchange (categorization) <code>categorization.cfdaNumber</code> <code>cep.exchange.schema.json</code> CFDA / Assistance CFDA / Assistance Listing number exactMatch Links exchanges to federal assistance programs. Exchange (categorization) <code>categorization.gtasAccountCode</code> <code>cep.exchange.schema.json</code> GTAS Treasury Account Symbol exactMatch Aligns exchanges to Treasury reporting accounts. Exchange (source) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCDS <code>Release</code>, <code>Award</code>, <code>Contract</code>, <code>Implementation.transactions</code> relatedMatch Exchange derived from procurement data. Exchange (bill/vote) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCD <code>Bill</code>, <code>Vote</code>, <code>Event</code> relatedMatch Funding events tied to legislative activity. Value (monetary) <code>value.valueTypeUri = #monetary</code> <code>value-type.json</code> XBRL Monetary item types (e.g., <code>monetaryItemType</code>) exactMatch Monetary amounts aligned with financial reporting taxonomies. Value (monetary) <code>value.amount</code>, <code>value.currencyCode</code> <code>cep.exchange.schema.json</code> XBRL <code>xbrli:monetaryItemType</code>, ISO 4217 exactMatch Strictly typed monetary values. Value (provisioning) <code>valueTypeUri = #service-hours</code> / <code>#in-kind</code> <code>value-type.json</code> HSDS <code>Service</code> value dimensions relatedMatch For human services and community programs. Provenance (entity) <code>attestation</code> block on Entity <code>cep.entity.schema.json</code> W3C PROV <code>prov:Entity</code>, <code>prov:wasGeneratedBy</code>, <code>prov:wasAttributedTo</code> exactMatch Entity record as a PROV entity with associated agent/activity. Provenance (relationship) <code>attestation</code> block on Relationship <code>cep.relationship.schema.json</code> W3C PROV Same as above exactMatch Relationship record provenance in PROV terms. Provenance (exchange) <code>attestation</code> block on Exchange <code>cep.exchange.schema.json</code> W3C PROV Same as above exactMatch Exchange record provenance. Provenance (revision) <code>previousRecordHash</code>, <code>revisionNumber</code> all CEP core schemas W3C PROV <code>prov:wasRevisionOf</code>, <code>prov:qualifiedRevision</code> exactMatch Immutable revision chains expressed via hashes and monotone revisions. Provenance (hash) Canonical string + SHA-256 hash (SSOT) implementation / spec W3C PROV <code>prov:generatedAtTime</code>, <code>prov:wasDerivedFrom</code> relatedMatch Hash as integrity proof supporting PROV-compatible derivation chains. IDs (UEI) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov UEI exactMatch Federal identity. IDs (LEI) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI LEI exactMatch Global financial identity. IDs (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) SNFEI newConcept Open, recomputable sub-federal ID bridging UEI/LEI and local civic entities. IDs (OCD) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division</code>, <code>ocd-jurisdiction</code>, <code>ocd-organization</code>, <code>ocd-person</code> exactMatch Primary bridge to the Open Civic Data topology. IDs (OCDS) <code>identifiers.additionalSchemes</code> on Entity/Relationship <code>cep.entity/relationship</code> OCDS <code>Parties</code>, <code>Award.id</code>, <code>Contract.id</code> relatedMatch Tie CEP entities/relationships back to OCDS releases. IDs (Popolo) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> Popolo <code>Person.id</code>, <code>Organization.id</code> relatedMatch Where Popolo IDs exist separately from OCD IDs."},{"location":"en/concepts/interoperability/#cep-concept-mapping-table-by-schema","title":"CEP Concept Mapping Table (by Schema)","text":"CEP Concept / Field External Standard External Concept / ID / Class Mapping Type Suggested <code>externalUri</code> / <code>schemeUri</code> example Notes Entity (general civic entity) Popolo <code>Person</code>, <code>Organization</code> broadMatch <code>http://www.popoloproject.com/specs/person.html</code>, <code>http://www.popoloproject.com/specs/organization.html</code> CEP <code>entity</code> covers both persons and orgs; Popolo separates. <code>entityTypeUri</code> <code>#natural-person</code> Popolo <code>Person</code> exactMatch <code>http://www.popoloproject.com/specs/person.html</code> For individuals (candidates, officials, donors). <code>entityTypeUri</code> <code>#organization</code> Popolo <code>Organization</code> exactMatch <code>http://www.popoloproject.com/specs/organization.html</code> Base org type, parent of more specific government / nonprofit types. <code>entityTypeUri</code> <code>#government-jurisdiction</code> Popolo/OCD Popolo <code>Organization</code> + OCD <code>jurisdiction</code> relatedMatch <code>https://opencivicdata.org/id/jurisdiction</code> A governing body; mix of org and jurisdiction. <code>identifiers.additionalSchemes</code> (division) OCD <code>ocd-division/*</code> exactMatch <code>https://opencivicdata.org/id/division</code> Store OCD division IDs as <code>schemeUri = \"https://opencivicdata.org/id/division\"</code>. <code>identifiers.additionalSchemes</code> (jurisdiction) OCD <code>ocd-jurisdiction/*</code> exactMatch <code>https://opencivicdata.org/id/jurisdiction</code> Store OCD jurisdiction IDs. <code>identifiers.additionalSchemes</code> (person) OCD / Popolo <code>ocd-person/*</code> (Popolo person) exactMatch <code>https://opencivicdata.org/id/person</code> Link CEP entity to OCD/Popolo person IDs. <code>identifiers.additionalSchemes</code> (organization) OCD / Popolo <code>ocd-organization/*</code> exactMatch <code>https://opencivicdata.org/id/organization</code> Link CEP entity to OCD/Popolo org IDs. <code>identifiers.lei</code> leif / LEI <code>LEI</code> (ISO 17442 Legal Entity Identifier) exactMatch <code>https://www.gleif.org/en/about-lei/introducing-the-legal-entity-identifier-lei</code> Already in schema; key for global finance interoperability. <code>identifiers.samUei</code> US Federal UEI (SAM.gov Unique Entity Identifier) exactMatch <code>https://www.sam.gov/</code> Tier 2 identity in our stack. <code>identifiers.additionalSchemes</code> (OCDS party) OCDS <code>parties.identifier.id</code> relatedMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Use for suppliers / buyers in procurement records. <code>entityTypeUri</code> <code>#supplier</code> / <code>#contractor</code> OCDS <code>Organization</code> with role <code>supplier</code> / <code>tenderer</code> exactMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Straight mapping for vendors. <code>entityTypeUri</code> <code>#school-district</code> Schema.org <code>SchoolDistrict</code> (subtype of <code>EducationalOrganization</code>) relatedMatch <code>https://schema.org/SchoolDistrict</code> For education equity analytics. <code>entityTypeUri</code> <code>#government-agency</code> Schema.org <code>GovernmentOrganization</code> exactMatch <code>https://schema.org/GovernmentOrganization</code> For agencies at any level. Relationship (legal / functional relationships) Popolo <code>Membership</code>, <code>Post</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> CEP Relationship is more general; includes contracts, grants, etc. <code>relationshipTypeUri</code> <code>#board-membership</code> Popolo <code>Membership</code> exactMatch <code>http://www.popoloproject.com/specs/membership.html</code> Board membership of a person in an org. <code>relationshipTypeUri</code> <code>#employment</code> Popolo <code>Membership</code> (with <code>post</code> / <code>role</code>) broadMatch <code>http://www.popoloproject.com/specs/membership.html</code> Employment is a constrained membership. <code>relationshipTypeUri</code> <code>#consulting-engagement</code> Popolo <code>Membership</code> or <code>ContactDetail</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> Less formal, non-employee service relationship. <code>relationshipTypeUri</code> <code>#prime-contract</code> OCDS <code>Contract</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> CEP Relationship for a prime contract matches OCDS Contract. <code>relationshipTypeUri</code> <code>#subcontract</code> OCDS <code>Contract</code> with <code>relatedProcesses</code> / <code>relatedLots</code> narrowMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> Subcontracts are contracts linked to a parent award. <code>relationshipTypeUri</code> <code>#grant-award</code> OCDS <code>Award</code> relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#award</code> OCDS is procurement-focused; grants are adjacent. <code>relationshipTypeUri</code> <code>#cooperative-agreement</code> OCDS <code>Award</code> or <code>Contract</code> (context-specific) relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/</code> Map conceptually to awarded agreements. <code>relationshipTypeUri</code> <code>#loan-agreement</code> FIBO <code>LoanAgreement</code> exactMatch <code>https://spec.edmcouncil.org/fibo/ontology/FBC/DebtAndEquities/Debt/LoanAgreement</code> Optional FIBO mapping; useful for financial instruments. <code>relationshipTypeUri</code> <code>#subsidiary</code> Schema.org <code>subOrganization</code> relatedMatch <code>https://schema.org/subOrganization</code> See vocab.mappings. <code>relationshipTypeUri</code> <code>#joint-venture</code> Schema.org <code>Organization</code> with <code>memberOf</code> relatedMatch <code>https://schema.org/Organization</code> Joint ventures as special multi-party orgs. <code>relationshipTypeUri</code> <code>#regulatory-registration</code> Schema.org <code>GovernmentOrganization</code> / <code>Service</code> relatedMatch <code>https://schema.org/GovernmentOrganization</code> Registration with a regulator. <code>relationshipTypeUri</code> <code>#fiscal-sponsorship</code> HSDS / Nonprofit HSDS <code>Funding</code> or <code>Service</code> relatedMatch <code>https://github.com/openreferral/specification</code> For nonprofit fiscal sponsor relationships. Exchange (value transfer events) OCDS <code>Implementation.transactions[]</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#implementation</code> CEP Exchange is very close to OCDS transaction-level data. <code>exchangeTypeUri</code> <code>#grant-disbursement</code> Schema.org <code>MonetaryGrant</code> exactMatch <code>https://schema.org/MonetaryGrant</code> Core pattern for education &amp; campaign finance. <code>exchangeTypeUri</code> <code>#contract-fee-payment</code> Schema.org <code>Payment</code> / <code>Invoice</code> relatedMatch <code>https://schema.org/Invoice</code> Payment for contracted services. <code>exchangeTypeUri</code> <code>#donation</code> (if defined) Schema.org <code>DonateAction</code> relatedMatch <code>https://schema.org/DonateAction</code> Campaign or charitable donations. <code>exchangeTypeUri</code> <code>#loan-disbursement</code> FIBO <code>LoanPrincipalPayment</code> relatedMatch FIBO debt concepts More detailed financial modeling if needed. Value &amp; Categorization XBRL GAAP / GRT financial elements exactMatch e.g. <code>http://xbrl.us/us-gaap/2024-01-31#RevenueRecognition</code> Map CEP <code>categorization</code> fields to XBRL when possible. <code>value.currencyCode</code> ISO 4217 Currency codes exactMatch <code>https://www.iso.org/iso-4217-currency-codes.html</code> Already enforced by regex. <code>categorization.naicsCode</code> NAICS NAICS activity code exactMatch <code>https://www.census.gov/naics/</code> Already included in schema. <code>categorization.cfdaNumber</code> Assistance List CFDA / Assistance Listing number exactMatch <code>https://sam.gov/content/assistance-listing</code> For federal assistance programs. <code>categorization.gtasAccountCode</code> US GTAS Treasury Account Symbol (TAS) exactMatch <code>https://fiscal.treasury.gov/gtas/</code> Connects to federal reporting. Provenance &amp; Attestation W3C PROV <code>Entity</code>, <code>Activity</code>, <code>Agent</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, etc. relatedMatch <code>https://www.w3.org/TR/prov-o/</code> CEP is PROV-aligned but more specialized. <code>attestation.attestorId</code> W3C PROV <code>Agent</code> / <code>prov:wasAttributedTo</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasAttributedTo</code> The attesting node is the Agent. <code>attestation.attestationTimestamp</code> W3C PROV <code>generatedAtTime</code> exactMatch <code>https://www.w3.org/TR/prov-o/#generatedAtTime</code> When the record (Entity) was generated. <code>previousRecordHash</code> W3C PROV <code>wasRevisionOf</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasRevisionOf</code> Revision chain between CEP records. <code>provenanceChain.fundingChainTag</code> W3C PROV <code>wasDerivedFrom</code> chain relatedMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Human-readable representation of a PROV derivation path. <code>provenanceChain.parentExchangeId</code> W3C PROV <code>wasDerivedFrom</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Parent exchange is the immediate predecessor in the flow. Events, Bills, Votes OCD / Popolo <code>Bill</code>, <code>VoteEvent</code>, <code>Event</code> relatedMatch <code>https://opencivicdata.org/specs/</code> Linked via <code>sourceReferences</code>. <code>sourceReferences</code> (bill) OCD <code>ocd-bill/*</code> exactMatch <code>https://opencivicdata.org/id/bill</code> For authorizing legislation. <code>sourceReferences</code> (vote) OCD / Popolo <code>ocd-vote/*</code> or Popolo <code>VoteEvent</code> exactMatch <code>https://opencivicdata.org/id/vote</code> For authorization votes. <code>sourceReferences</code> (event) OCD / Popolo <code>Event</code> exactMatch <code>https://opencivicdata.org/id/event</code> Meetings, hearings tied to relationships or exchanges. Human Services / Programs (optional) HSDS <code>Service</code>, <code>Organization</code>, <code>Funding</code> relatedMatch <code>https://github.com/openreferral/specification</code> For social services and community programs. <code>entityTypeUri</code> <code>#service-provider</code> HSDS <code>Organization</code> exactMatch <code>https://github.com/openreferral/specification</code> For agencies and nonprofits providing services. <code>relationshipTypeUri</code> <code>#service-delivery-agreement</code> (future) HSDS <code>Service</code> / <code>Funding</code> relatedMatch HSDS docs If added."},{"location":"en/concepts/interoperability/#vocabulary-notes","title":"Vocabulary Notes","text":"<p>prime-contract</p> <ul> <li>USAspending contract is a close conceptual match.</li> <li>OCDS contract is the canonical public procurement concept, so exactMatch.</li> </ul> <p>subcontract</p> <ul> <li>OCDS does not have a first-class subcontract object, but it is conceptually a specialized contract under a main award, so narrowMatch.</li> </ul> <p>grant-award</p> <ul> <li>USAspending grant is a direct match to federal grants.</li> <li>OCDS award is broader (covers procurements and grants), so relatedMatch.</li> <li>Schema.org MonetaryGrant is almost exactly, so exactMatch.</li> </ul> <p>loan-agreement</p> <ul> <li>FIBO Contracts and Loans ontologies give similar semantic neighborhood but more general, so relatedMatch.</li> </ul> <p>subsidiary</p> <ul> <li>Schema.org subOrganization is close but not strictly legal-definition match, so relatedMatch.</li> <li>FIBO Subsidiary is semantically close but in financial-industry framing; so relatedMatch.</li> </ul> <p>board-membership and employment</p> <ul> <li>Both are specializations of Popolo Membership (person\u2013organization relationship with roles and time-bounds), so narrowMatch.</li> </ul>"},{"location":"en/concepts/positioning-paper/","title":"Civic Interconnect Positioning Paper","text":"<p>CEP and P3Tags as Interoperability Layer for Civic Data Ecosystems</p>"},{"location":"en/concepts/positioning-paper/#1-introduction","title":"1. Introduction","text":"<p>Modern civic systems rely on multiple established standards: Open Civic Data (OCD) for political geography, Popolo for people and organizations, the Open Contracting Data Standard (OCDS) for procurement, and numerous state or federal schemas for grants, budgets, elections, disclosures, and public records.</p> <p>Each standard addresses its own domain well.  </p> <p>What is missing is a cross-domain, provenance-aware interoperability layer.</p> <p>The Civic Interconnect framework fills this gap by providing two complementary tools:</p> <ul> <li>Civic Exchange Protocol (CEP) - a lightweight model for representing entities, relationships, and exchanges across civic workflows.</li> <li>P3Tags (Per-Post Provenance Tags) - a simple, deployable metadata format that attaches provenance to individual documents, posts, filings, attachments, and AI-derived content.</li> </ul> <p>Civic Interconnect does not replace existing standards. It enables them to interoperate.</p>"},{"location":"en/concepts/positioning-paper/#2-role-of-cep","title":"2. Role of CEP","text":"<p>CEP provides neutral, JSON-first constructs that describe:</p> <ul> <li>Entities - people, organizations, agencies, programs, vendors  </li> <li>Relationships - membership, jurisdiction, oversight, affiliation  </li> <li>Exchanges - filings, permits, tenders, responses, amendments, reports</li> </ul> <p>CEP acts as a transport layer, allowing domain-specific schemas (e.g., OCDS, state grant systems) to be expressed in a common shape and combined across silos.</p> <p>CEP does not attempt to redefine deep domain ontologies. Its value is structural consistency and cross-domain interoperability.</p>"},{"location":"en/concepts/positioning-paper/#3-role-of-p3tags","title":"3. Role of P3Tags","text":"<p>P3Tags provide per-artifact provenance:</p> <ul> <li>what the content is  </li> <li>who created or modified it  </li> <li>what transformations occurred (OCR, summarization, redaction, modeling)  </li> <li>which policies applied  </li> <li>what source(s) it derived from</li> </ul> <p>Where CEP handles structured civic records, P3Tags handle the documents and messages that move through civic processes.</p> <p>In an AI-rich environment, P3Tags help establish:</p> <ul> <li>chain of custody  </li> <li>reproducibility  </li> <li>auditability  </li> <li>trustworthiness</li> </ul> <p>P3Tags can be used independently but become dramatically more powerful when linked to CEP entities and exchanges.</p>"},{"location":"en/concepts/positioning-paper/#4-alignment-with-existing-standards","title":"4. Alignment with Existing Standards","text":"<p>Civic Interconnect is intentionally non-competitive with existing civic standards:</p> <ul> <li>CEP entities may reference OCD Division IDs for jurisdictions.  </li> <li>CEP relationships may align with Popolo people/organization structures.  </li> <li>CEP exchanges may wrap OCDS contracting lifecycle documents.  </li> <li>P3Tags may map to W3C PROV concepts for semantic-web compatibility.</li> </ul> <p>Each standard continues doing what it does best. CEP and P3Tags provide the missing glue.</p>"},{"location":"en/concepts/positioning-paper/#5-why-this-matters","title":"5. Why This Matters","text":"<p>The civic ecosystem is facing three converging pressures:</p> <ol> <li>AI integration - automated agents increasingly summarize, classify, route, and transform civic information.  </li> <li>Fragmented vendor landscapes - public records, procurement, grants, meetings, and reporting systems rarely interoperate.  </li> <li>Transparency expectations - journalists, auditors, and the public need sourceable, auditable, machine-readable records.</li> </ol> <p>CEP and P3Tags offer a minimal, intuitive, and extensible way to satisfy these pressures without imposing heavy ontologies or requiring system rewrites.</p>"},{"location":"en/concepts/positioning-paper/#6-conclusion","title":"6. Conclusion","text":"<p>The Civic Interconnect framework is a small set of primitives designed to connect everything else:</p> <ul> <li>CEP: the cross-domain record structure  </li> <li>P3Tags: the provenance header  </li> <li>Existing standards: the authoritative domain models  </li> </ul> <p>This positioning enables the civic community to build interoperable, transparent, AI-ready systems that scale from small rural governments to national datasets - without displacing established standards or workflows.</p>"},{"location":"en/concepts/related-domains/","title":"Related Research Domains","text":"<p>This standard operates at the intersection of three major, yet often separate, academic research domains:  - Formal Entity Resolution (CS),  - Campaign Finance/Policy Analysis (Political Science), and - Global Data Standards (Information Systems).</p>"},{"location":"en/concepts/related-domains/#prior-work-entity-resolution-data-standards-and-civic-transparency","title":"Prior Work: Entity Resolution, Data Standards, and Civic Transparency","text":"<p>This standard advances the state-of-the-art by bridging the gap between three distinct bodies of work: high-fidelity entity resolution, policy-driven data harmonization, and the development of open standards for public accountability.</p>"},{"location":"en/concepts/related-domains/#1-entity-resolution-and-data-quality-methodology","title":"1. Entity Resolution and Data Quality Methodology","text":"<p>Research in Entity Resolution (ER), also known as record linkage or deduplication, has been a cornerstone of computer science and database theory.</p> <p>Carnegie Mellon University (CMU) has contributed foundational work in formalizing the ER problem, such as the ENRES framework, which provides a semantic model to represent and relate various ER research models. This work highlights the crucial need for formal reasoning and explicit assumptions regarding entities and their references, which directly informs our Category Theory approach. Other CMU-related research has addressed Generic Entity Resolution with Data Confidences, underscoring the necessity of associating numerical confidence with merged records, a feature we implement via the Splink-generated confidence_score.</p> <p>The computational methodology behind our implementation relies heavily on advancements in probabilistic record linkage, particularly the Fellegi-Sunter model, which allows for high-accuracy linking of data without labeled training sets, critical for messy public data. The use of the open-source Splink library (pioneered outside academia and rigorously validated) represents a pragmatic, scalable implementation of these probabilistic principles.</p>"},{"location":"en/concepts/related-domains/#2-campaign-finance-and-policy-data-standardization","title":"2. Campaign Finance and Policy Data Standardization","text":"<p>A parallel track of research has focused on the application of computational methods to clean and analyze fragmented political data.</p> <p>Stanford University's DIME (Database on Ideology, Money in Politics, and Elections) Project exemplifies the effort to centralize and standardize complex political contributions data. DIME has assigned unique identifiers for millions of individual and organizational donors, candidates, and political committees across federal and state elections. This established the value proposition for a persistent, standardized identifier in the campaign finance domain.</p> <p>The University of Chicago MS in Computational Analysis and Public Policy (MSCAPP) and Stanford's Computational Public Policy programs have emphasized the necessary skills, including machine learning, big data, and computational analysis required to address policy issues like public procurement and campaign finance. These programs underscore the academic recognition that robust data infrastructure is the prerequisite for rigorous policy analysis.</p> <p>While these efforts successfully resolve entities within their domain (e.g., within campaign finance), they often use internal, proprietary identifiers that do not readily link to entities in the public procurement or grant domains, creating siloed transparency.</p>"},{"location":"en/concepts/related-domains/#3-open-data-interoperability-and-global-standards","title":"3. Open Data, Interoperability, and Global Standards","text":"<p>The third body of work defines the principles of modern data governance and standardization.</p> <p>Massachusetts Institute of Technology (MIT), through its Research Data Principles, champions the need for researchers to manage data actively and avoid acquiring or generating data that restricts future use and sharing. This principle of \"open by default\" and \"designed for reuse\" informs the design of the our open-source standard and its reliance on the non-proprietary SNFEI.</p> <p>Organizations supporting the Open Data Charter emphasize that data must be comparable and interoperable to enhance governance and accountability. This reflects the global demand for cross-sectoral standards. The existing Legal Entity Identifier (LEI) standard provides the template for a globally harmonized system in the financial sector.</p>"},{"location":"en/concepts/related-domains/#novelty-and-contribution-of-this-standard","title":"Novelty and Contribution of this Standard","text":"<p>This project is novel in three key ways:</p> <ul> <li> <p>Compositional Rigor: We model the civic exchange system as a Category, using Category Theory to formally prove that the SNFEI acts as the Universal Property (Limit) that unifies all messy civic records, helping to guarantee the standard's structural integrity and extensibility.</p> </li> <li> <p>Tiered, Extensible Identity: We address sub-federal identities by explicitly creating the SNFEI (Tier 3) as an open-source bridge to the global LEI (Tier 1) and federal UEI (Tier 2).</p> </li> <li> <p>The Provenance Tag: We enforce a Compositional Provenance Tag that structurally records the Morphism Type (GRANT, CONTRACT_FEE) and the entity hierarchy, enabling automated tracing of the entire funding chain, which goes beyond simple entity deduplication.</p> </li> </ul>"},{"location":"en/governance/evolution-policy-and-versioning/","title":"Standard Evolution Policy and Versioning","text":"<p>This policy defines the process, requirements, and responsibilities for introducing changes to the Protocol.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#1-versioning-system","title":"1. Versioning System","text":"<p>The standard utilizes Semantic Versioning (MAJOR.MINOR.PATCH). The version number applies to the entire monorepo and its core protocol requirements.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#11-major-version-change-x00","title":"1.1 MAJOR Version Change (X.0.0)","text":"<p>A MAJOR change is reserved for non-backwards-compatible modifications that require all certified nodes to update their serialization logic, otherwise, they will lose hash parity.</p> Change Type Impact Example Data Type Change Changing a field type (e.g., transactionAmount from number to string). Field Order Change Modifying the CANONICAL_FIELD_ORDER. Cryptographic Change Switching from SHA-256 to a new algorithm (e.g., SHA-384). Mandatory Field Addition Adding a new field to the required list in the JSON Schema. <p>Requirement: Requires unanimous approval from the Interconnect Standards Board (ISB) and a mandatory 6-month deprecation period.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#12-minor-version-change-0x0","title":"1.2 MINOR Version Change (0.X.0)","text":"<p>A MINOR change is a backwards-compatible modification that adds new functionality or optional fields. Existing certified nodes maintain hash parity, but new nodes may need to account for new optional data.</p> Change Type Impact Example Optional Field Addition Adding a new field to the end of the CANONICAL_FIELD_ORDER (which is omitted if null). Adding funding_source_project_id (optional). Enum Value Addition Adding a new value to an existing enum (e.g., adding TEMPORARILY_SUSPENDED to transactionStatus). Tooling Upgrade Significant upgrade to the build system (build.sh or testing dependencies). <p>Requirement: Requires simple majority approval from the ISB (2 out of 3 votes).</p>"},{"location":"en/governance/evolution-policy-and-versioning/#13-patch-version-change-00x","title":"1.3 PATCH Version Change (0.0.X)","text":"<p>A PATCH change is a small, fully backwards-compatible correction to documentation, tooling, or non-protocol code.</p> Change Type Impact Example Documentation Fix Correcting a typo in the Governance Charter. Test Data Update Adding a new test vector to /test_data that uses only existing fields. Non-Core Bug Fix Fixing a non-critical bug in a reference implementation's example code. <p>Requirement: Can be approved by the ISB Chair alone.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#2-change-submission-and-review-cycle","title":"2. Change Submission and Review Cycle","text":"<ol> <li> <p>Proposal Submission: The contributor submits a Pull Request (PR) against the main branch.</p> </li> <li> <p>Versioning Assignment: The ISB Chair assigns the PR a tentative version bump (MAJOR, MINOR, or PATCH) based on Section 1.</p> </li> <li> <p>ISB Review and Vote: The ISB reviews the proposal (focusing on need and impact) and votes according to the requirement for the assigned version type.</p> </li> <li> <p>Hash Parity Enforcement: Once the vote passes, the PR is merged, and the automated CI system executes the build.sh script to confirm 100% hash parity across all five certified languages (Python, Rust, Java, C#, TypeScript). No release can occur until 100% parity is confirmed.</p> </li> <li> <p>Release: The new version is tagged, and all certified node operators are notified.</p> </li> </ol>"},{"location":"en/governance/objectives-and-vision/","title":"Objectives and Vision","text":"<p>The Civic Exchange Protocol (CEP) is designed to support incremental integration today and strategic planning without requiring architectural changes. The core philosophy is simple:</p> <ul> <li>Optimize for low-cost, low-friction adoption.</li> <li>Provide cryptographic integrity without requiring blockchain.</li> <li>Support regulatory harmonization across jurisdictions.</li> <li>Preserve openness, interoperability, and vendor neutrality.</li> </ul> <p>At its core, CEP ensures that the same payload always yields the same canonical hash, providing a universal identity and attestation mechanism that can span civic, financial, and administrative systems.</p>"},{"location":"en/governance/objectives-and-vision/#1-objectives","title":"1. Objectives","text":""},{"location":"en/governance/objectives-and-vision/#11-lower-the-cost-of-adoption","title":"1.1 Lower the Cost of Adoption","text":"<p>Most public-sector technology initiatives fail due to the cost and complexity of onboarding. CEP minimizes this by:</p> <ul> <li>Requiring only JSON + SHA-256 + a canonical string rule.</li> <li>Avoiding specialized infrastructure (no distributed ledger, no proprietary middleware).</li> <li>Allowing any language, platform, or agency to participate.</li> <li>Transparency by default: schemas and vocabularies are openly published.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#12-decentralized-provenance-without-blockchain","title":"1.2 Decentralized Provenance Without Blockchain","text":"<p>Unlike blockchain-based solutions, CEP:</p> <ul> <li>Requires no consensus algorithm.</li> <li>Does not impose token economics or distributed nodes.</li> <li>Uses a cryptographically linked attestation chain (previousRecordHash), providing tamper evidence at a fraction of the cost.</li> </ul> <p>This provides a cryptographic audit trail suitable for public-sector systems where full decentralization is either unnecessary or impractical.</p>"},{"location":"en/governance/objectives-and-vision/#13-cost-effective-regulatory-compliance","title":"1.3 Cost-Effective Regulatory Compliance","text":"<p>CEP is designed to satisfy emerging demands in:</p> <ul> <li>Transparency and anti-corruption policy  </li> <li>Cross-jurisdiction financial tracking  </li> <li>Federal reporting (XBRL, GTAS)  </li> <li>Global financial identity standards (UEI, LEI)</li> </ul> <p>By structuring the data model around canonical identifiers, provenance, and hash-bound attestations, CEP can adapt naturally to future regulatory frameworks and programmatic audit requirements.</p>"},{"location":"en/governance/objectives-and-vision/#2-vision","title":"2. Vision","text":"<p>The Civic Exchange Protocol is deliberately designed so that incremental adoption today will not conflict with expected future requirements.</p> <p>Possible evolution includes:</p> <ul> <li>National or state-level directives requiring provenance tagging for grant, contract, or procurement systems.</li> <li>Standardization bodies adopting CEP as a formal schema for intergovernmental reporting.</li> <li>Regulatory requirements for immutable audit trails for public money flows.</li> <li>International harmonization with LEI, XBRL, HSDS, PROV, Popolo, or other standards.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#3-voluntary-integration-vs-possible-future-requirements-matrix","title":"3. Voluntary Integration vs. Possible Future Requirements Matrix","text":"<p>This matrix outlines the anticipated pathway from voluntary use to potential regulatory mandate. The protocol is built to operate seamlessly in both contexts.</p> Aspect Current Voluntary Integration Possible Future Requirements Authority Interconnect Standards Board (ISB) governs versions, vocabularies, and hash rules. Department of Governance and Exchange (DOGE) as regulatory authority for compliance and enforcement. Access Policy Peer-to-peer agreements between participating entities. Standardized Digital Roles and Permissions (SDRP), federally or globally recognized. Public Data Best practice for transparency. Agencies may decide which data to publish. Mandatory global disclosures for specific categories (e.g., grants, contracts, campaign finance). Integrity Proof Entity Hash and canonical string provide voluntary integrity guarantee. Same Entity Hash meets any required SSOT-proof for compliance and audits. <p>CEP ensures that the same proof mechanism works in both cases, with no need for new cryptographic infrastructure should mandated requirements arrive.</p>"},{"location":"en/governance/objectives-and-vision/#4-future-proof-architecture","title":"4. Future-Proof Architecture","text":"<p>CEP is explicitly designed to:</p> <ul> <li>Scale from a few adopters to wider integration.</li> <li>Allow community-driven vocabulary evolution.</li> <li>Support new jurisdictions, formats, and regulatory requirements without schema breakage.</li> <li>Provide a secure, verifiable, and interoperable foundation for multi-sector data exchange.</li> </ul> <p>The vision is an interoperable civic identity and provenance network, offering incremental integration and compatibility with existing systems.</p>"},{"location":"en/governance/vocabulary-process/","title":"Vocabulary Governance Process","text":"<p>This document defines how controlled vocabularies in the Civic Exchange Protocol (CEP) are created, reviewed, versioned, and published. CEP vocabularies include:</p> <ul> <li><code>entity-type</code></li> <li><code>relationship-type</code></li> <li><code>exchange-type</code></li> <li><code>exchange-role</code></li> <li><code>party-role</code></li> <li><code>identifier-scheme</code></li> <li><code>source-system</code></li> <li><code>resolution-method</code></li> <li><code>value-type</code></li> </ul> <p>These vocabularies provide the stable semantic backbone for CEP interoperability across government systems, academic research, and third-party implementations.</p>"},{"location":"en/governance/vocabulary-process/#1-purpose-of-vocabularies","title":"1. Purpose of Vocabularies","text":"<p>CEP vocabularies serve three critical functions:</p> <ol> <li> <p>Interoperability:    Terms map to external standards (Popolo, Open Civic Data, OCDS, HSDS, Schema.org, XBRL, W3C PROV).</p> </li> <li> <p>Semantic Stability:    Terms provide canonical meaning for entity types, role types, relationship types, exchange types, etc.</p> </li> <li> <p>Verifiable Behavior:    Terms are referenced in canonical URI form inside attested CEP records, affecting hash parity and revision integrity.</p> </li> </ol>"},{"location":"en/governance/vocabulary-process/#2-versioning","title":"2. Versioning","text":"<p>Vocabulary files follow independent semantic versioning:</p> <p><code>&lt;name&gt;.vMAJOR.MINOR.PATCH.json</code></p> <p>Examples:  </p> <pre><code>entity-type.v1.0.0.json\nidentifier-scheme.v1.0.0.json\n</code></pre>"},{"location":"en/governance/vocabulary-process/#21-major","title":"2.1 MAJOR","text":"<p>Changes that break compatibility or reinterpret existing terms: - renaming or removing terms - redefining meanings - altering term URIs - significant structural changes</p> <p>Requires unanimous ISB approval + 6-month deprecation period.</p>"},{"location":"en/governance/vocabulary-process/#22-minor","title":"2.2 MINOR","text":"<p>Backward-compatible enhancements: - adding new terms - adding new mappings - adding optional properties</p> <p>Requires simple majority vote.</p>"},{"location":"en/governance/vocabulary-process/#23-patch","title":"2.3 PATCH","text":"<p>No semantic change: - fixing typos - adding external references in <code>seeAlso</code> - clarifying descriptions</p> <p>May be approved by ISB Chair alone.</p>"},{"location":"en/governance/vocabulary-process/#3-adding-updating-or-deprecating-terms","title":"3. Adding, Updating, or Deprecating Terms","text":"<p>All vocabulary modifications follow this structured workflow:</p>"},{"location":"en/governance/vocabulary-process/#step-1-proposal-submission","title":"Step 1 \u2014 Proposal Submission","text":"<p>A contributor submits a PR that includes: - updated vocabulary file - accompanying rationale - impact assessment on interoperability - references to external standards (if relevant)</p>"},{"location":"en/governance/vocabulary-process/#step-2-technical-review","title":"Step 2 \u2014 Technical Review","text":"<p>The Interconnect Standards Board (ISB) reviews: - term clarity and definition - hierarchy (<code>parentTermUri</code>) - mappings to external standards (SKOS-style) - URI stability - potential namespace collisions - hash-parity implications</p>"},{"location":"en/governance/vocabulary-process/#step-3-vote","title":"Step 3 \u2014 Vote","text":"<p>Version bump category determines voting requirements (Section 2).</p>"},{"location":"en/governance/vocabulary-process/#step-4-merge-release","title":"Step 4 \u2014 Merge &amp; Release","text":"<p>Upon approval: - CI validates JSON format, unique URIs, and mapping integrity - The vocabulary is merged into <code>main</code> - A new tag is created:</p> <p><code>vocab/&lt;name&gt;/vMAJOR.MINOR.PATCH</code></p>"},{"location":"en/governance/vocabulary-process/#step-5-deprecation-notices","title":"Step 5 \u2014 Deprecation Notices","text":"<p>If a term becomes deprecated: - it is retained with <code>\"status\": \"deprecated\"</code> - <code>\"deprecationNote\"</code> must point to its replacement - canonical JSON schemas continue accepting it unless a MAJOR bump occurs</p>"},{"location":"en/governance/vocabulary-process/#4-design-principles-for-vocabulary-terms","title":"4. Design Principles for Vocabulary Terms","text":""},{"location":"en/governance/vocabulary-process/#41-term-uris-must-be-globally-stable","title":"4.1 Term URIs MUST be globally stable","text":"<p>URIs never change after publication.</p>"},{"location":"en/governance/vocabulary-process/#42-labels-are-human-friendly-codes-are-machine-friendly","title":"4.2 Labels are human-friendly; codes are machine-friendly","text":"<p>Examples: - code: <code>prime-contract</code> - label: <code>Prime Contract</code></p>"},{"location":"en/governance/vocabulary-process/#43-definitions-must-be-unambiguous","title":"4.3 Definitions MUST be unambiguous","text":"<p>Definitions MUST avoid jurisdiction-specific assumptions unless explicitly scoped.</p>"},{"location":"en/governance/vocabulary-process/#44-hierarchies-should-be-used-where-meaningful","title":"4.4 Hierarchies SHOULD be used where meaningful","text":"<p>Example: - <code>subgrant</code> \u2192 parent: <code>grant-award</code> - <code>subcontract</code> \u2192 parent: <code>prime-contract</code></p>"},{"location":"en/governance/vocabulary-process/#45-external-mappings-should-be-included","title":"4.5 External mappings SHOULD be included","text":"<p>Supported mapping types: <code>exactMatch</code>, <code>broadMatch</code>, <code>narrowMatch</code>, <code>relatedMatch</code>.</p>"},{"location":"en/governance/vocabulary-process/#5-file-placement-and-structure","title":"5. File Placement and Structure","text":"<p>All vocabulary files live under <code>vocabularies/</code>.</p> <p>Each file follows the canonical <code>cep.vocabulary.schema.json</code>.</p>"},{"location":"en/governance/vocabulary-process/#6-lifecycle-summary","title":"6. Lifecycle Summary","text":"Stage Description Output Proposal Contributor suggests new/updated term Pull Request Review ISB evaluates definition + mappings Comments Vote Approve/reject based on version category Decision Release Publish new vocabulary version New <code>vX.Y.Z</code> tag Deprecation Old terms marked deprecated Maintained until next MAJOR"},{"location":"en/governance/vocabulary-process/#7-guiding-objective","title":"7. Guiding Objective","text":"<p>The primary objective of CEP vocabulary governance is to stabilize meaning, maximize interoperability, and ensure backward compatibility while allowing the ecosystem to grow with new policy types, relationship structures, data standards, and domain models.</p>"},{"location":"en/implementation/cep-p3tags-binding/","title":"CEP P3Tags Binding","text":"<p>How Exchanges and Provenance Connect Across Civic Systems</p>"},{"location":"en/implementation/cep-p3tags-binding/#1-purpose","title":"1. Purpose","text":"<p>CEP and P3Tags serve different but complementary roles:</p> <ul> <li>CEP structures civic information: entities, relationships, and exchanges.  </li> <li>P3Tags attach provenance to individual artifacts such as documents, filings, attachments, posts, and AI-generated outputs.</li> </ul> <p>The binding defines how P3Tags reference CEP records, and how CEP exchanges may embed or associate provenance metadata.</p>"},{"location":"en/implementation/cep-p3tags-binding/#2-binding-principles","title":"2. Binding Principles","text":""},{"location":"en/implementation/cep-p3tags-binding/#21-loose-coupling","title":"2.1 Loose Coupling","text":"<p>CEP remains usable without P3Tags. P3Tags remain usable without CEP. The binding is optional but highly recommended for systems involving document workflows or AI-assisted transformations.</p>"},{"location":"en/implementation/cep-p3tags-binding/#22-stable-identifiers","title":"2.2 Stable Identifiers","text":"<p>Whenever possible, P3Tags reference:</p> <ul> <li><code>entityId</code> \u2014 a CEP entity  </li> <li><code>exchangeId</code> \u2014 a specific CEP exchange  </li> <li><code>relationshipId</code> \u2014 if provenance is tied to a structural relationship  </li> </ul> <p>Identifiers allow provenance to persist even as systems evolve.</p>"},{"location":"en/implementation/cep-p3tags-binding/#23-provenance-at-the-artifact-level","title":"2.3 Provenance at the Artifact Level","text":"<p>CEP describes structured civic records; P3Tags describe the artifacts flowing through those records:</p> <ul> <li>submitted forms  </li> <li>attachments  </li> <li>FOIA responses  </li> <li>meeting packets  </li> <li>contracts and amendments  </li> <li>AI-generated summaries or assessments  </li> </ul> <p>CEP and P3Tags complement each other by covering different layers of the civic process.</p>"},{"location":"en/implementation/cep-p3tags-binding/#3-embedding-p3tags-within-cep-exchanges","title":"3. Embedding P3Tags Within CEP Exchanges","text":"<p>A CEP exchange MAY include a <code>provenance</code> array:</p> <pre><code>{\n  \"exchangeId\": \"EXCH-2025-000944\",\n  \"exchangeTypeUri\": \"https://example.org/vocab/exchange/foia-response\",\n  \"content\": { \"...\": \"...\" },\n\n  \"provenance\": [\n    {\n      \"p3tagVersion\": \"1.0.0\",\n      \"timestamp\": \"2025-01-01T10:03:22Z\",\n      \"createdBy\": \"US-MN-COUNTY-048\",\n      \"sourceUri\": \"https://example.gov/records/123.pdf\",\n      \"hash\": \"sha256-abc123...\",\n      \"transform\": \"ocr\"\n    }\n  ]\n}\n</code></pre> <p>This does not embed the entire P3Tag schema inside CEP. It simply references a P3Tag-shaped object.</p>"},{"location":"en/implementation/cep-p3tags-binding/#4-p3tags-referencing-cep","title":"4. P3Tags Referencing CEP","text":"<p>A P3Tag MAY reference CEP identifiers:</p> <pre><code>{\n  \"p3tagVersion\": \"1.0.0\",\n  \"entityId\": \"US-MN-COUNTY-048\",\n  \"exchangeId\": \"EXCH-2025-000944\",\n  \"hash\": \"sha256-xyz789...\",\n  \"sourceUri\": \"...\",\n  \"timestamp\": \"2025-02-10T15:22:01Z\",\n  \"transform\": \"summarization\"\n}\n</code></pre> <p>This enables:</p> <ul> <li>document lineage</li> <li>audit trails</li> <li>linking analysis results back to their civic origin</li> <li>verifying whether an artifact corresponds to a known exchange</li> <li>connecting AI outputs back to official sources</li> </ul>"},{"location":"en/implementation/cep-p3tags-binding/#5-ai-workflow-considerations","title":"5. AI Workflow Considerations","text":"<p>AI systems often:</p> <ul> <li>extract</li> <li>summarize</li> <li>classify</li> <li>translate</li> <li>redact</li> <li>cluster</li> <li>evaluate</li> </ul> <p>documents and records.</p> <p>P3Tags allow each transformation to be recorded, while CEP provides:</p> <ul> <li>the context (entity, exchange type, relationship)</li> <li>the structural meaning of the document</li> <li>stable IDs to anchor provenance</li> </ul> <p>This enables transparent, reproducible, and auditable AI-assisted civic workflows.</p>"},{"location":"en/implementation/cep-p3tags-binding/#6-summary","title":"6. Summary","text":"<ul> <li>CEP structures civic information.</li> <li>P3Tags describe the provenance of individual artifacts.</li> <li>The binding is minimal, optional, and powerful.</li> <li>Together, they support transparency, automation, and accountability across civic systems.</li> </ul>"},{"location":"en/implementation/implementation-guide/","title":"Implementation Guide","text":"<p>This guide provides a practical overview for developers building Civic Exchange Protocol (CEP) implementations in any language. It complements the formal schemas and the categorical foundations by describing how to validate, construct, serialize, and verify CEP records in a deterministic and interoperable way.</p>"},{"location":"en/implementation/implementation-guide/#technical-assurance","title":"Technical Assurance","text":"<p>CEP ensures technical correctness through two mandatory components:</p>"},{"location":"en/implementation/implementation-guide/#a-the-canonical-string-the-debug-tool","title":"A. The Canonical String (The Debug Tool)","text":"<p>Every implementation must expose a function (e.g., <code>getCanonicalString</code>, <code>to_canonical_string</code>, or <code>generate_canonical_string</code>) that returns the raw, unhashed, deterministic string representation of a CEP record.</p> <ul> <li>Strict field ordering  </li> <li>UTC timestamps with microsecond precision  </li> <li>Deterministic numeric formatting  </li> <li>No locale or OS artifacts  </li> </ul> <p>This is the ground truth for resolving cross-language hash mismatches.</p>"},{"location":"en/implementation/implementation-guide/#b-the-certification-test-suite-the-compliance-gate","title":"B. The Certification Test Suite (The Compliance Gate)","text":"<p>All implementations must pass the cross-language hash-parity suite in <code>/test_vectors</code>.</p> <p>Any system that computes a different SHA-256 hash for a canonical test vector is non-conforming.</p>"},{"location":"en/implementation/implementation-guide/#getting-certified","title":"Getting Certified","text":"<ol> <li>Read <code>/specifications</code>.  </li> <li>Select the implementation folder for your platform (Rust, Python, etc.).  </li> <li>Integrate <code>TransactionRecord</code> and <code>generateValidationHash</code>.  </li> <li>Run tests with <code>/test_vectors</code>.  </li> <li>Use canonical debugging strings to correct mismatch sources.  </li> </ol>"},{"location":"en/implementation/implementation-guide/#logic-organization","title":"Logic Organization","text":"Package Focus Depends On Artifacts core Shared utilities none hashing, canonicalization, timestamps, errors entity Entity records core <code>EntityRecord</code> relationship Bilateral links core, entity <code>RelationshipRecord</code> exchange Flows between entities core, entity, relationship <code>ExchangeRecord</code>"},{"location":"en/implementation/implementation-guide/#1-implementation-goals","title":"1. Implementation Goals","text":"<p>A correct CEP implementation MUST:</p> <ol> <li>Produce canonical JSON matching the schemas  </li> <li>Achieve full hash parity across languages  </li> <li>Verify attestations  </li> <li>Maintain immutable hash-linked revision chains  </li> <li>Support multi-scheme identifiers  </li> <li>Compose provenance deterministically  </li> </ol>"},{"location":"en/implementation/implementation-guide/#2-canonical-serialization","title":"2. Canonical Serialization","text":"<p>CEP uses canonical JSON for:</p> <ul> <li>hash computation  </li> <li>digital signatures  </li> <li>verification  </li> <li>cross-node equality  </li> </ul>"},{"location":"en/implementation/implementation-guide/#21-requirements","title":"2.1 Requirements","text":"<p>Canonical JSON MUST:</p> <ul> <li>Sort all object keys lexicographically  </li> <li>Use UTF-8  </li> <li>Serialize timestamps as UTC with microsecond precision and trailing <code>Z</code> </li> <li>Avoid superfluous whitespace  </li> <li>Use stable ordering inside arrays where applicable  </li> </ul> <p>Example: <code>2025-09-15T14:03:22.500000Z</code></p>"},{"location":"en/implementation/implementation-guide/#22-canonical-field-order","title":"2.2 Canonical Field Order","text":"<p>Field order is enforced via CI and cross-language tests. Any deviation produces a hash mismatch.</p>"},{"location":"en/implementation/implementation-guide/#3-record-model-and-encapsulation-philosophy","title":"3. Record Model and Encapsulation Philosophy","text":"<p>CEP defines record-shaped data, not object-oriented domain objects. The goal is interoperable, predictable, schema-driven structures that behave identically in:</p> <ul> <li>Rust  </li> <li>Python  </li> <li>TypeScript  </li> <li>Java / C#  </li> <li>SQL and NoSQL databases  </li> </ul>"},{"location":"en/implementation/implementation-guide/#31-why-cep-records-use-public-fields","title":"3.1 Why CEP Records Use Public Fields","text":"<p>CEP records are transparent because:</p> <ul> <li>Auditors must inspect them directly  </li> <li>Schemas define their shape exactly  </li> <li>Canonicalization requires predictable visibility  </li> <li>Multi-language parity demands structural simplicity  </li> <li>Hidden or computed fields would break determinism  </li> </ul> <p>Thus CEP avoids private state and getters/setters.</p>"},{"location":"en/implementation/implementation-guide/#32-where-logic-belongs-builders-and-validators","title":"3.2 Where Logic Belongs: Builders and Validators","text":"<p>CEP enforces correctness outside the record struct:</p> <ul> <li>Builders (e.g., <code>EntityBuilder</code>, <code>RelationshipBuilder</code>)  </li> <li>enforce invariants  </li> <li>normalize input  </li> <li>generate identifiers (SNFEI)  </li> <li> <p>ensure field completeness  </p> </li> <li> <p>Validators </p> </li> <li>validate schema compliance  </li> <li>enforce vocabulary correctness  </li> <li>verify signatures  </li> <li> <p>enforce revision chain rules  </p> </li> <li> <p>Canonicalization </p> </li> <li>enforces deterministic ordering  </li> <li>produces canonical strings for hashing  </li> </ul>"},{"location":"en/implementation/implementation-guide/#33-when-methods-are-appropriate","title":"3.3 When Methods Are Appropriate","text":"<p>Methods are acceptable when they:</p> <ul> <li>produce derived values (e.g., <code>canonical_string()</code>)  </li> <li>do not mutate underlying data  </li> <li>increase clarity without altering canonical shape  </li> </ul>"},{"location":"en/implementation/implementation-guide/#34-takeaway","title":"3.4 Takeaway","text":"<p>CEP records are stable public data structures. Builders and validators enforce correctness. Canonicalization enforces determinism. This ensures interoperability, auditability, and future-proof evolution.</p>"},{"location":"en/implementation/implementation-guide/#4-attestation-and-verification","title":"4. Attestation and Verification","text":""},{"location":"en/implementation/implementation-guide/#41-attestation-block","title":"4.1 Attestation Block","text":"<p>Each CEP record includes:</p> <ul> <li><code>attestorId</code> </li> <li><code>attestationTimestamp</code> </li> <li><code>proofType</code> </li> <li><code>proofValue</code> </li> <li><code>verificationMethodUri</code> </li> <li><code>proofPurpose</code> </li> <li><code>anchorUri</code> (optional)  </li> </ul>"},{"location":"en/implementation/implementation-guide/#42-verification-workflow","title":"4.2 Verification Workflow","text":"<ol> <li>Resolve public key from <code>verificationMethodUri</code> </li> <li>Recompute canonical JSON excluding attestation block  </li> <li>Verify signature using <code>proofType</code> </li> <li>Check signature matches the canonical hash  </li> </ol> <p>Failures MUST cause rejection.</p>"},{"location":"en/implementation/implementation-guide/#5-revision-and-hash-chain","title":"5. Revision and Hash Chain","text":""},{"location":"en/implementation/implementation-guide/#51-lifecycle","title":"5.1 Lifecycle","text":"<pre><code>revision 1: previousRecordHash = null\nrevision 2+: previousRecordHash = SHA256(canonical previous)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#52-requirements","title":"5.2 Requirements","text":"<p>Implementations MUST:</p> <ul> <li>Enforce monotonic revision numbers  </li> <li>Reject incorrect previousRecordHash values  </li> <li>Treat any modification as a new revision  </li> </ul> <p>This forms a tamper-evident chain.</p>"},{"location":"en/implementation/implementation-guide/#6-identifier-interoperability","title":"6. Identifier Interoperability","text":"<p>CEP supports:</p> <ul> <li>UEI  </li> <li>LEI  </li> <li>SNFEI  </li> <li>Canadian BN  </li> <li>Additional scheme-based identifiers  </li> </ul>"},{"location":"en/implementation/implementation-guide/#61-best-practices","title":"6.1 Best Practices","text":"<ul> <li>Validate URIs using the identifier-scheme vocabulary  </li> <li>Validate known schemes strictly  </li> <li>Allow unknown schemes if structurally valid  </li> </ul>"},{"location":"en/implementation/implementation-guide/#7-provenance-composition","title":"7. Provenance Composition","text":"<p>Relationships and exchanges form a directed provenance graph.</p> <p>Implementations MUST:</p> <ul> <li>Validate relationship links  </li> <li>Build provenance chains deterministically  </li> <li>Support parent relationships/exchanges  </li> </ul>"},{"location":"en/implementation/implementation-guide/#71-funding-chain-convention","title":"7.1 Funding Chain Convention","text":"<p><code>FEDERAL&gt;STATE&gt;LOCAL</code></p> <p>Segments must be uppercase, separated by <code>&gt;</code>.</p>"},{"location":"en/implementation/implementation-guide/#8-vocabulary-integration","title":"8. Vocabulary Integration","text":"<p>Vocabulary URIs MUST resolve to known terms:</p> <ul> <li>relationship-type  </li> <li>exchange-type  </li> <li>party-role  </li> <li>exchange-role  </li> <li>identifier-scheme  </li> </ul> <p>Implementations SHOULD cache vocabularies locally.</p>"},{"location":"en/implementation/implementation-guide/#9-source-references","title":"9. Source References","text":"<p>Source references link CEP to external datasets.</p> <p>Implementations SHOULD:</p> <ul> <li>validate URI syntax  </li> <li>enforce nonempty IDs  </li> <li>optionally verify URL resolvability  </li> </ul>"},{"location":"en/implementation/implementation-guide/#10-example-implementation-pattern","title":"10. Example Implementation Pattern","text":"<pre><code>load_schemas()\nload_vocabularies()\n\nrecord = parse_input_json()\nvalidate_schema(record)\nvalidate_vocabularies(record)\n\ncanonical = canonicalize_json(record without attestation)\ncheck_revision_chain(canonical, record)\nverify_attestation(canonical, record.attestation)\n\nstore(record)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#11-language-specific-notes","title":"11. Language-Specific Notes","text":""},{"location":"en/implementation/implementation-guide/#python","title":"Python","text":"<p><code>json.dumps(..., separators=(',', ':'), sort_keys=True)</code></p>"},{"location":"en/implementation/implementation-guide/#typescript","title":"TypeScript","text":"<p>Use deterministic-stringify libraries.</p>"},{"location":"en/implementation/implementation-guide/#rust","title":"Rust","text":"<p>Use <code>serde_json::to_writer</code> with sorted maps.</p>"},{"location":"en/implementation/implementation-guide/#java-c","title":"Java / C","text":"<p>Use custom deterministic serializers.</p> <p>All languages MUST yield identical canonical bytes.</p>"},{"location":"en/implementation/implementation-guide/#12-conformance-levels","title":"12. Conformance Levels","text":"Level Meaning Basic Validates schemas + vocabularies Full Validates attestations + revision chains Verifying Node Maintains verified subcategory Authoritative Node Issues new attestations"},{"location":"en/implementation/implementation-guide/#13-summary","title":"13. Summary","text":"<p>A complete CEP implementation MUST:</p> <p>\u2714 Validate schemas \u2714 Canonicalize deterministically \u2714 Verify cryptographic attestations \u2714 Maintain hash-linked revisions \u2714 Interpret vocabularies correctly \u2714 Support provenance graph construction \u2714 Achieve hash parity across languages  </p> <p>This ensures global interoperability within the Civic Graph.</p>"},{"location":"en/implementation/validator/","title":"Validator","text":"<p>Paste a sample Civic Exchange Protocol record below and validate it against one of the official schemas.</p>"},{"location":"en/implementation/validator/#schema-endpoints","title":"Schema Endpoints","text":"<p>The validator checks your JSON against one of the official Civic Exchange Protocol schemas:</p> <ul> <li> <p>Entity Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.entity.schema.json</p> </li> <li> <p>Relationship Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.relationship.schema.json</p> </li> <li> <p>Exchange Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.exchange.schema.json</p> </li> <li> <p>Identifier Scheme vocabularies https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.entity.identifier-scheme.schema.json</p> </li> </ul>"},{"location":"en/implementation/validator/#step-1-choose-schema","title":"Step 1. Choose schema","text":"<p> Entity (cep.entity.schema.json) Relationship (cep.relationship.schema.json) Exchange (cep.exchange.schema.json) <p></p>"},{"location":"en/implementation/validator/#step-2-input-json","title":"Step 2. Input JSON","text":"{   \"schemaVersion\": \"1.0.0\",   \"verifiableId\": \"cep-entity:sam-uei:J6H4FB3N5YK7\",   \"identifiers\": {     \"samUei\": \"J6H4FB3N5YK7\",     \"snfei\": \"d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\",     \"additionalSchemes\": [       {         \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabularies/identifier-scheme.json#us-mn-district-id\",         \"value\": \"ISD-0123\"       },       {         \"schemeUri\": \"https://opencivicdata.org/id/division\",         \"value\": \"ocd-division/country:us/state:mn/school_district:123\"       }     ]   },   \"legalName\": \"Springfield Public School District 123\",   \"legalNameNormalized\": \"springfield public school district 123\",   \"entityTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabularies/entity-type.json#school-district\",   \"jurisdictionIso\": \"US-MN\",   \"status\": {     \"statusCode\": \"ACTIVE\",     \"statusEffectiveDate\": \"2001-07-01\",     \"statusTerminationDate\": null,     \"successorEntityId\": null   },   \"naicsCode\": null,   \"resolutionConfidence\": {     \"score\": 1.0,     \"methodUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabularies/resolution-method.json#authoritative-sam-sync\",     \"sourceRecordCount\": 1   },   \"attestation\": {     \"attestorId\": \"cep-entity:sam-uei:EDFEDERAL0001\",     \"attestationTimestamp\": \"2025-11-28T15:30:45.123456Z\",     \"proofType\": \"Ed25519Signature2020\",     \"proofValue\": \"BASE64_SIGNATURE_VALUE_HERE\",     \"verificationMethodUri\": \"https://keys.civic-interconnect.org/attestors/edfederal-node-1#primary-key\",     \"proofPurpose\": \"assertionMethod\",     \"anchorUri\": null   },   \"previousRecordHash\": null,   \"revisionNumber\": 1 }"},{"location":"en/implementation/validator/#step-3-validation-result","title":"Step 3. Validation Result","text":"(Waiting for input...)"},{"location":"en/reference/compatibility-matrix/","title":"Compatibility Matrix","text":"<p>Alignment of CEP and P3Tags with Existing Civic Standards and Ecosystems</p> <p>This matrix summarizes how Civic Interconnect integrates with leading civic data standards and common government systems. CEP provides the cross-domain structure; P3Tags provide the provenance layer.</p>"},{"location":"en/reference/compatibility-matrix/#overview-table","title":"Overview Table","text":"Standard / System What It Covers How CEP Integrates How P3Tags Integrate Value Added Open Civic Data (OCD) Jurisdictions, political divisions, IDs CEP entities reference OCD division IDs; relationships anchored to geography P3Tags reference jurisdiction identifiers when provenance is location-based Shared geography layer; consistent identifiers Popolo People, organizations, memberships CEP entities map to Popolo-style person/organization structures P3Tags reference actors involved in document creation or modification Unified identity layer compatible with many civic tools OCDS (Open Contracting Data Standard) Contracting lifecycle (tender &gt; award &gt; contract &gt; implementation) CEP exchanges wrap OCDS documents or link to specific lifecycle stages P3Tags attach to RFPs, bids, contracts, amendments End-to-end traceability across procurement W3C PROV General-purpose provenance ontology CEP aligns conceptually via entities/activities P3Tags act as a lightweight PROV profile Semantic-web compatibility without complexity FOIA / Public Records Vendor Systems Submission, routing, review, redaction, release CEP exchanges represent request/response workflows P3Tags track document lineage and redactions Zero-friction integration; better audit trails Procurement / ERP Systems Contracts, POs, invoices, amendments CEP structures the entity/relationship context; exchanges represent filings P3Tags document transformations, OCR, AI assistance Stronger compliance and cross-system linking Grant Reporting Systems Awards, periodic reports, audits CEP models multi-stage reporting as exchanges P3Tags attach to each submitted artifact Simplified compliance, especially for small jurisdictions AI / LLM Systems Retrieval, summarization, classification, transformation CEP provides structured context and stable IDs P3Tags record chain-of-transformation for AI outputs Transparent AI workflows; verifiable lineage"},{"location":"en/reference/compatibility-matrix/#notes","title":"Notes","text":"<ul> <li>CEP is intentionally schema-light and integrative, not a replacement for existing domain standards.  </li> <li>P3Tags remain artifact-level and can be used independently.  </li> <li>Combined, they enable transparent, interoperable, AI-ready civic data pipelines across institutions, vendors, and research ecosystems.</li> </ul>"},{"location":"en/reference/reference-projects/","title":"Reference Projects: GitHub Data Standards","text":"<p>There are categories of open-source projects on GitHub that offer great examples, particularly concerning common data schemas, multi-language support, and provenance tracking.</p>"},{"location":"en/reference/reference-projects/#1-interoperability-event-specifications-cross-platform","title":"1. Interoperability &amp; Event Specifications (Cross-Platform)","text":"<p>These standards focus on defining a common data format to ensure different systems and languages can communicate seamlessly. They typically define schemas and transport rules.</p>"},{"location":"en/reference/reference-projects/#cloudevents-specification","title":"CloudEvents Specification","text":"<p>This specification describes event data in a common way. It is designed to simplify event declaration and delivery across services, platforms, and languages (e.g., Go, Java, Python, C#).</p> <p>It's a good example of a cross-platform specification managed openly on GitHub. It defines a mandatory set of attributes (like a base entity identifier) that must be present in every data payload.</p> <p>Link: https://github.com/cloudevents/spec</p>"},{"location":"en/reference/reference-projects/#cdevents-specification","title":"CDEvents Specification","text":"<p>This is a popular specification for Continuous Delivery events, extending CloudEvents by introducing purpose and semantics to the event data.</p> <p>It shows how a standard is built on top of another standard (CloudEvents), specializing the common metadata for a specific domain (CI/CD provenance and flow).</p> <p>Link: https://github.com/cdevents/spec</p>"},{"location":"en/reference/reference-projects/#2-provenance-and-data-tracking-standards","title":"2. Provenance and Data Tracking Standards","text":"<p>These projects relate to provenance aspects, focusing on tracking the history, inputs, and derivation of data.</p>"},{"location":"en/reference/reference-projects/#prov-cpl-core-provenance-library","title":"PROV-CPL (Core Provenance Library)","text":"<p>This is the Core Provenance Library for collecting data provenance with multiple language bindings (C/C++, Java, Python, R). It uses the W3C PROV standard as its foundation.</p> <p>It demonstrates a multi-language implementation of a provenance standard, providing APIs to record who/what/when/where data was created, which is central to provenance.</p> <p>Link: https://github.com/ProvTools/prov-cpl</p>"},{"location":"en/reference/reference-projects/#3-general-data-schemas-and-monorepo-structure","title":"3. General Data Schemas and Monorepo Structure","text":"<p>These focus on using JSON Schema to define strict data structures and managing them in a versioned repository.</p>"},{"location":"en/reference/reference-projects/#json-schema-specification","title":"JSON Schema Specification","text":"<p>This is the official specification for JSON Schema, a declarative language used to annotate and validate JSON documents.</p> <p>This foundational tool is by many standards (including CloudEvents) to define specific fields and types. This repo illustrates how a core schema standard is defined and versioned.</p> <p>Link: https://github.com/json-schema-org/json-schema-spec</p>"},{"location":"en/reference/reference-projects/#consumer-data-standards-australian-dsb-schemas","title":"Consumer Data Standards (Australian DSB Schemas)","text":"<p>This repository holds a collection of JSON schema files derived from the Australian Consumer Data Standards, used for robust schema validation in banking and energy sectors.</p> <p>This offers a practical example of a large-scale data standard implementation in a monorepo (single repository), organized by release version, providing strict, enforceable JSON schemas for real-world data exchange.</p> <p>Link: https://github.com/ConsumerDataStandardsAustralia/dsb-schema-tools</p>"},{"location":"en/reference/reference-standards/","title":"Reference Standards","text":""},{"location":"en/reference/reference-standards/#associated-standards","title":"Associated Standards","text":"Standard/Acronym Purpose Why We Interface XBRL (eXtensible Business Reporting Language) The international standard for electronic transmission of business and financial data (e.g., SEC and FDIC filings use it). We map its transactional fields directly to the relevant XBRL taxonomy elements for regulatory compliance reporting. LEI (Legal Entity Identifier) Global standard for identifying parties to financial transactions worldwide. While the UEI is authoritative in the U.S. government space, our protocol needs to contain a field for the LEI if the entity is globally registered, ensuring compliance for any international transactions. W3C PROV (Provenance) The World Wide Web Consortium standard for recording the historical lifecycle and data quality of a piece of information. Our core value is Provenance. We adopt the principles of W3C PROV to formally define how data history, revisions, and sources are timestamped and logged. GTAS (Government-wide Treasury Account Symbol) The framework used by the Treasury for standardized federal financial reporting. Transactional data (e.g., amounts, categories) must be translatable into GTAS fields for seamless reporting up to the Treasury level."},{"location":"en/reference/reference-standards/#bridge","title":"Bridge","text":"<ul> <li>Official U.S UEI: The U.S. government already uses a Unique Entity Identifier (UEI), a 12-character alphanumeric ID assigned by SAM.gov, for all entities receiving federal financial assistance or doing business with the federal government (Source 3.1, 3.2). Often does not appear on state/local campaign finance reports or local school district consultant contracts unless federal funds are directly involved.</li> <li>Open-Source Data Cleaning Tools: Tools like Splink, OpenRefine, and Python/Pandas to manually clean and standardize messy names (\"Acme Consulting, LLC\" vs. \"Acme Consulting\") (Source 2.1, 2.3).</li> </ul>"}]}