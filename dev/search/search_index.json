{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"en/","title":"Project Documentation","text":"<p>Documentation for civic-interconnect.</p> <p>Use the navigation menu to explore available modules and APIs.</p> <ul> <li>The API Reference section includes autogenerated docs from the source code.</li> <li>This home page will always be served at <code>/</code>.</li> </ul> <p>To learn more, visit the GitHub repository.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"en/api/#civic_interconnect","title":"civic_interconnect","text":""},{"location":"en/api/#civic_interconnect.cep","title":"cep","text":"<p>Top-level package for Civic Interconnect CEP Python helpers.</p> <p>This module intentionally avoids importing submodules at import time to prevent circular imports. Callers should import subpackages explicitly, e.g.:</p> <pre><code>from ci_cep.localization import load_localization\nfrom ci_cep.adapters.us_mn_municipality import build_municipality_entity\nfrom ci_cep.entity.api import build_entity_from_raw\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters","title":"adapters","text":"<p>Adapters package for civic-interconnect CEP.</p> <p>This package contains adapter implementations for external integrations.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.demo_entities","title":"demo_entities","text":"<p>Demo adapters for CEP Entity examples.</p> <p>This module provides helper functions for working with example \"slice\" directories such as:</p> <pre><code>examples/entity/municipality/us_il_01/\n</code></pre> <p>A slice is any directory that contains:</p> <pre><code>01_raw_source.json\n</code></pre> <p>These helpers are used by the CLI, but are also importable by tests or notebooks for experimentation.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.demo_entities.ExampleEntityInputs","title":"ExampleEntityInputs  <code>dataclass</code>","text":"<p>Minimal inputs needed to drive the Entity pipeline for examples.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/demo_entities.py</code> <pre><code>@dataclass\nclass ExampleEntityInputs:\n    \"\"\"Minimal inputs needed to drive the Entity pipeline for examples.\"\"\"\n\n    jurisdiction_iso: str\n    legal_name: str\n    country_code: str\n    entity_type: str\n    address: str | None\n    registration_date: str | None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.demo_entities.extract_example_entity_inputs","title":"extract_example_entity_inputs","text":"<pre><code>extract_example_entity_inputs(\n    raw: dict[str, Any], slice_dir: Path\n) -&gt; ExampleEntityInputs\n</code></pre> <p>Map messy raw shapes from example slices into normalized inputs.</p> <p>This is intentionally simple and example-focused. It supports the current demo shapes:</p> <ul> <li>municipality: official_name + state + country</li> <li>nonprofit: legalName, countryCode, registrationDate</li> <li>pac: committee_name, fec_id, etc.</li> <li>school_district: district_name + state + country</li> </ul> <p>If a required field is missing, it raises KeyError with a combined key hint so callers can emit friendly messages.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/demo_entities.py</code> <pre><code>def extract_example_entity_inputs(raw: dict[str, Any], slice_dir: Path) -&gt; ExampleEntityInputs:\n    \"\"\"Map messy raw shapes from example slices into normalized inputs.\n\n    This is intentionally simple and example-focused. It supports the\n    current demo shapes:\n\n    - municipality: official_name + state + country\n    - nonprofit: legalName, countryCode, registrationDate\n    - pac: committee_name, fec_id, etc.\n    - school_district: district_name + state + country\n\n    If a required field is missing, it raises KeyError with a combined\n    key hint so callers can emit friendly messages.\n    \"\"\"\n    # jurisdictionIso: prefer explicit, then raw \"jurisdiction\",\n    # otherwise derive from state + country.\n    if \"jurisdictionIso\" in raw:\n        jurisdiction_iso = str(raw[\"jurisdictionIso\"])\n    elif \"jurisdiction\" in raw:\n        jurisdiction_iso = str(raw[\"jurisdiction\"])\n    else:\n        state = raw.get(\"state\")\n        country_code_raw = raw.get(\"country\") or raw.get(\"countryCode\")\n        if not state or not country_code_raw:\n            raise KeyError(\"jurisdictionIso/jurisdiction/state/country\")\n        jurisdiction_iso = f\"{country_code_raw}-{state}\"\n\n    # legalName: try the common example keys in order.\n    legal_name = (\n        raw.get(\"legalName\")\n        or raw.get(\"official_name\")\n        or raw.get(\"committee_name\")\n        or raw.get(\"district_name\")\n        or raw.get(\"name\")\n    )\n    if not legal_name:\n        raise KeyError(\"legalName/official_name/committee_name/district_name/name\")\n    legal_name_str = str(legal_name)\n\n    # countryCode: explicit or from \"country\", default US for demos.\n    country_code = str(raw.get(\"countryCode\") or raw.get(\"country\") or \"US\")\n\n    # entityType: explicit or infer from folder name\n    entity_type = str(raw.get(\"entityType\") or slice_dir.parent.name)\n\n    address = raw.get(\"address\")\n    registration_date = raw.get(\"registrationDate\")\n\n    return ExampleEntityInputs(\n        jurisdiction_iso=jurisdiction_iso,\n        legal_name=legal_name_str,\n        country_code=country_code,\n        entity_type=entity_type,\n        address=address,\n        registration_date=registration_date,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.demo_entities.find_example_slices","title":"find_example_slices","text":"<pre><code>find_example_slices(root: Path) -&gt; list[Path]\n</code></pre> <p>Return all example slice directories that contain 01_raw_source.json.</p> <p>If <code>root</code> is itself a slice dir, include it. Otherwise, search recursively.</p> <p>This is intentionally file-system based so it works the same for CLI, tests, and notebooks.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/demo_entities.py</code> <pre><code>def find_example_slices(root: Path) -&gt; list[Path]:\n    \"\"\"Return all example slice directories that contain 01_raw_source.json.\n\n    If `root` is itself a slice dir, include it. Otherwise, search recursively.\n\n    This is intentionally file-system based so it works the same for CLI,\n    tests, and notebooks.\n    \"\"\"\n    slices: list[Path] = []\n\n    if root.is_dir() and (root / \"01_raw_source.json\").is_file():\n        slices.append(root)\n\n    # Recurse for nested slices\n    for raw_file in root.rglob(\"01_raw_source.json\"):\n        slices.append(raw_file.parent)\n\n    # De-duplicate while preserving order\n    seen: set[Path] = set()\n    unique: list[Path] = []\n    for s in slices:\n        if s not in seen:\n            seen.add(s)\n            unique.append(s)\n    return unique\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.demo_entities.load_raw_source","title":"load_raw_source","text":"<pre><code>load_raw_source(slice_dir: Path) -&gt; dict[str, Any]\n</code></pre> <p>Load the 01_raw_source.json for a slice, with friendly errors.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the raw file is missing.</p> <code>ValueError</code> <p>if the file exists but is not valid JSON.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/demo_entities.py</code> <pre><code>def load_raw_source(slice_dir: Path) -&gt; dict[str, Any]:\n    \"\"\"Load the 01_raw_source.json for a slice, with friendly errors.\n\n    Raises:\n        FileNotFoundError: if the raw file is missing.\n        ValueError: if the file exists but is not valid JSON.\n    \"\"\"\n    raw_path = slice_dir / RAW_FILENAME\n    if not raw_path.is_file():\n        raise FileNotFoundError(f\"Raw source not found: {raw_path}\")\n\n    try:\n        with raw_path.open(\"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n    except json.JSONDecodeError as exc:\n        raise ValueError(f\"Raw source {raw_path} is not valid JSON: {exc}\") from exc\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.fec_csv","title":"fec_csv","text":"<p>FEC CSV adapter for the Civic Engagement Platform.</p> <p>This module provides adapters for reading and processing Federal Election Commission (FEC) CSV data files.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.state_portal_example","title":"state_portal_example","text":"<p>State portal example adapter for the CEP system.</p> <p>This module provides an example adapter implementation for connecting to state portals and retrieving civic engagement data.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality","title":"us_ca_municipality","text":"<p>Adapter for US California municipality data sources.</p> <p>This module provides adapters for connecting to and retrieving data from California municipal government systems and data sources.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-CA\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-CA',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-CA\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ca_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ca_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality","title":"us_mn_municipality","text":"<p>Adapter for US Minnesota municipality data sources.</p> <p>This module provides adapters for connecting to and transforming data from Minnesota municipal government systems into normalized CEP-ready payloads.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-MN\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-MN',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-MN\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_mn_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_mn_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality","title":"us_ny_municipality","text":"<p>Adapter for US New York State municipality data sources.</p> <p>This module provides adapters for connecting to and retrieving data from New York State municipal government systems and data sources.</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.RawMunicipality","title":"RawMunicipality  <code>dataclass</code>","text":"<p>Minimal view of a raw municipality record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>@dataclass\nclass RawMunicipality:\n    \"\"\"Minimal view of a raw municipality record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str = \"US-NY\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.build_municipality_entity","title":"build_municipality_entity","text":"<pre><code>build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = 'US-NY',\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a municipality from a raw input dict.</p> <p>Adapter responsibilities: - extract and clean raw fields from source - apply localization and normalization - compute SNFEI and other derived fields - produce a normalized payload for the builder facade</p> <p>Builder responsibilities (ci_cep.entity.api): - convert normalized payload to a full CEP Entity envelope - apply schema-level defaults, attestation, revision chain, etc.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>def build_municipality_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str = \"US-NY\",\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a municipality from a raw input dict.\n\n    Adapter responsibilities:\n    - extract and clean raw fields from source\n    - apply localization and normalization\n    - compute SNFEI and other derived fields\n    - produce a normalized payload for the builder facade\n\n    Builder responsibilities (ci_cep.entity.api):\n    - convert normalized payload to a full CEP Entity envelope\n    - apply schema-level defaults, attestation, revision chain, etc.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n\n    raw = RawMunicipality(legal_name=str(raw_record[\"legal_name\"]).strip())\n\n    # Load and apply localization\n    loc_cfg: LocalizationConfig = load_localization(localization_jurisdiction)\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n\n    # Compute SNFEI based on normalized name and jurisdiction\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    # This is the normalized payload passed to the builder.\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"municipality\",\n        # Room for additional fields later:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    # Delegate to the builder facade (Python now, Rust later).\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_ny_municipality.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_ny_municipality.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_school_district","title":"us_school_district","text":"<p>Adapter for US school district data sources.</p> <p>This module provides an adapter for turning raw US school district records into normalized payloads for the CEP Entity builder.</p> <p>Adapters are responsible for: - extracting and cleaning raw fields from source - applying localization and normalization - computing SNFEI and other derived fields - producing a normalized payload for the builder facade</p> <p>The builder facade (civic_interconnect.cep.entity.api.build_entity_from_raw) is responsible for: - converting the normalized payload to a full CEP Entity envelope - applying schema-level defaults, attestation, revision chain, etc. - delegating to the Rust core via cep_py when available</p>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_school_district.RawSchoolDistrict","title":"RawSchoolDistrict  <code>dataclass</code>","text":"<p>Minimal view of a raw school district record.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_school_district.py</code> <pre><code>@dataclass\nclass RawSchoolDistrict:\n    \"\"\"Minimal view of a raw school district record.\"\"\"\n\n    legal_name: str\n    jurisdiction_iso: str  # e.g. \"US-MN\", \"US-CA\", \"US-NY\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_school_district.build_school_district_entity","title":"build_school_district_entity","text":"<pre><code>build_school_district_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build a CEP Entity record for a school district from a raw input dict.</p> <p>Expected raw_record keys: - legal_name: display/legal name from the source system - jurisdiction_iso: ISO 3166 style jurisdiction, e.g. \"US-MN\"</p> <p>If localization_jurisdiction is not provided, this function will use raw_record[\"jurisdiction_iso\"] as the localization key.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_school_district.py</code> <pre><code>def build_school_district_entity(\n    raw_record: dict[str, Any],\n    localization_jurisdiction: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Build a CEP Entity record for a school district from a raw input dict.\n\n    Expected raw_record keys:\n    - legal_name: display/legal name from the source system\n    - jurisdiction_iso: ISO 3166 style jurisdiction, e.g. \"US-MN\"\n\n    If localization_jurisdiction is not provided, this function will\n    use raw_record[\"jurisdiction_iso\"] as the localization key.\n    \"\"\"\n    if \"legal_name\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'legal_name'.\")\n    if \"jurisdiction_iso\" not in raw_record:\n        raise ValueError(\"raw_record must contain 'jurisdiction_iso'.\")\n\n    raw = RawSchoolDistrict(\n        legal_name=str(raw_record[\"legal_name\"]).strip(),\n        jurisdiction_iso=str(raw_record[\"jurisdiction_iso\"]).strip(),\n    )\n\n    loc_key = localization_jurisdiction or raw.jurisdiction_iso\n    loc_cfg: LocalizationConfig = load_localization(loc_key)\n\n    normalized_name = normalize_name(raw.legal_name, loc_cfg)\n    snfei = compute_snfei(normalized_name, raw.jurisdiction_iso)\n\n    normalized_payload: dict[str, Any] = {\n        \"jurisdictionIso\": raw.jurisdiction_iso,\n        \"legalName\": raw.legal_name,\n        \"legalNameNormalized\": normalized_name,\n        \"snfei\": snfei,\n        \"entityType\": \"school_district\",\n        # Extension surface for future fields:\n        # \"sourceSystem\": raw_record.get(\"source_system\"),\n        # \"externalIds\": raw_record.get(\"external_ids\", {}),\n    }\n\n    return build_entity_from_raw(normalized_payload)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.adapters.us_school_district.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; str\n</code></pre> <p>Compute SNFEI-style hash from normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/adapters/us_school_district.py</code> <pre><code>def compute_snfei(normalized_name: str, jurisdiction_iso: str) -&gt; str:\n    \"\"\"Compute SNFEI-style hash from normalized name and jurisdiction.\"\"\"\n    key = f\"{normalized_name}|{jurisdiction_iso}\"\n    return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen","title":"codegen","text":"<p>Code generation module for CEP (Complex Event Processing).</p> <p>This module provides utilities and classes for generating code related to complex event processing operations.</p>"},{"location":"en/api/#civic_interconnect.cep.codegen.python_constants","title":"python_constants","text":"<p>Generate Python field-name constants from CEP JSON Schemas.</p> <p>This is a companion to <code>rust_generated.py</code> that keeps all camelCase JSON field names in one generated place, so adapters and other Python code never hand-type schema field names.</p> <p>It currently generates two modules:</p> <ul> <li>civic_interconnect.cep.constants.entity_fields</li> <li>civic_interconnect.cep.constants.record_envelope_fields</li> </ul> <p>File: src/python/src/civic_interconnect/cep/codegen/python_constants.py</p>"},{"location":"en/api/#civic_interconnect.cep.codegen.python_constants.FieldConstant","title":"FieldConstant  <code>dataclass</code>","text":"<p>Represents a single Python constant mapping to a JSON field name.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/python_constants.py</code> <pre><code>@dataclass(frozen=True)\nclass FieldConstant:\n    \"\"\"Represents a single Python constant mapping to a JSON field name.\"\"\"\n\n    const_name: str  # e.g. ENTITY_LEGAL_NAME\n    json_name: str  # e.g. \"legalName\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.python_constants.write_all_constants","title":"write_all_constants","text":"<pre><code>write_all_constants(\n    entity_schema_path: Path = DEFAULT_ENTITY_SCHEMA,\n    entity_out: Path = DEFAULT_ENTITY_CONSTANTS_OUT,\n    envelope_schema_path: Path = DEFAULT_ENVELOPE_SCHEMA,\n    envelope_out: Path = DEFAULT_ENVELOPE_CONSTANTS_OUT,\n) -&gt; None\n</code></pre> <p>Generate both entity and record envelope constants in one call.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/python_constants.py</code> <pre><code>def write_all_constants(\n    entity_schema_path: Path = DEFAULT_ENTITY_SCHEMA,\n    entity_out: Path = DEFAULT_ENTITY_CONSTANTS_OUT,\n    envelope_schema_path: Path = DEFAULT_ENVELOPE_SCHEMA,\n    envelope_out: Path = DEFAULT_ENVELOPE_CONSTANTS_OUT,\n) -&gt; None:\n    \"\"\"Generate both entity and record envelope constants in one call.\"\"\"\n    write_entity_constants(entity_schema_path, entity_out)\n    write_envelope_constants(envelope_schema_path, envelope_out)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.python_constants.write_entity_constants","title":"write_entity_constants","text":"<pre><code>write_entity_constants(\n    entity_schema_path: Path, out_path: Path\n) -&gt; None\n</code></pre> <p>Generate the Python constants module for entity field names.</p> <ul> <li>entity_schema_path: path to <code>cep.entity.schema.json</code></li> <li>out_path: path to write <code>entity_fields.py</code></li> </ul> Source code in <code>src/python/src/civic_interconnect/cep/codegen/python_constants.py</code> <pre><code>def write_entity_constants(entity_schema_path: Path, out_path: Path) -&gt; None:\n    \"\"\"Generate the Python constants module for entity field names.\n\n    - entity_schema_path: path to `cep.entity.schema.json`\n    - out_path: path to write `entity_fields.py`\n    \"\"\"\n    with entity_schema_path.open(\"r\", encoding=\"utf-8\") as f:\n        schema = json.load(f)\n\n    prop_names = _collect_entity_properties(schema)\n    constants = _build_entity_field_constants(prop_names)\n\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n\n    with out_path.open(\"w\", encoding=\"utf-8\") as f:\n        f.write(\n            \"# This file is AUTO-GENERATED by cx codegen-python-constants.\\n\"\n            \"# Do not edit by hand. To change field names, update the JSON\\n\"\n            \"# schema (schemas/cep.entity.schema.json) and re-run:\\n\"\n            \"#\\n\"\n            \"#     uv run cx codegen-python-constants\\n\"\n            \"#\\n\"\n            '\"\"\"Python constants for CEP Entity JSON field names.\\n'\n            \"\\n\"\n            \"These constants ensure adapters never hand-type camelCase\\n\"\n            \"field names. All values MUST match the JSON Schemas.\\n\"\n            '\"\"\"\\n\\n'\n        )\n\n        for const in constants:\n            f.write(f'{const.const_name} = \"{const.json_name}\"\\n')\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.python_constants.write_envelope_constants","title":"write_envelope_constants","text":"<pre><code>write_envelope_constants(\n    envelope_schema_path: Path, out_path: Path\n) -&gt; None\n</code></pre> <p>Generate the Python constants module for record envelope field names.</p> <ul> <li>envelope_schema_path: path to <code>cep.record-envelope.schema.json</code></li> <li>out_path: path to write <code>record_envelope_fields.py</code></li> </ul> Source code in <code>src/python/src/civic_interconnect/cep/codegen/python_constants.py</code> <pre><code>def write_envelope_constants(envelope_schema_path: Path, out_path: Path) -&gt; None:\n    \"\"\"Generate the Python constants module for record envelope field names.\n\n    - envelope_schema_path: path to `cep.record-envelope.schema.json`\n    - out_path: path to write `record_envelope_fields.py`\n    \"\"\"\n    with envelope_schema_path.open(\"r\", encoding=\"utf-8\") as f:\n        schema = json.load(f)\n\n    constants = _build_envelope_field_constants(schema)\n\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n\n    with out_path.open(\"w\", encoding=\"utf-8\") as f:\n        f.write(\n            \"# This file is AUTO-GENERATED by cx codegen-python-constants.\\n\"\n            \"# Do not edit by hand. To change field names, update the JSON\\n\"\n            \"# schemas (schemas/cep.record-envelope.schema.json) and re-run:\\n\"\n            \"#\\n\"\n            \"#     uv run cx codegen-python-constants\\n\"\n            \"#\\n\"\n            '\"\"\"Python constants for CEP record envelope JSON field names.\\n'\n            \"\\n\"\n            \"These constants ensure adapters and tools never hand-type\\n\"\n            \"camelCase field names for the shared envelope, status,\\n\"\n            \"timestamps, and attestations.\\n\"\n            '\"\"\"\\n\\n'\n        )\n\n        for const in constants:\n            f.write(f'{const.const_name} = \"{const.json_name}\"\\n')\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated","title":"rust_generated","text":"<p>Code generation utilities for creating Rust structs from JSON Schema.</p> <p>This module provides functions to: - Convert JSON Schema files into Rust struct definitions - Map JSON Schema types to Rust types - Generate serde-compatible field attributes - Handle nullable and optional fields - Recursively generate nested object types</p> <p>File: src/python/src/civic_interconnect/cep/codegen/rust_generated.py</p> <p>uv run cx codegen-rust</p> <p>uv run python src/python/src/civic_interconnect/cep/codegen/rust_generated.py</p>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated.generate_rust_struct","title":"generate_rust_struct","text":"<pre><code>generate_rust_struct(\n    schema_path: Path, struct_name: str\n) -&gt; str\n</code></pre> <p>Generate a single Rust struct from a JSON Schema file.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/rust_generated.py</code> <pre><code>def generate_rust_struct(schema_path: Path, struct_name: str) -&gt; str:\n    \"\"\"Generate a single Rust struct from a JSON Schema file.\"\"\"\n    root: dict[str, Any] = _load_schema_for_codegen(schema_path)\n\n    flat: dict[str, Any] = {}\n    _flatten_schema(root, root, flat)\n\n    properties: dict[str, Any] = flat.get(\"properties\", {})\n    description = root.get(\"description\", \"\")\n\n    lines: list[str] = [RUST_HEADER]\n\n    special_types: dict[str, str] = {}\n    nested_structs: list[str] = []\n\n    record_kind_enum = _generate_record_kind_enum(root)\n    if record_kind_enum:\n        lines.append(record_kind_enum)\n        special_types[\"recordKind\"] = \"RecordKind\"\n\n    envelope_items = _generate_envelope_items(root, special_types, nested_structs)\n    if envelope_items:\n        lines.append(envelope_items)\n\n    identifiers_items = \"\"\n    if \"identifiers\" in properties:\n        identifiers_items = (\n            \"#[derive(Debug, Clone, Serialize, Deserialize)]\\n\"\n            '#[serde(rename_all = \"camelCase\")]\\n'\n            \"pub struct Identifier {\\n\"\n            '    #[serde(rename = \"schemeUri\")]\\n'\n            \"    pub scheme_uri: String,\\n\"\n            \"    pub identifier: String,\\n\"\n            '    #[serde(rename = \"sourceReference\", skip_serializing_if = \"Option::is_none\")]\\n'\n            \"    pub source_reference: Option&lt;String&gt;,\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"pub type Identifiers = Vec&lt;Identifier&gt;;\\n\"\n            \"\\n\"\n        )\n        special_types[\"identifiers\"] = \"Identifiers\"\n\n    if identifiers_items:\n        lines.append(identifiers_items)\n\n    # Process all fields to collect nested structs\n    for name, prop_schema in properties.items():\n        if name not in special_types:\n            _rust_type_for_schema(prop_schema, nested_structs, struct_name, name)\n\n    # Emit nested structs before the main struct\n    for nested in nested_structs:\n        lines.append(nested)\n\n    # Emit the main record struct\n    if description:\n        lines.append(\"/// \" + description + \"\\n\")\n\n    lines.append(\"#[derive(Debug, Clone, Serialize, Deserialize)]\")\n    lines.append('#[serde(rename_all = \"camelCase\")]')\n    lines.append(\"pub struct \" + struct_name + \" {\")\n\n    for name, prop_schema in properties.items():\n        lines.append(\n            _field_line(name, prop_schema, flat, special_types, nested_structs, struct_name)\n        )\n\n    lines.append(\"}\")\n    lines.append(\"\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.codegen.rust_generated.write_generated_rust","title":"write_generated_rust","text":"<pre><code>write_generated_rust(\n    schema_path: Path, struct_name: str, out_path: Path\n) -&gt; None\n</code></pre> <p>Generate Rust code from schema_path and write to out_path.</p> Source code in <code>src/python/src/civic_interconnect/cep/codegen/rust_generated.py</code> <pre><code>def write_generated_rust(\n    schema_path: Path,\n    struct_name: str,\n    out_path: Path,\n) -&gt; None:\n    \"\"\"Generate Rust code from schema_path and write to out_path.\"\"\"\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    rust_code = generate_rust_struct(schema_path, struct_name)\n    out_path.write_text(rust_code, encoding=\"utf-8\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core","title":"core","text":"<p>CEP Core - Core primitives for the Civic Exchange Protocol.</p> <p>This package provides the foundational types used by all CEP record types:</p> <ul> <li>CanonicalTimestamp: Microsecond-precision UTC timestamps</li> <li>CanonicalHash: SHA-256 hash values</li> <li>Canonicalize: Base class for deterministic serialization</li> <li>Attestation: Cryptographic proof of record integrity</li> <li>Schema Registry: Central schema loading and validation support</li> </ul>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.attestation","title":"attestation","text":"<p>Attestation and cryptographic proof types for CEP records.</p> <p>Every CEP record includes an attestation block that proves: - Who attested to the record (attestor_id) - When it was attested (attestation_timestamp) - Cryptographic proof of integrity (proof_type, proof_value, verification_method_uri)</p>"},{"location":"en/api/#civic_interconnect.cep.core.attestation.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre> canonical_fields \u00b6 <pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre> new <code>classmethod</code> \u00b6 <pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre> with_anchor \u00b6 <pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre> with_purpose \u00b6 <pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.attestation.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre> as_str \u00b6 <pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical","title":"canonical","text":"<p>Canonical serialization for CEP records.</p> <p>This module provides the base class and utilities for generating deterministic canonical strings from CEP records. The canonical string is the input to SHA-256 hashing for record integrity verification.</p> <p>Canonicalization Rules: 1. Field Order: Fields MUST be serialized in alphabetical order. 2. Null/Empty Omission: Fields with None or empty string values    MUST be omitted entirely from the canonical string. 3. Timestamp Format: All timestamps MUST use YYYY-MM-DDTHH:MM:SS.ffffffZ    with exactly 6 decimal places for microseconds. 4. Numeric Format: Monetary amounts MUST use exactly 2 decimal places.    Integers MUST NOT have decimal points. 5. String Escaping: Strings are NOT JSON-escaped in the canonical form.    The canonical string is a simple key:value concatenation. 6. Encoding: The canonical string MUST be UTF-8 encoded.</p>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre> calculate_hash \u00b6 <pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre> canonical_fields <code>abstractmethod</code> \u00b6 <pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre> to_canonical_string \u00b6 <pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.canonical.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error","title":"error","text":"<p>Error types for CEP operations.</p>"},{"location":"en/api/#civic_interconnect.cep.core.error.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre> __init__ \u00b6 <pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.error.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre> __init__ \u00b6 <pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.hash","title":"hash","text":"<p>Cryptographic hashing utilities for CEP records.</p> <p>All CEP hashes are SHA-256, represented as lowercase hexadecimal strings.</p>"},{"location":"en/api/#civic_interconnect.cep.core.hash.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre> __hash__ \u00b6 <pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre> __init__ \u00b6 <pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre> __repr__ \u00b6 <pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre> __str__ \u00b6 <pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre> as_bytes \u00b6 <pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre> as_hex \u00b6 <pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre> from_canonical_string <code>classmethod</code> \u00b6 <pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre> from_hex <code>classmethod</code> \u00b6 <pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry","title":"schema_registry","text":"<p>Central schema registry for CEP validation.</p>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.schema_registry.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.timestamp","title":"timestamp","text":"<p>Canonical timestamp handling for CEP records.</p> <p>All CEP timestamps MUST be: - UTC timezone (indicated by 'Z' suffix) - ISO 8601 format - Microsecond precision (exactly 6 decimal places)</p> <p>Example: 2025-11-28T14:30:00.000000Z</p>"},{"location":"en/api/#civic_interconnect.cep.core.timestamp.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre> __ge__ \u00b6 <pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre> __gt__ \u00b6 <pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre> __hash__ \u00b6 <pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre> __init__ \u00b6 <pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre> __le__ \u00b6 <pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre> __lt__ \u00b6 <pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre> __repr__ \u00b6 <pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre> __str__ \u00b6 <pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre> as_datetime \u00b6 <pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre> now <code>classmethod</code> \u00b6 <pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre> parse <code>classmethod</code> \u00b6 <pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre> to_canonical_string \u00b6 <pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_interconnect/cep/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.core.version","title":"version","text":"<p>CEP version constants.</p>"},{"location":"en/api/#civic_interconnect.cep.entity","title":"entity","text":"<p>Entity module for civic-interconnect CEP.</p> <p>This module contains entity classes and related functionality.</p>"},{"location":"en/api/#civic_interconnect.cep.entity.api","title":"api","text":"<p>CEP Entity builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Entity records from normalized adapter payloads.</p> <p>Adapters should call build_entity_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p> <p>File: src/python/src/civic_interconnect/cep/entity/api.py</p>"},{"location":"en/api/#civic_interconnect.cep.entity.api.build_entity_from_raw","title":"build_entity_from_raw","text":"<pre><code>build_entity_from_raw(\n    raw: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert a normalized adapter payload into a full CEP Entity record.</p> <p>Expected raw keys: - jurisdictionIso: ISO 3166 style jurisdiction code, for example \"US-MN\" - legalName: canonical or near-canonical name from source - legalNameNormalized: normalized form used for SNFEI - snfei: SNFEI hash computed by the adapter - entityType: domain type label such as \"municipality\", \"school_district\", etc.</p> <p>This function: - applies schema-level defaults - constructs verifiableId - attaches identifiers and status - populates timestamps and an initial attestation block</p> <p>If the cep_py native extension is available, this function delegates to Rust. Otherwise, it uses a pure Python implementation.</p> <p>In both cases, it normalizes the output shape so that: - entityTypeUri is present - identifiers[\"snfei\"] exists and is a dict with a \"value\" field</p> Source code in <code>src/python/src/civic_interconnect/cep/entity/api.py</code> <pre><code>def build_entity_from_raw(raw: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Convert a normalized adapter payload into a full CEP Entity record.\n\n    Expected raw keys:\n    - jurisdictionIso: ISO 3166 style jurisdiction code, for example \"US-MN\"\n    - legalName: canonical or near-canonical name from source\n    - legalNameNormalized: normalized form used for SNFEI\n    - snfei: SNFEI hash computed by the adapter\n    - entityType: domain type label such as \"municipality\", \"school_district\", etc.\n\n    This function:\n    - applies schema-level defaults\n    - constructs verifiableId\n    - attaches identifiers and status\n    - populates timestamps and an initial attestation block\n\n    If the cep_py native extension is available, this function delegates\n    to Rust. Otherwise, it uses a pure Python implementation.\n\n    In both cases, it normalizes the output shape so that:\n    - entityTypeUri is present\n    - identifiers[\"snfei\"] exists and is a dict with a \"value\" field\n    \"\"\"\n    # Basic validation of the normalized payload\n    required_keys = [\n        \"jurisdictionIso\",\n        \"legalName\",\n        \"legalNameNormalized\",\n        \"snfei\",\n        \"entityType\",\n    ]\n    missing = [k for k in required_keys if k not in raw]\n    if missing:\n        raise ValueError(f\"Normalized entity payload is missing keys: {missing}\")\n\n    # Decide which backend to use\n    if HAS_NATIVE_BACKEND and _build_entity_json_native is not None:\n        try:\n            input_json = json.dumps(raw, sort_keys=True)\n            output_json = _build_entity_json_native(input_json)  # type: ignore[misc]\n            entity: dict[str, Any] = json.loads(output_json)\n        except Exception as exc:\n            # Defensive fallback: log-friendly message and drop back to Python.\n            print(\n                \"[ci_cep.entity.api] Warning: native backend failed \"\n                f\"({exc!r}); falling back to pure Python builder.\"\n            )\n            entity = _build_entity_from_raw_python(raw)\n    else:\n        entity = _build_entity_from_raw_python(raw)\n\n    # Normalize shape so tests (and downstream code) see consistent fields.\n    return _normalize_entity_shape(entity, raw)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.exchange","title":"exchange","text":""},{"location":"en/api/#civic_interconnect.cep.exchange.api","title":"api","text":"<p>CEP Exchange builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Exchange records from normalized adapter payloads.</p> <p>Adapters should call build_exchange_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p>"},{"location":"en/api/#civic_interconnect.cep.localization","title":"localization","text":"<p>Apply localization configurations for different jurisdictions.</p>"},{"location":"en/api/#civic_interconnect.cep.localization.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for jurisdiction-specific localization settings.</p> <p>jurisdiction : str     The jurisdiction code (e.g., 'BASE', 'US', 'US-MN'). parent : str | None     The parent jurisdiction from which this config inherits. version : str     The version of this localization configuration. updated_timestamp : str     ISO timestamp of when this configuration was last updated. config_hash : str | None     Optional hash of the configuration for versioning. abbreviations : dict[str, str]     Mapping of abbreviations to their expanded forms. agency_names : dict[str, str]     Mapping of agency name aliases to canonical names. entity_types : dict[str, str]     Mapping of entity type aliases to canonical types. rules : list[dict[str, Any]]     List of jurisdiction-specific rules. stop_words : list[str]     List of words to ignore during normalization.</p> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for jurisdiction-specific localization settings.\n\n    Attributes:\n    jurisdiction : str\n        The jurisdiction code (e.g., 'BASE', 'US', 'US-MN').\n    parent : str | None\n        The parent jurisdiction from which this config inherits.\n    version : str\n        The version of this localization configuration.\n    updated_timestamp : str\n        ISO timestamp of when this configuration was last updated.\n    config_hash : str | None\n        Optional hash of the configuration for versioning.\n    abbreviations : dict[str, str]\n        Mapping of abbreviations to their expanded forms.\n    agency_names : dict[str, str]\n        Mapping of agency name aliases to canonical names.\n    entity_types : dict[str, str]\n        Mapping of entity type aliases to canonical types.\n    rules : list[dict[str, Any]]\n        List of jurisdiction-specific rules.\n    stop_words : list[str]\n        List of words to ignore during normalization.\n    \"\"\"\n\n    jurisdiction: str\n    parent: str | None\n    version: str\n    updated_timestamp: str\n    config_hash: str | None\n    abbreviations: dict[str, str]\n    agency_names: dict[str, str]\n    entity_types: dict[str, str]\n    rules: list[dict[str, Any]]\n    stop_words: list[str]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.localization.load_localization","title":"load_localization","text":"<pre><code>load_localization(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Public entry point: get a cascaded LocalizationConfig, with caching.</p> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>def load_localization(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Public entry point: get a cascaded LocalizationConfig, with caching.\"\"\"\n    if jurisdiction in _LOCALIZATION_CACHE:\n        return _LOCALIZATION_CACHE[jurisdiction]\n    cfg = _build_localization_config(jurisdiction)\n    _LOCALIZATION_CACHE[jurisdiction] = cfg\n    return cfg\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.localization.normalize_name","title":"normalize_name","text":"<pre><code>normalize_name(\n    raw_name: str, config: LocalizationConfig\n) -&gt; str\n</code></pre> <p>Very simple first-pass normalizer.</p> <ul> <li>lowercases</li> <li>strips leading/trailing whitespace</li> <li>replaces abbreviations as whole-word tokens when possible</li> <li>trims stop words</li> <li>applies simple agency_names mapping if exact match</li> </ul> Source code in <code>src/python/src/civic_interconnect/cep/localization.py</code> <pre><code>def normalize_name(raw_name: str, config: LocalizationConfig) -&gt; str:\n    \"\"\"Very simple first-pass normalizer.\n\n    - lowercases\n    - strips leading/trailing whitespace\n    - replaces abbreviations as whole-word tokens when possible\n    - trims stop words\n    - applies simple agency_names mapping if exact match\n    \"\"\"\n    if not raw_name:\n        return \"\"\n\n    text = raw_name.strip().lower()\n\n    # Exact agency name override first (common for \"nyc\", \"mn\", etc.).\n    if text in config.agency_names:\n        return config.agency_names[text]\n\n    # Tokenize on whitespace.\n    tokens = text.split()\n\n    # Expand abbreviations and drop stop words.\n    expanded_tokens: list[str] = []\n    for tok in tokens:\n        if tok in config.stop_words:\n            continue\n        if tok in config.abbreviations:\n            expanded_tokens.extend(config.abbreviations[tok].split())\n        else:\n            expanded_tokens.append(tok)\n\n    normalized = \" \".join(expanded_tokens)\n\n    # Apply agency_names again in case expansion matched a known alias.\n    if normalized in config.agency_names:\n        return config.agency_names[normalized]\n\n    return normalized\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.relationship","title":"relationship","text":""},{"location":"en/api/#civic_interconnect.cep.relationship.api","title":"api","text":"<p>CEP Relationship builder facade.</p> <p>This module defines the Python-facing API for constructing CEP Relationship records from normalized adapter payloads.</p> <p>Adapters should call build_relationship_from_raw() instead of constructing CEP envelopes directly.</p> <p>This module uses the Rust core (via the cep_py extension) when available, and falls back to a pure Python implementation otherwise.</p>"},{"location":"en/api/#civic_interconnect.cep.snfei","title":"snfei","text":""},{"location":"en/api/#civic_interconnect.cep.snfei.generate_snfei","title":"generate_snfei","text":"<pre><code>generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; str\n</code></pre> <p>Return SNFEI as a 64-char hex string via the Rust core.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/__init__.py</code> <pre><code>def generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; str:\n    \"\"\"Return SNFEI as a 64-char hex string via the Rust core.\"\"\"\n    return _core.generate_snfei(\n        legal_name,\n        country_code,\n        address,\n        registration_date,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.generate_snfei_detailed","title":"generate_snfei_detailed","text":"<pre><code>generate_snfei_detailed(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Return a structured dict with SNFEI plus canonical input and metadata.</p> <p><code>lei</code> and <code>sam_uei</code> are accepted for future compatibility but are not yet forwarded into the Rust implementation.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/__init__.py</code> <pre><code>def generate_snfei_detailed(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Return a structured dict with SNFEI plus canonical input and metadata.\n\n    `lei` and `sam_uei` are accepted for future compatibility but are not yet\n    forwarded into the Rust implementation.\n    \"\"\"\n    raw = _core.generate_snfei_detailed(\n        legal_name,\n        country_code,\n        address,\n        registration_date,\n    )\n\n    # Rust FFI currently returns a JSON string; normalize to dict.\n    if isinstance(raw, str):\n        return json.loads(raw)\n\n    # If we ever change the Rust side to return a mapping directly,\n    # this still works.\n    return raw\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(value: str) -&gt; str\n</code></pre> <p>Normalize an address using the Rust core.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/__init__.py</code> <pre><code>def normalize_address(value: str) -&gt; str:\n    \"\"\"Normalize an address using the Rust core.\"\"\"\n    return _core.normalize_address_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(value: str) -&gt; str\n</code></pre> <p>Normalize a legal name using the Rust core.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/__init__.py</code> <pre><code>def normalize_legal_name(value: str) -&gt; str:\n    \"\"\"Normalize a legal name using the Rust core.\"\"\"\n    return _core.normalize_legal_name_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(value: str) -&gt; str | None\n</code></pre> <p>Normalize a registration/formation date, or return None.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/__init__.py</code> <pre><code>def normalize_registration_date(value: str) -&gt; str | None:\n    \"\"\"Normalize a registration/formation date, or return None.\"\"\"\n    return _core.normalize_registration_date_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization","title":"localization","text":"<p>Localization Functor: Jurisdiction-Specific Transformations.</p> <p>This module loads and applies jurisdiction-specific normalization rules BEFORE the universal Normalizing Functor is applied.</p> <p>The Localization Functor L transforms raw local data into a canonical intermediate form that the universal normalizer can process:</p> <pre><code>L: RawLocal \u2192 IntermediateCanonical\nN: IntermediateCanonical \u2192 FinalCanonical\n\nSNFEI = Hash(N(L(raw_data)))\n</code></pre> Directory Structure <p>/localization/     base.yaml           # Default/fallback rules     us/         base.yaml       # US-wide rules         ca.yaml         # California-specific         ny.yaml         # New York-specific     ca/         base.yaml       # Canada-wide rules         on.yaml         # Ontario-specific         qc.yaml         # Quebec-specific</p> <p>File: src/python/src/civic_interconnect/cep/snfei/localization.py</p>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for a specific jurisdiction.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for a specific jurisdiction.\"\"\"\n\n    jurisdiction: str  # e.g., \"us/ca\", \"ca/on\"\n    parent: str | None  # Parent jurisdiction for inheritance\n\n    # Transformation maps\n    abbreviations: dict[str, str] = field(default_factory=dict)\n    agency_names: dict[str, str] = field(default_factory=dict)\n    entity_types: dict[str, str] = field(default_factory=dict)\n\n    # Additional rules\n    rules: list[LocalizationRule] = field(default_factory=list)\n\n    # Stop words specific to this jurisdiction\n    stop_words: set[str] = field(default_factory=set)\n\n    def apply_to_name(self, name: str) -&gt; str:\n        \"\"\"Apply jurisdiction-specific transformations to a name.\n\n        Order of application:\n        1. Agency name expansions\n        2. Abbreviation expansions\n        3. Entity type standardization\n        4. Custom rules\n        \"\"\"\n        result = name.lower()\n\n        # 1. Agency names (exact match, case-insensitive)\n        for abbrev, full in self.agency_names.items():\n            # Word boundary matching\n            import re\n\n            pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n            result = re.sub(pattern, full.lower(), result)\n\n        # 2. Abbreviations\n        tokens = result.split()\n        expanded = []\n        for token in tokens:\n            if token in self.abbreviations:\n                expanded.append(self.abbreviations[token].lower())\n            else:\n                expanded.append(token)\n        result = \" \".join(expanded)\n\n        # 3. Entity types\n        for local_type, canonical_type in self.entity_types.items():\n            import re\n\n            pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n            result = re.sub(pattern, canonical_type.lower(), result)\n\n        # 4. Custom rules\n        for rule in self.rules:\n            if rule.is_regex:\n                import re\n\n                result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n            else:\n                result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n        return result\n</code></pre> apply_to_name \u00b6 <pre><code>apply_to_name(name: str) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific transformations to a name.</p> <p>Order of application: 1. Agency name expansions 2. Abbreviation expansions 3. Entity type standardization 4. Custom rules</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_to_name(self, name: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific transformations to a name.\n\n    Order of application:\n    1. Agency name expansions\n    2. Abbreviation expansions\n    3. Entity type standardization\n    4. Custom rules\n    \"\"\"\n    result = name.lower()\n\n    # 1. Agency names (exact match, case-insensitive)\n    for abbrev, full in self.agency_names.items():\n        # Word boundary matching\n        import re\n\n        pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n        result = re.sub(pattern, full.lower(), result)\n\n    # 2. Abbreviations\n    tokens = result.split()\n    expanded = []\n    for token in tokens:\n        if token in self.abbreviations:\n            expanded.append(self.abbreviations[token].lower())\n        else:\n            expanded.append(token)\n    result = \" \".join(expanded)\n\n    # 3. Entity types\n    for local_type, canonical_type in self.entity_types.items():\n        import re\n\n        pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n        result = re.sub(pattern, canonical_type.lower(), result)\n\n    # 4. Custom rules\n    for rule in self.rules:\n        if rule.is_regex:\n            import re\n\n            result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n        else:\n            result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n    return result\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationRegistry","title":"LocalizationRegistry","text":"<p>Registry for loading and caching localization configurations.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>class LocalizationRegistry:\n    \"\"\"Registry for loading and caching localization configurations.\"\"\"\n\n    def __init__(self, config_dir: Path | None = None):\n        \"\"\"Initialize the registry.\n\n        Args:\n            config_dir: Optional path to localization YAML files.\n                       If None, only built-in configs are available.\n        \"\"\"\n        self.config_dir = config_dir\n        self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n\n    def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n        \"\"\"Get localization config for a jurisdiction.\n\n        Falls back through parent jurisdictions if specific config not found.\n        Merges child config with parent config for inheritance.\n\n        Args:\n            jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                         Case-insensitive - will be normalized to lowercase.\n\n        Returns:\n            LocalizationConfig for the jurisdiction (merged with parent).\n        \"\"\"\n        # Normalize to lowercase\n        jurisdiction = jurisdiction.lower()\n\n        # Check if we have a merged config cached\n        cache_key = f\"_merged_{jurisdiction}\"\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Get the base config for this jurisdiction\n        if jurisdiction in self._cache:\n            config = self._cache[jurisdiction]\n        elif self.config_dir:\n            config = self._load_yaml(jurisdiction)\n            if config:\n                self._cache[jurisdiction] = config\n            else:\n                config = None\n        else:\n            config = None\n\n        # If no config found, fall back to parent\n        if config is None:\n            if \"/\" in jurisdiction:\n                parent = jurisdiction.rsplit(\"/\", 1)[0]\n                return self.get_config(parent)\n            # Return empty config as last resort\n            return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n        # If config has a parent, merge with parent config\n        if config.parent:\n            parent_config = self.get_config(config.parent)\n            merged = self.merge_configs(config, parent_config)\n            self._cache[cache_key] = merged\n            return merged\n\n        return config\n\n    def _load_yaml(self, jurisdiction: str) -&gt; LocalizationConfig | None:\n        \"\"\"Load config from YAML file.\n\n        Expected paths:\n            - {config_dir}/{country}/base.yaml for country-level (e.g., US, CA)\n            - {config_dir}/{country}/{region}.yaml for region-level (e.g., us/ca, ca/on)\n        \"\"\"\n        if not self.config_dir:\n            return None\n\n        # Determine the YAML file path\n        if \"/\" in jurisdiction:\n            # Region-level: us/ca -&gt; us/ca.yaml\n            parts = jurisdiction.split(\"/\")\n            yaml_path = self.config_dir / parts[0] / f\"{parts[1]}.yaml\"\n        else:\n            # Country-level: US -&gt; us/base.yaml\n            yaml_path = self.config_dir / jurisdiction / \"base.yaml\"\n\n        if not yaml_path.exists():\n            return None\n\n        try:\n            with yaml_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n\n            if not data:\n                return None\n\n            # Parse rules if present\n            rules = []\n            for rule_data in data.get(\"rules\", []):\n                rules.append(\n                    LocalizationRule(\n                        pattern=rule_data.get(\"pattern\", \"\"),\n                        replacement=rule_data.get(\"replacement\", \"\"),\n                        is_regex=rule_data.get(\"is_regex\", False),\n                        context=rule_data.get(\"context\"),\n                    )\n                )\n\n            return LocalizationConfig(\n                jurisdiction=data.get(\"jurisdiction\", jurisdiction),\n                parent=data.get(\"parent\"),\n                abbreviations=data.get(\"abbreviations\", {}),\n                agency_names=data.get(\"agency_names\", {}),\n                entity_types=data.get(\"entity_types\", {}),\n                rules=rules,\n                stop_words=set(data.get(\"stop_words\", [])),\n            )\n        except Exception as e:\n            # Log error but don't crash\n            print(f\"Warning: Failed to load localization YAML {yaml_path}: {e}\")\n            return None\n\n    def merge_configs(\n        self, child: LocalizationConfig, parent: LocalizationConfig\n    ) -&gt; LocalizationConfig:\n        \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n        merged_abbrevs = dict(parent.abbreviations)\n        merged_abbrevs.update(child.abbreviations)\n\n        merged_agencies = dict(parent.agency_names)\n        merged_agencies.update(child.agency_names)\n\n        merged_types = dict(parent.entity_types)\n        merged_types.update(child.entity_types)\n\n        return LocalizationConfig(\n            jurisdiction=child.jurisdiction,\n            parent=parent.jurisdiction,\n            abbreviations=merged_abbrevs,\n            agency_names=merged_agencies,\n            entity_types=merged_types,\n            rules=parent.rules + child.rules,\n            stop_words=parent.stop_words | child.stop_words,\n        )\n</code></pre> __init__ \u00b6 <pre><code>__init__(config_dir: Path | None = None)\n</code></pre> <p>Initialize the registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>Path | None</code> <p>Optional path to localization YAML files.        If None, only built-in configs are available.</p> <code>None</code> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def __init__(self, config_dir: Path | None = None):\n    \"\"\"Initialize the registry.\n\n    Args:\n        config_dir: Optional path to localization YAML files.\n                   If None, only built-in configs are available.\n    \"\"\"\n    self.config_dir = config_dir\n    self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n</code></pre> get_config \u00b6 <pre><code>get_config(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction.</p> <p>Falls back through parent jurisdictions if specific config not found. Merges child config with parent config for inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\", \"ca/on\").          Case-insensitive - will be normalized to lowercase.</p> required <p>Returns:</p> Type Description <code>LocalizationConfig</code> <p>LocalizationConfig for the jurisdiction (merged with parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction.\n\n    Falls back through parent jurisdictions if specific config not found.\n    Merges child config with parent config for inheritance.\n\n    Args:\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                     Case-insensitive - will be normalized to lowercase.\n\n    Returns:\n        LocalizationConfig for the jurisdiction (merged with parent).\n    \"\"\"\n    # Normalize to lowercase\n    jurisdiction = jurisdiction.lower()\n\n    # Check if we have a merged config cached\n    cache_key = f\"_merged_{jurisdiction}\"\n    if cache_key in self._cache:\n        return self._cache[cache_key]\n\n    # Get the base config for this jurisdiction\n    if jurisdiction in self._cache:\n        config = self._cache[jurisdiction]\n    elif self.config_dir:\n        config = self._load_yaml(jurisdiction)\n        if config:\n            self._cache[jurisdiction] = config\n        else:\n            config = None\n    else:\n        config = None\n\n    # If no config found, fall back to parent\n    if config is None:\n        if \"/\" in jurisdiction:\n            parent = jurisdiction.rsplit(\"/\", 1)[0]\n            return self.get_config(parent)\n        # Return empty config as last resort\n        return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n    # If config has a parent, merge with parent config\n    if config.parent:\n        parent_config = self.get_config(config.parent)\n        merged = self.merge_configs(config, parent_config)\n        self._cache[cache_key] = merged\n        return merged\n\n    return config\n</code></pre> merge_configs \u00b6 <pre><code>merge_configs(\n    child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig\n</code></pre> <p>Merge child config with parent (child overrides parent).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def merge_configs(\n    self, child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig:\n    \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n    merged_abbrevs = dict(parent.abbreviations)\n    merged_abbrevs.update(child.abbreviations)\n\n    merged_agencies = dict(parent.agency_names)\n    merged_agencies.update(child.agency_names)\n\n    merged_types = dict(parent.entity_types)\n    merged_types.update(child.entity_types)\n\n    return LocalizationConfig(\n        jurisdiction=child.jurisdiction,\n        parent=parent.jurisdiction,\n        abbreviations=merged_abbrevs,\n        agency_names=merged_agencies,\n        entity_types=merged_types,\n        rules=parent.rules + child.rules,\n        stop_words=parent.stop_words | child.stop_words,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.LocalizationRule","title":"LocalizationRule  <code>dataclass</code>","text":"<p>A single localization transformation rule.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationRule:\n    \"\"\"A single localization transformation rule.\"\"\"\n\n    pattern: str  # Text to match (case-insensitive)\n    replacement: str  # Replacement text\n    is_regex: bool = False  # Whether pattern is a regex\n    context: str | None = None  # Optional context (e.g., \"agency\", \"school\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.apply_localization","title":"apply_localization","text":"<pre><code>apply_localization(name: str, jurisdiction: str) -&gt; str\n</code></pre> <p>Apply localization transforms to a name.</p> <p>This is the Localization Functor L.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw entity name.</p> required <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name with jurisdiction-specific transforms applied.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def apply_localization(name: str, jurisdiction: str) -&gt; str:\n    \"\"\"Apply localization transforms to a name.\n\n    This is the Localization Functor L.\n\n    Args:\n        name: Raw entity name.\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\").\n\n    Returns:\n        Name with jurisdiction-specific transforms applied.\n    \"\"\"\n    config = get_localization_config(jurisdiction)\n    return config.apply_to_name(name)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.localization.get_localization_config","title":"get_localization_config","text":"<pre><code>get_localization_config(\n    jurisdiction: str,\n) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction (convenience function).</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/localization.py</code> <pre><code>def get_localization_config(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction (convenience function).\"\"\"\n    return _registry.get_config(jurisdiction)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer","title":"normalizer","text":"<p>Thin normalization wrappers around the Rust core.</p> <p>All actual normalization logic lives in <code>cep_core::common::normalizer</code> and is exposed to Python via the <code>cep_py</code> extension module.</p> <p>This module exists only to provide a stable Python surface: - normalize_legal_name - normalize_address - normalize_registration_date - CanonicalInput - build_canonical_input</p> <p>There is no business logic here; everything delegates to Rust.</p>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.CanonicalInput","title":"CanonicalInput","text":"<p>               Bases: <code>TypedDict</code></p> <p>Canonical snapshot returned by the Rust SNFEI pipeline.</p> <p>This mirrors the shape of the <code>canonical</code> block in SnfeiResult as serialized by serde_json:</p> <pre><code>{\n    \"legalNameNormalized\": str,\n    \"countryCode\": str,\n    \"addressNormalized\": str | None,\n    \"registrationDate\": str | None,\n    ...\n}\n</code></pre> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>class CanonicalInput(TypedDict, total=False):\n    \"\"\"Canonical snapshot returned by the Rust SNFEI pipeline.\n\n    This mirrors the shape of the `canonical` block in SnfeiResult as\n    serialized by serde_json:\n\n        {\n            \"legalNameNormalized\": str,\n            \"countryCode\": str,\n            \"addressNormalized\": str | None,\n            \"registrationDate\": str | None,\n            ...\n        }\n    \"\"\"\n\n    legalNameNormalized: str\n    countryCode: str\n    addressNormalized: str | None\n    registrationDate: str | None\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical snapshot via the Rust SNFEI pipeline.</p> <p>For now, we reuse the Rust SNFEI pipeline and extract its <code>canonical</code> section. This guarantees that:</p> <ul> <li>Canonicalization happens exactly once (in Rust).</li> <li>The canonical shape matches what SNFEI actually uses.</li> </ul> <p>If you only care about normalization (and not the hash), this is still safe; it just does a bit more work under the hood.</p> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput dict with the normalized fields.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical snapshot via the Rust SNFEI pipeline.\n\n    For now, we reuse the Rust SNFEI pipeline and extract its `canonical`\n    section. This guarantees that:\n\n    - Canonicalization happens exactly once (in Rust).\n    - The canonical shape matches what SNFEI actually uses.\n\n    If you only care about normalization (and not the hash), this is still\n    safe; it just does a bit more work under the hood.\n\n    Returns:\n        CanonicalInput dict with the normalized fields.\n    \"\"\"\n    # Import here to avoid cycles: civic_interconnect.cep.snfei.__init__\n    from civic_interconnect.cep.snfei import generate_snfei_detailed\n\n    detailed = generate_snfei_detailed(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=address,\n        registration_date=registration_date,\n        lei=None,\n        sam_uei=None,\n    )\n    # Trust Rust\u2019s canonical structure; we only type it.\n    return detailed[\"canonical\"]  # type: ignore[return-value]\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(value: str) -&gt; str\n</code></pre> <p>Normalize an address using the Rust core.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_address(value: str) -&gt; str:\n    \"\"\"Normalize an address using the Rust core.\"\"\"\n    return _core.normalize_address_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(value: str) -&gt; str\n</code></pre> <p>Normalize a legal name using the Rust core.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_legal_name(value: str) -&gt; str:\n    \"\"\"Normalize a legal name using the Rust core.\"\"\"\n    return _core.normalize_legal_name_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.snfei.normalizer.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(value: str) -&gt; str | None\n</code></pre> <p>Normalize a registration/formation date using the Rust core.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>ISO date string (e.g. \"2020-01-31\") or None if the date</p> <code>str | None</code> <p>cannot be normalized.</p> Source code in <code>src/python/src/civic_interconnect/cep/snfei/normalizer.py</code> <pre><code>def normalize_registration_date(value: str) -&gt; str | None:\n    \"\"\"Normalize a registration/formation date using the Rust core.\n\n    Returns:\n        ISO date string (e.g. \"2020-01-31\") or None if the date\n        cannot be normalized.\n    \"\"\"\n    return _core.normalize_registration_date_py(value)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cep.vocab","title":"vocab","text":"<p>Vocabulary module for civic-interconnect CEP.</p> <p>This module provides vocabulary-related functionality.</p>"},{"location":"en/api/#civic_interconnect.cli","title":"cli","text":""},{"location":"en/api/#civic_interconnect.cli.cli","title":"cli","text":"<p>Command-line interface for the Civic Exchange Protocol.</p> <p>This module provides CLI commands for: - snfei: Generate an SNFEI for an entity name and country - version: Display the package version - validate-json: Validate JSON files against CEP schemas - codegen-rust: Generate Rust types from CEP JSON Schemas - generate-example: Generate example data files from raw sources.</p> <p>For example:</p> <p>uv run cx codegen-rust uv run cx codegen-python-constants uv run cx generate-example examples/entity uv run cx generate-example examples/entity --overwrite</p>"},{"location":"en/api/#civic_interconnect.cli.cli.codegen_python_constants","title":"codegen_python_constants","text":"<pre><code>codegen_python_constants(\n    entity_schema: Path | None = None,\n    entity_out: Path | None = None,\n) -&gt; None\n</code></pre> <p>Generate Python field-name constants from CEP JSON Schemas.</p> <p>Currently generates:</p> <ul> <li>civic_interconnect.cep.constants.entity_fields</li> </ul> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command(\"codegen-python-constants\")\ndef codegen_python_constants(\n    entity_schema: Path | None = None,\n    entity_out: Path | None = None,\n) -&gt; None:\n    \"\"\"Generate Python field-name constants from CEP JSON Schemas.\n\n    Currently generates:\n\n    - civic_interconnect.cep.constants.entity_fields\n    \"\"\"\n    if entity_schema is None:\n        entity_schema = DEFAULT_ENTITY_SCHEMA_FOR_CONSTANTS\n    if entity_out is None:\n        entity_out = DEFAULT_ENTITY_CONSTANTS_OUT\n\n    write_entity_constants(entity_schema, entity_out)\n    typer.echo(f\"Wrote {entity_out}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.codegen_rust","title":"codegen_rust","text":"<pre><code>codegen_rust(\n    entity_schema: Path | None = None,\n    relationship_schema: Path | None = None,\n    exchange_schema: Path | None = None,\n    entity_out: Path | None = None,\n    relationship_out: Path | None = None,\n    exchange_out: Path | None = None,\n) -&gt; None\n</code></pre> <p>Generate Rust types from CEP JSON Schemas into generated.rs files.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command(\"codegen-rust\")\ndef codegen_rust(\n    entity_schema: Path | None = None,\n    relationship_schema: Path | None = None,\n    exchange_schema: Path | None = None,\n    entity_out: Path | None = None,\n    relationship_out: Path | None = None,\n    exchange_out: Path | None = None,\n) -&gt; None:\n    \"\"\"Generate Rust types from CEP JSON Schemas into generated.rs files.\"\"\"\n    if entity_schema is None:\n        entity_schema = DEFAULT_ENTITY_SCHEMA\n    if relationship_schema is None:\n        relationship_schema = DEFAULT_RELATIONSHIP_SCHEMA\n    if exchange_schema is None:\n        exchange_schema = DEFAULT_EXCHANGE_SCHEMA\n    if entity_out is None:\n        entity_out = DEFAULT_ENTITY_OUT\n    if relationship_out is None:\n        relationship_out = DEFAULT_RELATIONSHIP_OUT\n    if exchange_out is None:\n        exchange_out = DEFAULT_EXCHANGE_OUT\n\n    # Adjust struct names here as needed\n    write_generated_rust(entity_schema, \"EntityRecord\", entity_out)\n    write_generated_rust(relationship_schema, \"RelationshipRecord\", relationship_out)\n    write_generated_rust(exchange_schema, \"ExchangeRecord\", exchange_out)\n\n    typer.echo(f\"Wrote {entity_out}\")\n    typer.echo(f\"Wrote {relationship_out}\")\n    typer.echo(f\"Wrote {exchange_out}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.generate_example","title":"generate_example","text":"<pre><code>generate_example(\n    path: Annotated[\n        Path,\n        Argument(\n            help='Path to an example slice or a directory containing slices (e.g. examples/entity or examples/entity/municipality/us_il_01)'\n        ),\n    ],\n    overwrite: Annotated[\n        bool,\n        Option(\n            --overwrite,\n            help='Overwrite existing 02/03/04 files instead of skipping them.',\n        ),\n    ] = False,\n) -&gt; None\n</code></pre> <p>Generate 02_normalized, 03_canonical, and 04_entity_record JSON files.</p> <p>This walks any examples under <code>path</code> that contain 01_raw_source.json and runs the full pipeline:</p> <pre><code>raw -&gt; normalized -&gt; canonical -&gt; EntityRecord\n</code></pre> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command(\"generate-example\")\ndef generate_example(\n    path: Annotated[\n        Path,\n        typer.Argument(\n            help=(\n                \"Path to an example slice or a directory containing slices \"\n                \"(e.g. examples/entity or examples/entity/municipality/us_il_01)\"\n            ),\n        ),\n    ],\n    overwrite: Annotated[\n        bool,\n        typer.Option(\n            \"--overwrite\",\n            help=\"Overwrite existing 02/03/04 files instead of skipping them.\",\n        ),\n    ] = False,\n) -&gt; None:\n    \"\"\"Generate 02_normalized, 03_canonical, and 04_entity_record JSON files.\n\n    This walks any examples under `path` that contain 01_raw_source.json and\n    runs the full pipeline:\n\n        raw -&gt; normalized -&gt; canonical -&gt; EntityRecord\n    \"\"\"\n    slices = find_example_slices(path)\n    if not slices:\n        typer.echo(f\"No example slices found under {path}\")\n        raise typer.Exit(code=1)\n\n    typer.echo(f\"Found {len(slices)} example slice(s) under {path}\")\n    for slice_dir in slices:\n        typer.echo(f\"\\n[example] {slice_dir}\")\n\n        f02 = slice_dir / \"02_normalized.json\"\n        f03 = slice_dir / \"03_canonical.json\"\n        f04 = slice_dir / \"04_entity_record.json\"\n\n        if not overwrite and f02.exists() and f03.exists() and f04.exists():\n            typer.echo(\"  - 02/03/04 already exist, skipping (use --overwrite to regenerate)\")\n            continue\n\n        # Load raw\n        try:\n            raw = load_raw_source(slice_dir)\n        except (FileNotFoundError, ValueError) as exc:\n            typer.echo(f\"  ! {exc}, skipping slice\")\n            continue\n\n        # Map messy raw shapes into the normalized fields we need\n        try:\n            inputs = extract_example_entity_inputs(raw, slice_dir)\n        except KeyError as exc:\n            typer.echo(f\"  ! missing required raw field(s): {exc!r}, skipping slice\")\n            continue\n\n        jurisdiction_iso = inputs.jurisdiction_iso\n        legal_name = inputs.legal_name\n        country_code = inputs.country_code\n        entity_type = inputs.entity_type\n        address = inputs.address\n        registration_date = inputs.registration_date\n\n        # 1) Canonical input (normalizing functor) + SNFEI\n        snfei_result = generate_snfei_detailed(\n            legal_name=legal_name,\n            country_code=country_code,\n            address=address,\n            registration_date=registration_date,\n            lei=None,\n            sam_uei=None,\n        )\n        # Rust returns:\n        # {\n        #   \"snfei\": {\"value\": \"...\"},\n        #   \"canonical\": {\n        #       \"legalNameNormalized\": \"...\",\n        #       \"addressNormalized\": \"...\",\n        #       \"countryCode\": \"...\",\n        #       \"registrationDate\": \"...\" | null\n        #   },\n        #   ...\n        # }\n\n        snfei_value = snfei_result[\"snfei\"][\"value\"]\n        canonical_raw = snfei_result.get(\"canonical\", {})\n        # Be tolerant to either camelCase or snake_case field names\n        legal_name_normalized = (\n            canonical_raw.get(\"legalNameNormalized\")\n            or canonical_raw.get(\"legal_name_normalized\")\n            or \"\"\n        )\n        address_normalized = canonical_raw.get(\"addressNormalized\") or canonical_raw.get(\n            \"address_normalized\"\n        )\n        country_code_canonical = (\n            canonical_raw.get(\"countryCode\") or canonical_raw.get(\"country_code\") or country_code\n        )\n        registration_date_canonical = canonical_raw.get(\"registrationDate\") or canonical_raw.get(\n            \"registration_date\"\n        )\n\n        # 2) NormalizedEntityInput (02_normalized.json)\n        normalized: dict[str, Any] = {\n            \"jurisdictionIso\": jurisdiction_iso,\n            \"legalName\": legal_name,\n            \"legalNameNormalized\": legal_name_normalized,\n            \"snfei\": snfei_value,\n            \"entityType\": entity_type,\n        }\n        _write_json(f02, normalized)\n        typer.echo(f\"  - wrote {f02.name}\")\n\n        # 3) Canonical snapshot (03_canonical.json)\n        canonical_json: dict[str, Any] = {\n            \"legalNameNormalized\": legal_name_normalized,\n            \"addressNormalized\": address_normalized,\n            \"countryCode\": country_code_canonical,\n            \"registrationDate\": registration_date_canonical,\n        }\n        _write_json(f03, canonical_json)\n        typer.echo(f\"  - wrote {f03.name}\")\n\n        # 4) Final EntityRecord via builder (04_entity_record.json)\n        entity_record = build_entity_from_raw(normalized)\n        _write_json(f04, entity_record)\n        typer.echo(f\"  - wrote {f04.name}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.snfei","title":"snfei","text":"<pre><code>snfei(\n    legal_name: str = typer.Argument(\n        ..., help='Raw legal name'\n    ),\n    country_code: str = typer.Option(\n        'US',\n        '--country-code',\n        '-c',\n        help='ISO country code',\n    ),\n) -&gt; None\n</code></pre> <p>Generate an SNFEI for an entity name and country.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef snfei(\n    legal_name: str = typer.Argument(..., help=\"Raw legal name\"),\n    country_code: str = typer.Option(\"US\", \"--country-code\", \"-c\", help=\"ISO country code\"),\n) -&gt; None:\n    \"\"\"Generate an SNFEI for an entity name and country.\"\"\"\n    result = generate_snfei_detailed(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=None,\n        registration_date=None,\n        lei=None,\n        sam_uei=None,\n    )\n    snfei_value = result[\"snfei\"]\n    tier = result[\"tier\"]\n    confidence = result[\"confidenceScore\"]\n\n    typer.echo(f\"SNFEI: {snfei_value}\")\n    typer.echo(f\"Tier: {tier}, confidence: {confidence}\")\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.validate_json","title":"validate_json","text":"<pre><code>validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        '--schema',\n        '-s',\n        help='Schema name (for example: entity, exchange, relationship, snfei).',\n    ),\n    recursive: bool = typer.Option(\n        False,\n        '--recursive',\n        '-r',\n        help='Recurse into subdirectories when validating a directory.',\n    ),\n) -&gt; None\n</code></pre> <p>Validate JSON file(s) against a CEP JSON Schema.</p> <p>Behavior: - If PATH is a file, validates that single JSON file. - If PATH is a directory, validates all *.json files within it.   Use --recursive to walk subdirectories.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        \"--schema\",\n        \"-s\",\n        help=\"Schema name (for example: entity, exchange, relationship, snfei).\",\n    ),\n    recursive: bool = typer.Option(\n        False,\n        \"--recursive\",\n        \"-r\",\n        help=\"Recurse into subdirectories when validating a directory.\",\n    ),\n) -&gt; None:\n    \"\"\"Validate JSON file(s) against a CEP JSON Schema.\n\n    Behavior:\n    - If PATH is a file, validates that single JSON file.\n    - If PATH is a directory, validates all *.json files within it.\n      Use --recursive to walk subdirectories.\n    \"\"\"\n    if path is None:\n        typer.echo(\"Error: Path argument is required.\")\n        raise typer.Exit(code=1)\n\n    summary: ValidationSummary = validate_json_path(\n        path=path,\n        schema_name=schema,\n        recursive=recursive,\n    )\n\n    if not summary.results:\n        typer.echo(\"No JSON files found to validate.\")\n        raise typer.Exit(code=1)\n\n    errors_found = False\n\n    for result in summary.results:\n        if result.ok:\n            typer.echo(f\"[OK] {result.path}\")\n        else:\n            errors_found = True\n            typer.echo(f\"[ERROR] {result.path}\")\n            for err in result.errors:\n                typer.echo(f\"  - {err}\")\n\n    if errors_found:\n        typer.echo(\"Validation completed with errors.\")\n        raise typer.Exit(code=1)\n\n    typer.echo(\"All files validated successfully.\")\n    raise typer.Exit(code=0)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.cli.version_cmd","title":"version_cmd","text":"<pre><code>version_cmd() -&gt; None\n</code></pre> <p>Show package version.</p> Source code in <code>src/python/src/civic_interconnect/cli/cli.py</code> <pre><code>@app.command()\ndef version_cmd() -&gt; None:\n    \"\"\"Show package version.\"\"\"\n    try:\n        v = version(\"civic-interconnect\")\n    except PackageNotFoundError:\n        v = \"0.0.0\"\n    typer.echo(v)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer","title":"normalizer","text":"<p>CEP Core Linker: The Normalizing Functor.</p> <p>This module implements the universal normalization pipeline that transforms entity attributes into hash-ready canonical form for SNFEI generation.</p> <p>The architecture follows the Category Theory foundation: - Localization Functor: Jurisdiction-specific transforms (YAML-driven) - Normalizing Functor: Universal normalization steps (this module) - SNFEI Hash: Final SHA-256 computation</p> Directory Structure <p>/snfei/     normalizer.py      # Universal normalization (this file)     generator.py       # SNFEI hash generation     localization.py    # Localization functor implementation /localization/     us/               # US state-specific rules         ca.yaml         ny.yaml     ca/               # Canada province-specific rules         on.yaml         qc.yaml     base.yaml         # Fallback rules</p> Mathematical Foundation <p>The Normalizing Functor N transforms the category of Raw Entity Data into the category of Canonical Entity Data:</p> <p>N: RawEntity \u2192 CanonicalEntity</p> <p>Where N preserves identity (same entity always maps to same canonical form) and composition (N(L(x)) = N \u2218 L(x) where L is the localization functor).</p>"},{"location":"en/api/#civic_interconnect.cli.normalizer.CanonicalInput","title":"CanonicalInput  <code>dataclass</code>","text":"<p>Normalized input for SNFEI hashing.</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>@dataclass\nclass CanonicalInput:\n    \"\"\"Normalized input for SNFEI hashing.\"\"\"\n\n    legal_name_normalized: str\n    address_normalized: str | None\n    country_code: str\n    registration_date: str | None\n\n    def to_hash_string(self) -&gt; str:\n        \"\"\"Generate the concatenated string for hashing.\n\n        Format:\n            legal_name_normalized|address_normalized|country_code|registration_date\n\n        Empty/None fields are included as empty strings to maintain\n        consistent field positions.\n        \"\"\"\n        parts = [\n            self.legal_name_normalized,\n            self.address_normalized or \"\",\n            self.country_code,\n            self.registration_date or \"\",\n        ]\n        return \"|\".join(parts)\n\n    def to_hash_string_v2(self) -&gt; str:\n        \"\"\"Alternative format that omits empty fields.\n\n        This produces shorter strings but requires all implementations\n        to handle optional fields identically.\n        \"\"\"\n        parts = [self.legal_name_normalized]\n        if self.address_normalized:\n            parts.append(self.address_normalized)\n        parts.append(self.country_code)\n        if self.registration_date:\n            parts.append(self.registration_date)\n        return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.CanonicalInput.to_hash_string","title":"to_hash_string","text":"<pre><code>to_hash_string() -&gt; str\n</code></pre> <p>Generate the concatenated string for hashing.</p> Format <p>legal_name_normalized|address_normalized|country_code|registration_date</p> <p>Empty/None fields are included as empty strings to maintain consistent field positions.</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def to_hash_string(self) -&gt; str:\n    \"\"\"Generate the concatenated string for hashing.\n\n    Format:\n        legal_name_normalized|address_normalized|country_code|registration_date\n\n    Empty/None fields are included as empty strings to maintain\n    consistent field positions.\n    \"\"\"\n    parts = [\n        self.legal_name_normalized,\n        self.address_normalized or \"\",\n        self.country_code,\n        self.registration_date or \"\",\n    ]\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.CanonicalInput.to_hash_string_v2","title":"to_hash_string_v2","text":"<pre><code>to_hash_string_v2() -&gt; str\n</code></pre> <p>Alternative format that omits empty fields.</p> <p>This produces shorter strings but requires all implementations to handle optional fields identically.</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def to_hash_string_v2(self) -&gt; str:\n    \"\"\"Alternative format that omits empty fields.\n\n    This produces shorter strings but requires all implementations\n    to handle optional fields identically.\n    \"\"\"\n    parts = [self.legal_name_normalized]\n    if self.address_normalized:\n        parts.append(self.address_normalized)\n    parts.append(self.country_code)\n    if self.registration_date:\n        parts.append(self.registration_date)\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical input structure from raw entity data.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration/formation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput with all fields normalized.</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical input structure from raw entity data.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration/formation date.\n\n    Returns:\n        CanonicalInput with all fields normalized.\n    \"\"\"\n    return CanonicalInput(\n        legal_name_normalized=normalize_legal_name(legal_name),\n        address_normalized=normalize_address(address) if address else None,\n        country_code=country_code.upper(),\n        registration_date=normalize_registration_date(registration_date)\n        if registration_date\n        else None,\n    )\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(\n    address: str, remove_secondary: bool = True\n) -&gt; str\n</code></pre> <p>Normalize a street address for SNFEI hashing.</p> <p>Pipeline: 1. Lowercase 2. ASCII transliteration 3. Remove secondary unit designators (apt, suite, etc.) 4. Remove punctuation 5. Expand postal abbreviations 6. Collapse whitespace</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Raw street address.</p> required <code>remove_secondary</code> <code>bool</code> <p>Whether to remove apartment/suite numbers.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized address string.</p> Example <p>normalize_address(\"123 N. Main St., Suite 400\") \"123 north main street\"</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def normalize_address(\n    address: str,\n    remove_secondary: bool = True,\n) -&gt; str:\n    \"\"\"Normalize a street address for SNFEI hashing.\n\n    Pipeline:\n    1. Lowercase\n    2. ASCII transliteration\n    3. Remove secondary unit designators (apt, suite, etc.)\n    4. Remove punctuation\n    5. Expand postal abbreviations\n    6. Collapse whitespace\n\n    Args:\n        address: Raw street address.\n        remove_secondary: Whether to remove apartment/suite numbers.\n\n    Returns:\n        Normalized address string.\n\n    Example:\n        &gt;&gt;&gt; normalize_address(\"123 N. Main St., Suite 400\")\n        \"123 north main street\"\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # 1. Lowercase\n    text = address.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove secondary unit designators\n    if remove_secondary:\n        for pattern in SECONDARY_UNIT_PATTERNS:\n            text = re.sub(pattern, \"\", text, flags=re.IGNORECASE)\n\n    # 4. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 5. Collapse whitespace first\n    text = _collapse_whitespace(text)\n\n    # 6. Expand postal abbreviations\n    tokens = text.split()\n    expanded = []\n    for token in tokens:\n        if token in US_ADDRESS_EXPANSIONS:\n            expanded.append(US_ADDRESS_EXPANSIONS[token])\n        else:\n            expanded.append(token)\n    text = \" \".join(expanded)\n\n    # 7. Final trim\n    return text.strip()\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str\n</code></pre> <p>Apply the universal normalization pipeline to a legal name.</p> <p>Pipeline (in order): 1. Convert to lowercase 2. ASCII transliteration 3. Remove punctuation 4. Collapse whitespace 5. Expand abbreviations 6. Remove stop words (optional) 7. Final trim</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>remove_stop_words</code> <code>bool</code> <p>Whether to filter out stop words.</p> <code>True</code> <code>preserve_initial_stop</code> <code>bool</code> <p>If True, preserve stop word at start of name.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized name suitable for SNFEI hashing.</p> Example <p>normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\") \"springfield unified school district incorporated\"</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str:\n    \"\"\"Apply the universal normalization pipeline to a legal name.\n\n    Pipeline (in order):\n    1. Convert to lowercase\n    2. ASCII transliteration\n    3. Remove punctuation\n    4. Collapse whitespace\n    5. Expand abbreviations\n    6. Remove stop words (optional)\n    7. Final trim\n\n    Args:\n        name: Raw legal name from source system.\n        remove_stop_words: Whether to filter out stop words.\n        preserve_initial_stop: If True, preserve stop word at start of name.\n\n    Returns:\n        Normalized name suitable for SNFEI hashing.\n\n    Example:\n        &gt;&gt;&gt; normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\")\n        \"springfield unified school district incorporated\"\n    \"\"\"\n    if not name:\n        return \"\"\n\n    # 1. Lowercase\n    text = name.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 4. Collapse whitespace\n    text = _collapse_whitespace(text)\n\n    # 5. Expand abbreviations\n    text = _expand_abbreviations(text)\n\n    # 6. Remove stop words\n    if remove_stop_words:\n        text = _remove_stop_words(text, preserve_initial=preserve_initial_stop)\n\n    # 7. Final collapse and trim\n    return _collapse_whitespace(text)\n</code></pre>"},{"location":"en/api/#civic_interconnect.cli.normalizer.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(date_str: str) -&gt; str | None\n</code></pre> <p>Normalize a registration date to ISO 8601 format.</p> <p>Returns None if date cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string in various formats.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO 8601 date string (YYYY-MM-DD) or None.</p> Source code in <code>src/python/src/civic_interconnect/cli/normalizer.py</code> <pre><code>def normalize_registration_date(date_str: str) -&gt; str | None:\n    \"\"\"Normalize a registration date to ISO 8601 format.\n\n    Returns None if date cannot be parsed.\n\n    Args:\n        date_str: Date string in various formats.\n\n    Returns:\n        ISO 8601 date string (YYYY-MM-DD) or None.\n    \"\"\"\n    if not date_str:\n        return None\n\n    # Remove extra whitespace\n    date_str = date_str.strip()\n\n    # Try common date patterns\n\n    patterns = [\n        # ISO format\n        (r\"^(\\d{4})-(\\d{2})-(\\d{2})$\", \"%Y-%m-%d\"),\n        # US format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%m/%d/%Y\"),\n        (r\"^(\\d{1,2})-(\\d{1,2})-(\\d{4})$\", \"%m-%d-%Y\"),\n        # European format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%d/%m/%Y\"),\n        # Year only\n        (r\"^(\\d{4})$\", \"%Y\"),\n    ]\n\n    for pattern, fmt in patterns:\n        if re.match(pattern, date_str):\n            try:\n                if fmt == \"%Y\":\n                    # Year only - use January 1\n                    return f\"{date_str}-01-01\"\n                dt = datetime.strptime(date_str, fmt)\n                return dt.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n    return None\n</code></pre>"},{"location":"en/cli/","title":"CLI Reference","text":""},{"location":"en/cli/#quick-help","title":"Quick help","text":"<pre><code># Show top-level help\ncx --help\n\n# Show help for a subcommand\ncx &lt;subcommand&gt; --help\n</code></pre>"},{"location":"en/quick-start/","title":"Quick Start","text":"<p>The Civic Exchange Protocol (CEP) is an open, standards-driven framework for creating verifiable civic records with canonical identities, provenance, and interoperability across jurisdictions.</p> <p>This guide shows how to:</p> <ol> <li>Install CEP tools  </li> <li>Validate schemas  </li> <li>Generate example records  </li> <li>Build entities programmatically  </li> </ol>"},{"location":"en/quick-start/#1-install-the-cep-toolkit","title":"1. Install the CEP Toolkit","text":"<p>You can install the CLI and Python API from PyPI:</p> <pre><code>uv pip install civic-interconnect\n</code></pre> <p>Or add to an existing environment:</p> <pre><code>pip install civic-interconnect\n</code></pre> <p>Confirm installation:</p> <pre><code>cx --help\n</code></pre>"},{"location":"en/quick-start/#2-validate-a-cep-record","title":"2. Validate a CEP Record","text":"<p>CEP ships with a JSON Schema validator:</p> <pre><code>cx validate path/to/my-entity.json\n</code></pre> <p>You may validate any record family:</p> <pre><code>cx validate --schema entity path/to/my-entity.json\ncx validate --schema relationship path/to/my-relationship.json\ncx validate --schema exchange path/to/my-exchange.json\n</code></pre> <p>Successful validation confirms:</p> <ul> <li>Schema compliance  </li> <li>Vocabulary references  </li> <li>Canonical field types  </li> <li>Envelope integrity  </li> </ul>"},{"location":"en/quick-start/#3-generate-example-data","title":"3. Generate Example Data","text":"<p>The CLI can generate examples for any directory under <code>examples/</code>:</p> <pre><code>cx generate-example examples/entity --overwrite\n</code></pre> <p>This produces three files per slice:</p> <ul> <li>01_raw_source.json \u2013 raw adapter input  </li> <li>02_normalized.json \u2013 normalized fields  </li> <li>03_canonical.json \u2013 canonical hash inputs  </li> <li>04_entity_record.json \u2013 final CEP EntityRecord  </li> </ul> <p>This is the best way to understand the transformation pipeline.</p>"},{"location":"en/quick-start/#4-build-an-entity-using-python","title":"4. Build an Entity Using Python","text":"<p>You can construct SNFEI values and full EntityRecords programmatically.</p> <pre><code>from civic_interconnect.cep.snfei import compute_snfei\nfrom civic_interconnect.cep.entity import build_entity_from_raw\n\nraw = {\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"City of Springfield\",\n    \"legalNameNormalized\": \"city springfield\",\n    \"snfei\": compute_snfei(\"city springfield\", \"US-MN\"),\n    \"entityType\": \"municipality\",\n}\n\nentity = build_entity_from_raw(raw)\nprint(entity[\"verifiableId\"])\n</code></pre> <p>If Rust bindings are installed, CEP uses them automatically; otherwise, it falls back to the pure-Python implementation.</p>"},{"location":"en/quick-start/#5-next-steps","title":"5. Next Steps","text":"<ul> <li>Learn how SNFEI canonical identities work at <code>/en/reference/snfei.md</code></li> <li>Understand normalization at <code>/en/concepts/normalization.md</code></li> <li>Explore record envelopes and provenance at <code>/en/implementation/record-envelopes.md</code></li> <li>Explore schemas at <code>/en/schemas.md</code></li> </ul> <p>CEP aims to make civic data verifiable, interoperable, and future-proof with minimal integration overhead.</p> <p>Welcome to the network of connected civic data!</p>"},{"location":"en/schemas/","title":"Civic Interconnect Schemas","text":"<p>These schemas are the source of truth for CEP:</p>"},{"location":"en/schemas/#schemas","title":"Schemas","text":"<p>This directory contains the machine-readable specifications for the Civic Exchange Protocol (CEP). Schemas define the structural rules, validation contracts, controlled vocabularies, and governance models used across CEP implementations.</p>"},{"location":"en/schemas/#directory-structure","title":"Directory Structure","text":"<pre><code>schemas/\n  README.md\n  core/\n  vocabulary/\n  domains/\n  governance/\n</code></pre> <p>Each subdirectory serves a distinct role within the specification:</p>"},{"location":"en/schemas/#core","title":"<code>core/</code>","text":"<p>Defines the foundational schema components shared across all domains, including entities, relationships, exchanges, record envelopes, identifier schemes, and content tags. These schemas establish the canonical structural model that all CEP records build upon.</p>"},{"location":"en/schemas/#vocabulary","title":"<code>vocabulary/</code>","text":"<p>Contains the vocabulary meta-schema along with versioned controlled vocabularies. Vocabularies provide stable identifiers and terms for classifications, codes, and relationship types. Schemas and data instances may reference vocabulary URIs rather than embedding codes directly.</p>"},{"location":"en/schemas/#domains","title":"<code>domains/</code>","text":"<p>Holds domain-specific schemas such as campaign finance, education, environment, procurement, and others. Domain schemas extend the core model and define structures unique to particular civic contexts.</p>"},{"location":"en/schemas/#governance","title":"<code>governance/</code>","text":"<p>Includes schemas that describe how CEP itself is validated, encoded, and traced. This includes canonical graph encoding, fingerprinting, provenance, versioning rules, and related governance structures.</p>"},{"location":"en/schemas/#file-naming-conventions","title":"File Naming Conventions","text":"<p>Schema filenames follow a consistent pattern:</p> <pre><code>&lt;schema-name&gt;.schema.json\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;schema-name&gt;</code> is a descriptive, lowercase, kebab-case identifier  </li> <li><code>.schema.json</code> indicates a JSON Schema document  </li> <li>Versioning is governed by the <code>$id</code> field rather than the filename  </li> </ul> <p>Examples:</p> <ul> <li><code>cep.entity.schema.json</code> </li> <li><code>cep.relationship.schema.json</code> </li> <li><code>cf.contribution.schema.json</code> (domain example)  </li> <li><code>cep.record-envelope.schema.json</code> </li> <li><code>cep.graph.schema.json</code></li> </ul> <p>Filenames describe what the schema is. The directory path describes where the schema belongs within CEP\u2019s structure. These concerns remain independent so that schemas may relocate without requiring filename changes.</p>"},{"location":"en/schemas/#id-and-ref-conventions","title":"<code>$id</code> and <code>$ref</code> Conventions","text":"<p>Each schema defines a unique <code>$id</code> that corresponds to its public URI, typically served from GitHub Raw URLs. Schemas reference one another using relative <code>$ref</code> paths that match the directory layout shown above.</p> <p>This organization ensures that:</p> <ul> <li>References resolve deterministically  </li> <li>Validators can locate dependencies without custom configuration  </li> <li>Implementations can mirror or vend schemas in different hosting environments  </li> </ul>"},{"location":"en/schemas/#hosting-and-resolution","title":"Hosting and Resolution","text":"<p>Tools may load schemas directly via their <code>$id</code> URIs or from a local checkout of this directory. The directory structure is arranged so that relative references remain valid regardless of where the schemas are hosted or embedded.</p> <p>This README describes the organization and conventions of the CEP schema tree. Individual schemas provide further detail on the structures and rules they define.</p>"},{"location":"en/schemas/#cep-schemas","title":"CEP Schemas","text":"Schema Description cep.entity.schema.json Entity records cep.entity.identifier-scheme.schema.json Identifier scheme metadata cep.relationship.schema.json Relationship records cep.exchange.schema.json Exchange records cep.record-envelope.schema.json Core envelope shared by all record families cep.vocabulary.schema.json Vocabulary definition meta-schema cep.ctag.schema.json Per-post tagging model README.md Schema overview and documentation"},{"location":"en/schemas/#schema-and-vocabulary-versions","title":"Schema and Vocabulary Versions","text":"<p>Schemas are expected to change less often than vocabularies and the versioning is handled differently.</p> <ul> <li> <p>Schema URIs are found from the file names <code>schemas/cep.entity.schema.json</code>, etc. Schemas are unversioned at the path, and the <code>schemaVersion</code> field provides the version.</p> </li> <li> <p>Vocabulary URIs are found in <code>vocabularies/&lt;name&gt;.v1.0.0.json#&lt;code&gt;</code>.</p> </li> </ul>"},{"location":"en/concepts/category-theory-foundation/","title":"Category Theory Foundation for the Civic Exchange Protocol (CEP)","text":"<p>Mathematical definition of the category CEP</p>"},{"location":"en/concepts/category-theory-foundation/#abstract-a-categorical-data-model-for-verifiable-information-exchange","title":"Abstract: A Categorical Data Model for Verifiable Information Exchange","text":"<p>Government and institutional information today is fragmented across heterogeneous systems that lack shared identity, provenance, and attestation structures. The Civic Exchange Protocol (CEP) provides a mathematically principled interoperability layer defined as a category CEP, whose objects are attested CEP entities and whose morphisms are typed CEP relationships and exchanges.</p> <p>The core of CEP rests on six structural invariants:</p> <ol> <li>Distributed trust / decentralized verification</li> <li>Immutable provenance chains</li> <li>Jurisdictional autonomy</li> <li>Verifiable ID as a universal construction</li> <li>Cryptographic attestation</li> <li>Non-destructive, hash-anchored revision chains</li> </ol> <p>These invariants guarantee identity consistency, provenance integrity, and long-term trustworthiness across civic systems while preserving local control.</p> <p>CEP's categorical semantics allow data from heterogeneous sources to interoperate, compose, and verify in a predictable, inspectable, and audit-ready manner.</p>"},{"location":"en/concepts/category-theory-foundation/#1-the-category-cep","title":"1. The Category CEP","text":""},{"location":"en/concepts/category-theory-foundation/#11-objects-attested-cep-entities","title":"1.1 Objects: Attested CEP Entities","text":"<p>Objects in CEP are attested entity records conforming to the CEP schema. An object represents a legal or administrative actor (e.g., agency, vendor, nonprofit, district) at a specific revision.</p> <p>Formally:</p> <pre><code>Ob(CEP) = { E | E is a valid, attested CEP entity record }\n</code></pre> <p>Each entity object must satisfy the following invariants:</p>"},{"location":"en/concepts/category-theory-foundation/#invariant-cryptographic-attestation","title":"Invariant: Cryptographic Attestation","text":"<p>Every entity includes a verifiable attestation signed with independently resolvable keys.</p>"},{"location":"en/concepts/category-theory-foundation/#invariant-distributed-trust-decentralized-verification","title":"Invariant: Distributed Trust / Decentralized Verification","text":"<p>Verification must not rely on a single authority. Keys and verification endpoints must support independent validation across jurisdictions.</p>"},{"location":"en/concepts/category-theory-foundation/#12-morphisms-cep-relationships-and-exchanges","title":"1.2 Morphisms: CEP Relationships and Exchanges","text":"<p>Morphisms are directed civic flows between entities.</p>"},{"location":"en/concepts/category-theory-foundation/#relationship-morphisms","title":"Relationship morphisms","text":"<p>Structural, legal, or organizational links:</p> <ul> <li>grant_award: FederalAgency \u2192 StateAgency</li> <li>contract: Agency \u2192 Vendor</li> <li>license: Regulator \u2192 Licensee</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#exchange-morphisms","title":"Exchange morphisms","text":"<p>Operational transfers of value, obligation, or authority:</p> <ul> <li>disbursement: Grantor \u2192 Grantee</li> <li>payment: ContractingOffice \u2192 Vendor</li> <li>allocation: BudgetDept \u2192 Division</li> </ul> <p>Morphisms carry:</p> <ul> <li>type</li> <li>jurisdiction</li> <li>attestation</li> <li>parent references</li> <li>revision metadata</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#invariant-immutable-provenance-chains","title":"Invariant: Immutable Provenance Chains","text":"<p>Every morphism participates in a complete, immutable provenance chain. No selective omission, truncation, or overwriting is permitted.</p>"},{"location":"en/concepts/category-theory-foundation/#13-identity-morphisms","title":"1.3 Identity Morphisms","text":"<p>Each entity E has an identity morphism:</p> <pre><code>id_E : E \u2192 E\n</code></pre> <p>This corresponds to the entity's inaugural self-attested revision.</p>"},{"location":"en/concepts/category-theory-foundation/#2-composition-and-provenance","title":"2. Composition and Provenance","text":"<p>Given:</p> <pre><code>f: A \u2192 B\ng: B \u2192 C\n</code></pre> <p>their composition is:</p> <pre><code>g \u2218 f : A \u2192 C\n</code></pre> <p>Composition expresses derived provenance, allowing a downstream recipient to understand the full lineage of a flow.</p>"},{"location":"en/concepts/category-theory-foundation/#invariant-provenance-chains-must-be-immutable-and-complete","title":"Invariant: Provenance Chains Must Be Immutable and Complete","text":"<p>Composition must preserve the entire provenance chain, with no truncation or mutation.</p>"},{"location":"en/concepts/category-theory-foundation/#associativity","title":"Associativity","text":"<p>As required by category theory:</p> <pre><code>(h \u2218 g) \u2218 f = h \u2218 (g \u2218 f)\n</code></pre> <p>CEP guarantees associativity through:</p> <ul> <li>parent relationship and exchange references</li> <li>hash-linked revision chains</li> <li>cryptographic attestations</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#3-verifiable-identity-as-a-universal-construction","title":"3. Verifiable Identity as a Universal Construction","text":"<p>Government systems often assign different identifiers to the same real-world entity. CEP resolves this through a single canonical Verifiable ID, defined mathematically as a Limit over the diagram of source identifiers.</p>"},{"location":"en/concepts/category-theory-foundation/#31-source-identifier-diagram","title":"3.1 Source Identifier Diagram","text":"<p>An entity may appear in:</p> <ul> <li>SAM.gov</li> <li>state vendor systems</li> <li>LEI databases</li> <li>county procurement files</li> <li>legacy systems</li> </ul> <p>These form a diagram of partial mappings.</p>"},{"location":"en/concepts/category-theory-foundation/#32-the-limit","title":"3.2 The Limit","text":"<p>The Verifiable ID is the unique object V equipped with projections to all identifier sources such that any other object mapping to the same sources factors uniquely through V.</p>"},{"location":"en/concepts/category-theory-foundation/#invariant-verifiable-id-as-universal-construction","title":"Invariant: Verifiable ID as Universal Construction","text":"<p>Once assigned, the Verifiable ID is stable across revisions and cannot be overwritten. Identity is extended only by adding evidence, never by destructively modifying past identity claims.</p>"},{"location":"en/concepts/category-theory-foundation/#4-revision-chains-and-hash-anchoring","title":"4. Revision Chains and Hash Anchoring","text":"<p>Real-world data evolves over time. CEP models this evolution through a non-destructive revision sequence:</p> <pre><code>E\u2081 \u2192 E\u2082 \u2192 E\u2083 \u2192 ...\n</code></pre> <p>Each revision is an object in CEP, linked by an amendment morphism.</p>"},{"location":"en/concepts/category-theory-foundation/#invariant-non-destructive-revision-chain","title":"Invariant: Non-Destructive Revision Chain","text":"<p>Revisions must accumulate. No revision may be deleted or overwritten.</p>"},{"location":"en/concepts/category-theory-foundation/#structure-of-revisions","title":"Structure of Revisions","text":"<p>Each revision includes:</p> <ul> <li>a <code>revisionNumber</code></li> <li>a <code>previousRecordHash</code> linking cryptographically to the prior revision</li> <li>a new attestation verifying content and timestamp</li> </ul> <p>These structures guarantee:</p> <ul> <li>tamper-evident change history</li> <li>reproducibility of past states</li> <li>future-verifiable evidence of updates</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#5-jurisdictional-structure-as-slice-categories","title":"5. Jurisdictional Structure as Slice Categories","text":"<p>Government entities operate within political or administrative boundaries. CEP models jurisdictional scoping using slice categories.</p> <p>For a jurisdiction J:</p> <pre><code>CEP / J\n</code></pre> <p>contains:</p> <ul> <li>all entities whose jurisdiction aligns with J</li> <li>all morphisms where both endpoints lie in J</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#invariant-jurisdictional-autonomy","title":"Invariant: Jurisdictional Autonomy","text":"<p>Each jurisdiction governs its own objects and attestations. Higher-level contexts may compose with these records but may not override them.</p> <p>This supports:</p> <ul> <li>local control</li> <li>independent verification</li> <li>aggregation across jurisdictions</li> </ul> <p>without centralizing authority.</p>"},{"location":"en/concepts/category-theory-foundation/#6-the-verified-subcategory","title":"6. The Verified Subcategory","text":"<p>Define:</p> <pre><code>CEP_verified \u2286 CEP\n</code></pre> <p>as the full subcategory where:</p> <ul> <li>attestations validate</li> <li>verification methods resolve</li> <li>hash links match content</li> <li>provenance chains are intact</li> </ul>"},{"location":"en/concepts/category-theory-foundation/#invariant-cryptographic-attestation_1","title":"Invariant: Cryptographic Attestation","text":"<p>Verification depends on cryptographic evidence, not on trust in a hosting party.</p> <p>Morphisms in the verified subcategory remain verified under composition.</p>"},{"location":"en/concepts/category-theory-foundation/#7-summary-of-embedded-invariants","title":"7. Summary of Embedded Invariants","text":"<p>CEP embeds six structural invariants directly into the mathematical definition of CEP:</p> <ol> <li>Distributed verification</li> <li>Immutable provenance chains</li> <li>Jurisdictional autonomy</li> <li>Universal-construction Verifiable ID</li> <li>Cryptographic attestation</li> <li>Non-destructive revision chains</li> </ol> <p>These invariants ensure that CEP provides a verifiable, interoperable, tamper-evident, and jurisdictionally respectful foundation for verifiable information exchange across jurisdictions and domains.</p>"},{"location":"en/concepts/interoperability/","title":"Interoperability","text":"<p>CEP is designed to integrate with: </p> <ul> <li>Popolo - the entity + political relationships backbone of nearly every open civics project worldwide (OCD, OpenStates, etc.) includes models for Person, Organization, Membership,  Post / Role, Area, Event, Motion / Vote, Legislative Activity and works for elected officials, models boards, committees, councils, includes membership graph.</li> <li>Open Civic Data</li> <li>Open Contracting Data Standard (OCDS) - international standard for public procurement, contracts, tenders, awards, suppliers, implementation and milestone tracking.</li> <li>Schema.org - includes Organization, Person, Place, GovernmentOrganization, Grant, MonetaryGrant,  Legislation, VoteAction and enables interoperability with Google datasets, machine readability.</li> <li>Financial Taxonomies (XBRL) - good for financial reporting, auditing, interoperability with Treasury and state finance systems</li> <li>W3C PROV - good for academics and auditors, PROV guides revision chains, attestation blocks, canonical timestamps, and hash-based integrity. CEP attestation maps to PROV wasGeneratedBy, wasAttributedTo, wasDerivedFrom and CEP previousRecordHash maps to PROV wasRevisionOf.</li> <li>Open Referral Human Services Data Specification (HSDS) - has Organization, Location, Service, Funding - enables connecting public funding to outcomes</li> <li>Financial Industry Business Ontology (FIBO) - map to loan-agreement, grant-award (loosely), subsidiary.</li> </ul>"},{"location":"en/concepts/interoperability/#cep-concept-mapping-table","title":"CEP Concept Mapping Table","text":"CEP Concept CEP Term / Field CEP Vocabulary / Schema External Standard External Concept / Class / Field Mapping Type Notes Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Popolo <code>Organization</code> exactMatch Government bodies (legislatures, councils, agencies). Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> OCD <code>ocd-jurisdiction</code> exactMatch Use in <code>identifiers.additionalSchemes</code> with OCD jurisdiction IDs. Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Schema.org <code>GovernmentOrganization</code> exactMatch For web/SEO and generic data consumers. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> OCD <code>ocd-division</code> + <code>ocd-jurisdiction</code> (school districts) broadMatch Division/jurisdiction pair identifies school districts. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> Schema.org <code>EducationalOrganization</code> / <code>SchoolDistrict</code> (where available) exactMatch For education analytics and public-facing data. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Popolo <code>Organization</code> with classification <code>nonprofit</code> broadMatch Nonprofits providing services, fiscal sponsors, etc. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Schema.org <code>NGO</code> / <code>Organization</code> relatedMatch Web-compatible representation of nonprofits. Entity (organization) <code>entityTypeUri = #vendor</code> <code>entity-type.json</code> OCDS <code>Party</code> with role <code>supplier</code> exactMatch Contractors / vendors in procurement. Entity (natural person) <code>entityTypeUri = #natural-person</code> <code>entity-type.json</code> Popolo <code>Person</code> exactMatch Politicians, officials, natural-person donors, etc. Entity (natural person) <code>entityTypeUri = #elected-official</code> <code>entity-type.json</code> Popolo <code>Person</code> + <code>Membership</code> in <code>Organization</code> exactMatch Derived from Popolo membership in a legislature / council. Entity (natural person) <code>entityTypeUri = #natural-person</code> / <code>#elected-official</code> <code>entity-type.json</code> Schema.org <code>Person</code> exactMatch Generic consumer-friendly alignment. Entity (division) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division/...</code> exactMatch Political geography for school districts, counties, states, etc. Entity (jurisdiction) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-jurisdiction/...</code> exactMatch Governing bodies over divisions. Entity (organization) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-organization/...</code> exactMatch Committees, councils, agencies, boards. Entity (person) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-person/...</code> exactMatch People in OCD-compatible civic graphs. Entity (financial) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI ISO 17442 Legal Entity Identifier exactMatch Global financial identity for entities in financial transactions. Entity (federal) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov Unique Entity Identifier exactMatch U.S. federal financial identity for entities. Entity (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) Hash-based Structured Non-Fungible Entity Identifier newConcept Bridges UEI/LEI to local civic entities; open-source identifier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> exactMatch Prime contract between government and supplier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> USAspending <code>contract</code> (glossary) exactMatch Alignment with USASpending contract awards. Relationship (subcontract) <code>relationshipTypeUri = #subcontract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> linked via <code>relatedProcesses</code> broadMatch Subcontracts under a prime contract. Relationship (grant) <code>relationshipTypeUri = #grant-award</code> <code>relationship-type.json</code> USAspending <code>grant</code> (glossary) exactMatch Federal grants / assistance awards. Relationship (subgrant) <code>relationshipTypeUri = #subgrant</code> <code>relationship-type.json</code> OCDS <code>Award</code> + <code>Implementation.transactions</code> for subawards broadMatch Pass-through grants from state to local entities. Relationship (coop agrmt) <code>relationshipTypeUri = #cooperative-agreement</code> <code>relationship-type.json</code> USAspending <code>cooperative agreement</code> exactMatch Cooperative federal assistance relationships. Relationship (interagency) <code>relationshipTypeUri = #interagency-agreement</code> <code>relationship-type.json</code> OCDS <code>Contract</code> or <code>Agreement</code> between government parties relatedMatch Transfer agreements between agencies. Relationship (MOU) <code>relationshipTypeUri = #memorandum-of-understanding</code> <code>relationship-type.json</code> Popolo <code>Membership</code> / <code>Organization</code> with informal cooperation relatedMatch Non-binding but structured relationships. Relationship (fiscal spon) <code>relationshipTypeUri = #fiscal-sponsorship</code> <code>relationship-type.json</code> HSDS <code>Funding</code> / <code>Service</code> provider/host relationship relatedMatch Connects projects to 501(c)(3) entities. Relationship (board) <code>relationshipTypeUri = #board-membership</code> <code>relationship-type.json</code> Popolo <code>Membership</code> (person \u2194 organization, role = board member) exactMatch Governance relationships. Relationship (employment) <code>relationshipTypeUri = #employment</code> <code>relationship-type.json</code> Popolo <code>Membership</code> or <code>Post</code> with classification <code>employment</code> exactMatch Staff roles in agencies, schools, vendors. Relationship (consulting) <code>relationshipTypeUri = #consulting-engagement</code> <code>relationship-type.json</code> Popolo <code>Membership</code> with classification <code>consultant</code> relatedMatch Non-employee professional services. Relationship (subsidiary) <code>relationshipTypeUri = #subsidiary</code> <code>relationship-type.json</code> Schema.org <code>subOrganization</code> relatedMatch Corporate ownership within civic vendor trees. Relationship (joint ven.) <code>relationshipTypeUri = #joint-venture</code> <code>relationship-type.json</code> FIBO Joint venture relationship relatedMatch Optional mapping for advanced financial/corporate semantics. Relationship (reg. reg.) <code>relationshipTypeUri = #regulatory-registration</code> <code>relationship-type.json</code> Schema.org <code>GovernmentOrganization</code> + <code>registration</code>-related properties relatedMatch Entities registered with regulatory bodies. Relationship (loan) <code>relationshipTypeUri = #loan-agreement</code> <code>relationship-type.json</code> FIBO Loan contract exactMatch For loans, bond-like instruments, and revolving credit. Relationship (bill-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Bill</code> object relatedMatch Relationship authorized or shaped by a bill. Relationship (vote-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Vote</code> object relatedMatch Relationship activated/approved by a vote. Relationship (event-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Event</code> object relatedMatch Relationship linked to hearings, meetings, signings. Exchange (grant) <code>exchangeTypeUri = #grant-disbursement</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type grant disbursement exactMatch Payment of grant funds under a grant-award relationship. Exchange (contract fee) <code>exchangeTypeUri = #contract-fee-payment</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type payment exactMatch Invoice payments under contracts. Exchange (subaward) <code>exchangeTypeUri = #subgrant-disbursement</code> <code>exchange-type.json</code> USAspending Subaward transactions exactMatch Pass-through disbursements to subrecipients. Exchange (donation) <code>exchangeTypeUri = #campaign-contribution</code> <code>exchange-type.json</code> Popolo / DIME Contribution records mapped to <code>Person</code> / <code>Organization</code> donors/recipients relatedMatch Campaign finance contributions tied into CEP graph. Exchange (in-kind) <code>value.valueTypeUri = #in-kind</code> <code>value-type.json</code> Schema.org <code>Offer</code> / <code>Grant</code> with non-monetary value relatedMatch Non-monetary goods/services tracked in CEP. Exchange (service-hours) <code>value.valueTypeUri = #service-hours</code> <code>value-type.json</code> HSDS <code>Service</code> + time-based contributions relatedMatch Volunteer or staff time as value. Exchange (categorization) <code>categorization.naicsCode</code> <code>cep.exchange.schema.json</code> NAICS NAICS industry codes exactMatch Standard economic activity classification for exchanges. Exchange (categorization) <code>categorization.cfdaNumber</code> <code>cep.exchange.schema.json</code> CFDA / Assistance CFDA / Assistance Listing number exactMatch Links exchanges to federal assistance programs. Exchange (categorization) <code>categorization.gtasAccountCode</code> <code>cep.exchange.schema.json</code> GTAS Treasury Account Symbol exactMatch Aligns exchanges to Treasury reporting accounts. Exchange (source) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCDS <code>Release</code>, <code>Award</code>, <code>Contract</code>, <code>Implementation.transactions</code> relatedMatch Exchange derived from procurement data. Exchange (bill/vote) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCD <code>Bill</code>, <code>Vote</code>, <code>Event</code> relatedMatch Funding events tied to legislative activity. Value (monetary) <code>value.valueTypeUri = #monetary</code> <code>value-type.json</code> XBRL Monetary item types (e.g., <code>monetaryItemType</code>) exactMatch Monetary amounts aligned with financial reporting taxonomies. Value (monetary) <code>value.amount</code>, <code>value.currencyCode</code> <code>cep.exchange.schema.json</code> XBRL <code>xbrli:monetaryItemType</code>, ISO 4217 exactMatch Strictly typed monetary values. Value (provisioning) <code>valueTypeUri = #service-hours</code> / <code>#in-kind</code> <code>value-type.json</code> HSDS <code>Service</code> value dimensions relatedMatch For human services and community programs. Provenance (entity) <code>attestation</code> block on Entity <code>cep.entity.schema.json</code> W3C PROV <code>prov:Entity</code>, <code>prov:wasGeneratedBy</code>, <code>prov:wasAttributedTo</code> exactMatch Entity record as a PROV entity with associated agent/activity. Provenance (relationship) <code>attestation</code> block on Relationship <code>cep.relationship.schema.json</code> W3C PROV Same as above exactMatch Relationship record provenance in PROV terms. Provenance (exchange) <code>attestation</code> block on Exchange <code>cep.exchange.schema.json</code> W3C PROV Same as above exactMatch Exchange record provenance. Provenance (revision) <code>previousRecordHash</code>, <code>revisionNumber</code> all CEP core schemas W3C PROV <code>prov:wasRevisionOf</code>, <code>prov:qualifiedRevision</code> exactMatch Immutable revision chains expressed via hashes and monotone revisions. Provenance (hash) Canonical string + SHA-256 hash (SSOT) implementation / spec W3C PROV <code>prov:generatedAtTime</code>, <code>prov:wasDerivedFrom</code> relatedMatch Hash as integrity proof supporting PROV-compatible derivation chains. IDs (UEI) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov UEI exactMatch Federal identity. IDs (LEI) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI LEI exactMatch Global financial identity. IDs (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) SNFEI newConcept Open, recomputable sub-federal ID bridging UEI/LEI and local civic entities. IDs (OCD) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division</code>, <code>ocd-jurisdiction</code>, <code>ocd-organization</code>, <code>ocd-person</code> exactMatch Primary bridge to the Open Civic Data topology. IDs (OCDS) <code>identifiers.additionalSchemes</code> on Entity/Relationship <code>cep.entity/relationship</code> OCDS <code>Parties</code>, <code>Award.id</code>, <code>Contract.id</code> relatedMatch Tie CEP entities/relationships back to OCDS releases. IDs (Popolo) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> Popolo <code>Person.id</code>, <code>Organization.id</code> relatedMatch Where Popolo IDs exist separately from OCD IDs."},{"location":"en/concepts/interoperability/#cep-concept-mapping-table-by-schema","title":"CEP Concept Mapping Table (by Schema)","text":"CEP Concept / Field External Standard External Concept / ID / Class Mapping Type Suggested <code>externalUri</code> / <code>schemeUri</code> example Notes Entity (general civic entity) Popolo <code>Person</code>, <code>Organization</code> broadMatch <code>http://www.popoloproject.com/specs/person.html</code>, <code>http://www.popoloproject.com/specs/organization.html</code> CEP <code>entity</code> covers both persons and orgs; Popolo separates. <code>entityTypeUri</code> <code>#natural-person</code> Popolo <code>Person</code> exactMatch <code>http://www.popoloproject.com/specs/person.html</code> For individuals (candidates, officials, donors). <code>entityTypeUri</code> <code>#organization</code> Popolo <code>Organization</code> exactMatch <code>http://www.popoloproject.com/specs/organization.html</code> Base org type, parent of more specific government / nonprofit types. <code>entityTypeUri</code> <code>#government-jurisdiction</code> Popolo/OCD Popolo <code>Organization</code> + OCD <code>jurisdiction</code> relatedMatch <code>https://opencivicdata.org/id/jurisdiction</code> A governing body; mix of org and jurisdiction. <code>identifiers.additionalSchemes</code> (division) OCD <code>ocd-division/*</code> exactMatch <code>https://opencivicdata.org/id/division</code> Store OCD division IDs as <code>schemeUri = \"https://opencivicdata.org/id/division\"</code>. <code>identifiers.additionalSchemes</code> (jurisdiction) OCD <code>ocd-jurisdiction/*</code> exactMatch <code>https://opencivicdata.org/id/jurisdiction</code> Store OCD jurisdiction IDs. <code>identifiers.additionalSchemes</code> (person) OCD / Popolo <code>ocd-person/*</code> (Popolo person) exactMatch <code>https://opencivicdata.org/id/person</code> Link CEP entity to OCD/Popolo person IDs. <code>identifiers.additionalSchemes</code> (organization) OCD / Popolo <code>ocd-organization/*</code> exactMatch <code>https://opencivicdata.org/id/organization</code> Link CEP entity to OCD/Popolo org IDs. <code>identifiers.lei</code> leif / LEI <code>LEI</code> (ISO 17442 Legal Entity Identifier) exactMatch <code>https://www.gleif.org/en/about-lei/introducing-the-legal-entity-identifier-lei</code> Already in schema; key for global finance interoperability. <code>identifiers.samUei</code> US Federal UEI (SAM.gov Unique Entity Identifier) exactMatch <code>https://www.sam.gov/</code> Tier 2 identity in our stack. <code>identifiers.additionalSchemes</code> (OCDS party) OCDS <code>parties.identifier.id</code> relatedMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Use for suppliers / buyers in procurement records. <code>entityTypeUri</code> <code>#supplier</code> / <code>#contractor</code> OCDS <code>Organization</code> with role <code>supplier</code> / <code>tenderer</code> exactMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Straight mapping for vendors. <code>entityTypeUri</code> <code>#school-district</code> Schema.org <code>SchoolDistrict</code> (subtype of <code>EducationalOrganization</code>) relatedMatch <code>https://schema.org/SchoolDistrict</code> For education equity analytics. <code>entityTypeUri</code> <code>#government-agency</code> Schema.org <code>GovernmentOrganization</code> exactMatch <code>https://schema.org/GovernmentOrganization</code> For agencies at any level. Relationship (legal / functional relationships) Popolo <code>Membership</code>, <code>Post</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> CEP Relationship is more general; includes contracts, grants, etc. <code>relationshipTypeUri</code> <code>#board-membership</code> Popolo <code>Membership</code> exactMatch <code>http://www.popoloproject.com/specs/membership.html</code> Board membership of a person in an org. <code>relationshipTypeUri</code> <code>#employment</code> Popolo <code>Membership</code> (with <code>post</code> / <code>role</code>) broadMatch <code>http://www.popoloproject.com/specs/membership.html</code> Employment is a constrained membership. <code>relationshipTypeUri</code> <code>#consulting-engagement</code> Popolo <code>Membership</code> or <code>ContactDetail</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> Less formal, non-employee service relationship. <code>relationshipTypeUri</code> <code>#prime-contract</code> OCDS <code>Contract</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> CEP Relationship for a prime contract matches OCDS Contract. <code>relationshipTypeUri</code> <code>#subcontract</code> OCDS <code>Contract</code> with <code>relatedProcesses</code> / <code>relatedLots</code> narrowMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> Subcontracts are contracts linked to a parent award. <code>relationshipTypeUri</code> <code>#grant-award</code> OCDS <code>Award</code> relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#award</code> OCDS is procurement-focused; grants are adjacent. <code>relationshipTypeUri</code> <code>#cooperative-agreement</code> OCDS <code>Award</code> or <code>Contract</code> (context-specific) relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/</code> Map conceptually to awarded agreements. <code>relationshipTypeUri</code> <code>#loan-agreement</code> FIBO <code>LoanAgreement</code> exactMatch <code>https://spec.edmcouncil.org/fibo/ontology/FBC/DebtAndEquities/Debt/LoanAgreement</code> Optional FIBO mapping; useful for financial instruments. <code>relationshipTypeUri</code> <code>#subsidiary</code> Schema.org <code>subOrganization</code> relatedMatch <code>https://schema.org/subOrganization</code> See vocab.mappings. <code>relationshipTypeUri</code> <code>#joint-venture</code> Schema.org <code>Organization</code> with <code>memberOf</code> relatedMatch <code>https://schema.org/Organization</code> Joint ventures as special multi-party orgs. <code>relationshipTypeUri</code> <code>#regulatory-registration</code> Schema.org <code>GovernmentOrganization</code> / <code>Service</code> relatedMatch <code>https://schema.org/GovernmentOrganization</code> Registration with a regulator. <code>relationshipTypeUri</code> <code>#fiscal-sponsorship</code> HSDS / Nonprofit HSDS <code>Funding</code> or <code>Service</code> relatedMatch <code>https://github.com/openreferral/specification</code> For nonprofit fiscal sponsor relationships. Exchange (value transfer events) OCDS <code>Implementation.transactions[]</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#implementation</code> CEP Exchange is very close to OCDS transaction-level data. <code>exchangeTypeUri</code> <code>#grant-disbursement</code> Schema.org <code>MonetaryGrant</code> exactMatch <code>https://schema.org/MonetaryGrant</code> Core pattern for education &amp; campaign finance. <code>exchangeTypeUri</code> <code>#contract-fee-payment</code> Schema.org <code>Payment</code> / <code>Invoice</code> relatedMatch <code>https://schema.org/Invoice</code> Payment for contracted services. <code>exchangeTypeUri</code> <code>#donation</code> (if defined) Schema.org <code>DonateAction</code> relatedMatch <code>https://schema.org/DonateAction</code> Campaign or charitable donations. <code>exchangeTypeUri</code> <code>#loan-disbursement</code> FIBO <code>LoanPrincipalPayment</code> relatedMatch FIBO debt concepts More detailed financial modeling if needed. Value &amp; Categorization XBRL GAAP / GRT financial elements exactMatch e.g. <code>http://xbrl.us/us-gaap/2024-01-31#RevenueRecognition</code> Map CEP <code>categorization</code> fields to XBRL when possible. <code>value.currencyCode</code> ISO 4217 Currency codes exactMatch <code>https://www.iso.org/iso-4217-currency-codes.html</code> Already enforced by regex. <code>categorization.naicsCode</code> NAICS NAICS activity code exactMatch <code>https://www.census.gov/naics/</code> Already included in schema. <code>categorization.cfdaNumber</code> Assistance List CFDA / Assistance Listing number exactMatch <code>https://sam.gov/content/assistance-listing</code> For federal assistance programs. <code>categorization.gtasAccountCode</code> US GTAS Treasury Account Symbol (TAS) exactMatch <code>https://fiscal.treasury.gov/gtas/</code> Connects to federal reporting. Provenance &amp; Attestation W3C PROV <code>Entity</code>, <code>Activity</code>, <code>Agent</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, etc. relatedMatch <code>https://www.w3.org/TR/prov-o/</code> CEP is PROV-aligned but more specialized. <code>attestation.attestorId</code> W3C PROV <code>Agent</code> / <code>prov:wasAttributedTo</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasAttributedTo</code> The attesting node is the Agent. <code>attestation.attestationTimestamp</code> W3C PROV <code>generatedAtTime</code> exactMatch <code>https://www.w3.org/TR/prov-o/#generatedAtTime</code> When the record (Entity) was generated. <code>previousRecordHash</code> W3C PROV <code>wasRevisionOf</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasRevisionOf</code> Revision chain between CEP records. <code>provenanceChain.fundingChainTag</code> W3C PROV <code>wasDerivedFrom</code> chain relatedMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Human-readable representation of a PROV derivation path. <code>provenanceChain.parentExchangeId</code> W3C PROV <code>wasDerivedFrom</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Parent exchange is the immediate predecessor in the flow. Events, Bills, Votes OCD / Popolo <code>Bill</code>, <code>VoteEvent</code>, <code>Event</code> relatedMatch <code>https://opencivicdata.org/specs/</code> Linked via <code>sourceReferences</code>. <code>sourceReferences</code> (bill) OCD <code>ocd-bill/*</code> exactMatch <code>https://opencivicdata.org/id/bill</code> For authorizing legislation. <code>sourceReferences</code> (vote) OCD / Popolo <code>ocd-vote/*</code> or Popolo <code>VoteEvent</code> exactMatch <code>https://opencivicdata.org/id/vote</code> For authorization votes. <code>sourceReferences</code> (event) OCD / Popolo <code>Event</code> exactMatch <code>https://opencivicdata.org/id/event</code> Meetings, hearings tied to relationships or exchanges. Human Services / Programs (optional) HSDS <code>Service</code>, <code>Organization</code>, <code>Funding</code> relatedMatch <code>https://github.com/openreferral/specification</code> For social services and community programs. <code>entityTypeUri</code> <code>#service-provider</code> HSDS <code>Organization</code> exactMatch <code>https://github.com/openreferral/specification</code> For agencies and nonprofits providing services. <code>relationshipTypeUri</code> <code>#service-delivery-agreement</code> (future) HSDS <code>Service</code> / <code>Funding</code> relatedMatch HSDS docs If added."},{"location":"en/concepts/interoperability/#vocabulary-notes","title":"Vocabulary Notes","text":"<p>prime-contract</p> <ul> <li>USAspending contract is a close conceptual match.</li> <li>OCDS contract is the canonical public procurement concept, so exactMatch.</li> </ul> <p>subcontract</p> <ul> <li>OCDS does not have a first-class subcontract object, but it is conceptually a specialized contract under a main award, so narrowMatch.</li> </ul> <p>grant-award</p> <ul> <li>USAspending grant is a direct match to federal grants.</li> <li>OCDS award is broader (covers procurements and grants), so relatedMatch.</li> <li>Schema.org MonetaryGrant is almost exactly, so exactMatch.</li> </ul> <p>loan-agreement</p> <ul> <li>FIBO Contracts and Loans ontologies give similar semantic neighborhood but more general, so relatedMatch.</li> </ul> <p>subsidiary</p> <ul> <li>Schema.org subOrganization is close but not strictly legal-definition match, so relatedMatch.</li> <li>FIBO Subsidiary is semantically close but in financial-industry framing; so relatedMatch.</li> </ul> <p>board-membership and employment</p> <ul> <li>Both are specializations of Popolo Membership (person\u2013organization relationship with roles and time-bounds), so narrowMatch.</li> </ul>"},{"location":"en/concepts/normalization/","title":"Normalization","text":"<p>Normalization is the first transformation step in the CEP pipeline. Its purpose is to convert raw, heterogeneous civic data into a consistent structure before canonicalization and hashing.</p> <p>In practice there are two layers:</p> <ul> <li>Adapter-level normalization - local, jurisdiction-aware cleaning and mapping from raw sources.</li> <li>Core normalization - a small, international, script-preserving pass implemented in the CEP core (Rust), applied just before SNFEI hashing.</li> </ul> <p>This separation ensures:</p> <ul> <li>Adapters can reflect local domain knowledge and messy source quirks</li> <li>Core normalization remains stable and global across all jurisdictions</li> <li>Normalization rules can evolve without breaking the hash function, as long as the core contract is respected</li> </ul>"},{"location":"en/concepts/normalization/#1-goals-of-normalization","title":"1. Goals of Normalization","text":"<p>Normalization should:</p> <ul> <li>Produce deterministic strings (same input \u2192 same normalized form)</li> <li>Ensure stable Unicode handling across scripts</li> <li>Provide predictable address strings for hashing</li> <li>Remove noise (punctuation, obvious boilerplate) without erasing meaning</li> <li>Apply jurisdiction-specific expansions via configuration, not ad-hoc code</li> </ul> <p>Normalization must not:</p> <ul> <li>Guess or infer missing values</li> <li>Perform record linkage or entity resolution</li> <li>Translate between languages</li> <li>Destroy information from non-Latin scripts just to satisfy ASCII-only constraints</li> </ul> <p>Anything that changes semantic meaning or crosses those boundaries belongs outside the canonical SNFEI path.</p>"},{"location":"en/concepts/normalization/#2-core-normalization-pipeline-international-policy","title":"2. Core Normalization Pipeline (International Policy)","text":"<p>The CEP core defines a script-preserving normalization policy used to build canonical inputs for SNFEI. Adapters may do extra work, but they must not contradict this core behavior.</p> <p>At a high level, core normalization does:</p> <ol> <li>Unicode normalization and case folding  </li> <li>Punctuation and spacing cleanup  </li> <li>Safe abbreviation expansion  </li> <li>Optional stop-word removal (language-aware)  </li> <li>Address cleanup for hashing</li> </ol>"},{"location":"en/concepts/normalization/#21-unicode-normalization-and-case-folding","title":"2.1 Unicode Normalization and Case Folding","text":"<p>Core normalization applies Unicode normalization and converts text to a stable lowercase form. </p> <p>We use Normalization Form Compatibility Decomposition (NFKD) for the SNFEI canonicalization path.</p> <p>Understanding NFD vs. NFKD</p> Form Full Name Effect on Characters Why We Use NFKD NFD Normalization Form Decomposition Separates base characters from combining marks/diacritics. Preserves too much semantic variation. For example, it would treat compatibility characters differently from their base equivalents. NFKD Normalization Form Compatibility Decomposition Separates base characters,  and replaces compatibility characters (e.g.,  ligatures, Roman numerals) with their best plain text equivalent. Addresses Entity Resolution. Compatibility characters often arise from rendering/typography and should be treated as equivalent for identity hashing (e.g., the KC in NFKC is too strict, but the KD in NFKD is perfect for eliminating visual noise). <p>The Core Process</p> <ul> <li>Apply NFKD: The input string is converted to NFKD. This replaces ligatures and compatibility characters with their basic constituent letters.</li> <li>Strip combining marks where safe (\u00e9 \u2192 e, \u00f1 \u2192 n, \u00f6 \u2192 o) for Latin-based scripts.</li> <li>Preserve underlying letters in all scripts (Greek, Cyrillic, Han, Arabic, etc.).</li> <li>Apply lowercase / casefolding to get a consistent case-insensitive representation.</li> </ul> <p>Examples:</p> <ul> <li><code>\"Soci\u00e9t\u00e9 G\u00e9n\u00e9rale\"</code> \u2192 <code>\"societe generale\"</code> </li> <li><code>\"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae \u0395\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b1 \u0394\u03b5\u03b4\u03bf\u03bc\u03ad\u03bd\u03c9\u03bd\"</code> \u2192 a lowercased Greek string with accents normalized, but still in Greek, not dropped or transliterated to ASCII.</li> </ul> <p>Key property: Core normalization uses NFKD because it is the most aggressive form of decomposition that remains script-preserving (i.e., it doesn't try to turn Arabic into ASCII) while ensuring maximum equivalency for hashing identifiers, making two visually distinct inputs (due to font/encoding issues) hash to the same canonical ID.</p>"},{"location":"en/concepts/normalization/#22-punctuation-whitespace","title":"2.2 Punctuation &amp; Whitespace","text":"<p>All scripts share a common punctuation/whitespace policy:</p> <ul> <li>Replace punctuation (commas, periods, quotes, dashes, etc.) with spaces.</li> <li>Remove control characters.</li> <li>Collapse runs of whitespace to a single space.</li> <li>Trim leading/trailing spaces.</li> </ul> <p>Examples:</p> <ul> <li><code>\"City of Springfield, Inc.\"</code> \u2192 <code>\"city of springfield inc\"</code> </li> <li><code>\"123 N. Main St., Suite 400\"</code> (before abbreviation expansion) \u2192 <code>\"123 n main st suite 400\"</code></li> </ul>"},{"location":"en/concepts/normalization/#23-abbreviation-expansion-language-region-aware","title":"2.3 Abbreviation Expansion (Language- &amp; Region-Aware)","text":"<p>Abbreviations are expanded only where we have explicit rules. Core provides a Latin-focused, international set; jurisdictions can add overlays (e.g. <code>us/mn.yaml</code>, <code>us/ma.yaml</code>).</p> <p>Examples of core expansions:</p> <ul> <li>Legal forms:</li> <li><code>\"inc\"</code>, <code>\"inc.\"</code> \u2192 <code>\"incorporated\"</code></li> <li><code>\"corp\"</code>, <code>\"corp.\"</code> \u2192 <code>\"corporation\"</code></li> <li><code>\"gmbh\"</code> \u2192 <code>\"gesellschaft mit beschrankter haftung\"</code></li> <li><code>\"sa\"</code>, <code>\"s.a.\"</code> \u2192 <code>\"sociedad anonima\"</code> (by explicit rule)</li> <li>Organizational abbreviations:</li> <li><code>\"sch\"</code> \u2192 <code>\"school\"</code></li> <li><code>\"dist\"</code> \u2192 <code>\"district\"</code></li> <li><code>\"univ\"</code> \u2192 <code>\"university\"</code></li> </ul> <p>Address expansions (core US examples):</p> <ul> <li><code>\"st\"</code>, <code>\"st.\"</code> \u2192 <code>\"street\"</code></li> <li><code>\"ave\"</code>, <code>\"ave.\"</code> \u2192 <code>\"avenue\"</code></li> <li><code>\"n\"</code>, <code>\"n.\"</code> \u2192 <code>\"north\"</code></li> <li><code>\"sw\"</code> \u2192 <code>\"southwest\"</code></li> </ul> <p>For scripts outside that vocabulary, no attempt is made to transliterate or guess expansions; the text is left as cleaned lowercased Unicode.</p>"},{"location":"en/concepts/normalization/#24-stop-word-removal","title":"2.4 Stop-Word Removal","text":"<p>Stop words are used cautiously and are language-aware:</p> <ul> <li>Core defines a small English set: <code>\"the\"</code>, <code>\"of\"</code>, <code>\"and\"</code>, <code>\"for\"</code>, <code>\"in\"</code>, etc.</li> <li>They may be removed after expansion and punctuation cleanup.</li> <li>For names beginning with a stop word, behavior can be configured (e.g. preserve <code>\"the\"</code> at the start vs. drop it).</li> </ul> <p>Example (English):</p> <ul> <li><code>\"The City of Springfield\"</code> \u2192 <code>\"city springfield\"</code></li> </ul> <p>For non-English scripts, stop-word lists must be defined explicitly; otherwise, core does not silently drop tokens.</p>"},{"location":"en/concepts/normalization/#25-address-cleanup-for-hashing","title":"2.5 Address Cleanup for Hashing","text":"<p>For SNFEI hashing, addresses are normalized into a minimal, stable form:</p> <ul> <li>Lowercase + Unicode normalization as above.</li> <li>Remove secondary unit designators (apt, suite, floor, room, etc.).</li> <li>Remove punctuation and collapse whitespace.</li> <li>Expand postal abbreviations (US: <code>st</code> \u2192 <code>street</code>, <code>rd</code> \u2192 <code>road</code>, directionals, etc.).</li> <li>Trim final result; empty or near-empty addresses become <code>None</code> in canonical form.</li> </ul> <p>Example (US):</p> <ul> <li>Raw: <code>\"123 N. Main St., Suite 400\"</code> </li> <li>Normalized: <code>\"123 north main street\"</code></li> </ul>"},{"location":"en/concepts/normalization/#3-canonical-input-shape","title":"3. Canonical Input Shape","text":"<p>Core normalization produces a canonical input struct that feeds SNFEI hashing. Conceptually:</p> <pre><code>{\n  \"legalNameNormalized\": \"springfield public schools\",\n  \"addressNormalized\": \"123 north main street\",\n  \"countryCode\": \"US\",\n  \"registrationDate\": \"1985-01-15\"\n}\n</code></pre> <p>The canonical hash string is then built in a fixed order, e.g.:</p> <p><code>springfield public schools|123 north main street|US|1985-01-15</code></p> <p>Empty/unknown fields are represented as empty strings in the hash preimage, but stored as <code>null</code> / omitted in the JSON representation.</p>"},{"location":"en/concepts/normalization/#4-example-from-raw-to-normalized","title":"4. Example: From Raw to Normalized","text":"<p>Raw: <pre><code>{\n  \"legalName\": \"City of Springfield Unified Sch. Dist., Inc.\",\n  \"address\": \"123 N. Main St., Suite 400\",\n  \"countryCode\": \"US\",\n  \"jurisdictionIso\": \"US-IL\",\n  \"registrationDate\": \"01/15/1985\"\n}\n</code></pre></p> <p>Core-normalized canonical input:</p> <pre><code>{\n  \"legalNameNormalized\": \"city springfield unified school district incorporated\",\n  \"addressNormalized\": \"123 north main street\",\n  \"countryCode\": \"US\",\n  \"registrationDate\": \"1985-01-15\"\n}\n</code></pre> <p>International example (French):</p> <pre><code>{\n  \"legalName\": \"Soci\u00e9t\u00e9 G\u00e9n\u00e9rale S.A.\",\n  \"countryCode\": \"FR\"\n}\n</code></pre> <p>to:</p> <pre><code>{\n  \"legalNameNormalized\": \"societe generale societe anonyme\",\n  \"addressNormalized\": null,\n  \"countryCode\": \"FR\",\n  \"registrationDate\": null\n}\n</code></pre> <p>International example (Greek):</p> <pre><code>{\n  \"legalName\": \"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae \u0395\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b1 \u0394\u03b5\u03b4\u03bf\u03bc\u03ad\u03bd\u03c9\u03bd\",\n  \"countryCode\": \"GR\"\n}\n</code></pre> <p>to: a lowercased Greek string with punctuation removed and whitespace collapsed; the script remains Greek, not transliterated or dropped.</p>"},{"location":"en/concepts/normalization/#5-normalization-vs-canonicalization","title":"5. Normalization vs Canonicalization","text":"Stage Purpose Uses Adapter Normalization Clean and map raw records into CEP-friendly fields Adapters / ETL code Core Normalization Unicode-safe, script-preserving string cleanup CEP Rust core Canonicalization Assemble final hash string and compute SNFEI CEP Rust core (SNFEI) <p>Notes: - Adapter normalization may be jurisdiction-specific and can evolve quickly. - Core normalization is global and stable; all implementations must match it. - Canonicalization is purely structural: build the hash pre-image in the agreed order, then hash.</p>"},{"location":"en/concepts/normalization/#6-international-design","title":"6. International Design","text":"<p>This design ensures that:</p> <ul> <li>The same entity produces the same SNFEI across jurisdictions and implementations.</li> <li>Latin-based names behave as expected (diacritics folded, legal suffixes expanded).</li> <li>Non-Latin scripts (Greek, Cyrillic, Han, Arabic, etc.) are first-class citizens, not collateral damage of ASCII-only assumptions.</li> <li>Future language- or country-specific tweaks (e.g. new legal forms) can be layered on via vocabularies and localization files, without rewriting the core.</li> </ul> <p>Normalization is designed to be transparent, domain-aware, and non-destructive, serving as the reliable entrance to the CEP identity pipeline.</p>"},{"location":"en/concepts/positioning-paper/","title":"Civic Interconnect Positioning Paper","text":"<p>CEP and CTags as Interoperability Layer for Civic Data Ecosystems</p>"},{"location":"en/concepts/positioning-paper/#1-introduction","title":"1. Introduction","text":"<p>Modern civic systems rely on multiple established standards: Open Civic Data (OCD) for political geography, Popolo for people and organizations, the Open Contracting Data Standard (OCDS) for procurement, and numerous state or federal schemas for grants, budgets, elections, disclosures, and public records.</p> <p>Each standard addresses its own domain well.  </p> <p>What is missing is a cross-domain, provenance-aware interoperability layer.</p> <p>The Civic Interconnect framework fills this gap by providing two complementary tools:</p> <ul> <li>Civic Exchange Protocol (CEP) - a lightweight model for representing entities, relationships, and exchanges across civic workflows.</li> <li>CTags (Context Tags) - a simple, deployable context tag format that attaches annotations to records.</li> </ul> <p>Civic Interconnect does not replace existing standards. It enables them to interoperate.</p>"},{"location":"en/concepts/positioning-paper/#2-role-of-cep","title":"2. Role of CEP","text":"<p>CEP provides neutral, JSON-first constructs that describe:</p> <ul> <li>Entities - people, organizations, agencies, programs, vendors  </li> <li>Relationships - membership, jurisdiction, oversight, affiliation  </li> <li>Exchanges - filings, permits, tenders, responses, amendments, reports</li> </ul> <p>CEP acts as a transport layer, allowing domain-specific schemas (e.g., OCDS, state grant systems) to be expressed in a common shape and combined across silos.</p> <p>CEP does not attempt to redefine deep domain ontologies. Its value is structural consistency and cross-domain interoperability.</p>"},{"location":"en/concepts/positioning-paper/#3-role-of-ctags","title":"3. Role of CTags","text":"<p>CTags provide per-artifact context:</p> <ul> <li>what the content is  </li> <li>who created or modified it  </li> <li>what transformations occurred (OCR, summarization, redaction, modeling)  </li> <li>which policies applied  </li> <li>what source(s) it derived from</li> </ul> <p>Where CEP handles structured civic records, CTags handle the documents and messages that move through civic processes.</p> <p>In an AI-rich environment, CTags help establish:</p> <ul> <li>chain of custody  </li> <li>reproducibility  </li> <li>auditability  </li> <li>trustworthiness</li> </ul> <p>CTags can be used independently but become dramatically more powerful when linked to CEP entities and exchanges.</p>"},{"location":"en/concepts/positioning-paper/#4-alignment-with-existing-standards","title":"4. Alignment with Existing Standards","text":"<p>Civic Interconnect is intentionally non-competitive with existing civic standards:</p> <ul> <li>CEP entities may reference OCD Division IDs for jurisdictions.  </li> <li>CEP relationships may align with Popolo people/organization structures.  </li> <li>CEP exchanges may wrap OCDS contracting lifecycle documents.  </li> <li>CTags may map to W3C PROV concepts for semantic-web compatibility.</li> </ul> <p>Each standard continues doing what it does best. CEP and CTags provide the missing glue.</p>"},{"location":"en/concepts/positioning-paper/#5-why-this-matters","title":"5. Why This Matters","text":"<p>The civic ecosystem is facing three converging pressures:</p> <ol> <li>AI integration - automated agents increasingly summarize, classify, route, and transform civic information.  </li> <li>Fragmented vendor landscapes - public records, procurement, grants, meetings, and reporting systems rarely interoperate.  </li> <li>Transparency expectations - journalists, auditors, and the public need sourceable, auditable, machine-readable records.</li> </ol> <p>CEP and CTags offer a minimal, intuitive, and extensible way to satisfy these pressures without imposing heavy ontologies or requiring system rewrites.</p>"},{"location":"en/concepts/positioning-paper/#6-conclusion","title":"6. Conclusion","text":"<p>The Civic Interconnect framework is a small set of primitives designed to connect everything else:</p> <ul> <li>CEP: the cross-domain record structure  </li> <li>CTags: the provenance header  </li> <li>Existing standards: the authoritative domain models  </li> </ul> <p>This positioning enables the civic community to build interoperable, transparent, AI-ready systems that scale from small rural governments to national datasets - without displacing established standards or workflows.</p>"},{"location":"en/concepts/related-domains/","title":"Related Research Domains","text":"<p>This standard operates at the intersection of three major, yet often separate, academic research domains:  - Formal Entity Resolution (CS),  - Campaign Finance/Policy Analysis (Political Science), and - Global Data Standards (Information Systems).</p>"},{"location":"en/concepts/related-domains/#prior-work-entity-resolution-data-standards-and-civic-transparency","title":"Prior Work: Entity Resolution, Data Standards, and Civic Transparency","text":"<p>This standard advances the state-of-the-art by bridging the gap between three distinct bodies of work: high-fidelity entity resolution, policy-driven data harmonization, and the development of open standards for public accountability.</p>"},{"location":"en/concepts/related-domains/#1-entity-resolution-and-data-quality-methodology","title":"1. Entity Resolution and Data Quality Methodology","text":"<p>Research in Entity Resolution (ER), also known as record linkage or deduplication, has been a cornerstone of computer science and database theory.</p> <p>Carnegie Mellon University (CMU) has contributed foundational work in formalizing the ER problem, such as the ENRES framework, which provides a semantic model to represent and relate various ER research models. This work highlights the crucial need for formal reasoning and explicit assumptions regarding entities and their references, which directly informs our Category Theory approach. Other CMU-related research has addressed Generic Entity Resolution with Data Confidences, underscoring the necessity of associating numerical confidence with merged records, a feature we implement via the Splink-generated confidence_score.</p> <p>The computational methodology behind our implementation relies heavily on advancements in probabilistic record linkage, particularly the Fellegi-Sunter model, which allows for high-accuracy linking of data without labeled training sets, critical for messy public data. The use of the open-source Splink library (pioneered outside academia and rigorously validated) represents a pragmatic, scalable implementation of these probabilistic principles.</p>"},{"location":"en/concepts/related-domains/#2-campaign-finance-and-policy-data-standardization","title":"2. Campaign Finance and Policy Data Standardization","text":"<p>A parallel track of research has focused on the application of computational methods to clean and analyze fragmented political data.</p> <p>Stanford University's DIME (Database on Ideology, Money in Politics, and Elections) Project exemplifies the effort to centralize and standardize complex political contributions data. DIME has assigned unique identifiers for millions of individual and organizational donors, candidates, and political committees across federal and state elections. This established the value proposition for a persistent, standardized identifier in the campaign finance domain.</p> <p>The University of Chicago MS in Computational Analysis and Public Policy (MSCAPP) and Stanford's Computational Public Policy programs have emphasized the necessary skills, including machine learning, big data, and computational analysis required to address policy issues like public procurement and campaign finance. These programs underscore the academic recognition that robust data infrastructure is the prerequisite for rigorous policy analysis.</p> <p>While these efforts successfully resolve entities within their domain (e.g., within campaign finance), they often use internal, proprietary identifiers that do not readily link to entities in the public procurement or grant domains, creating siloed transparency.</p>"},{"location":"en/concepts/related-domains/#3-open-data-interoperability-and-global-standards","title":"3. Open Data, Interoperability, and Global Standards","text":"<p>The third body of work defines the principles of modern data governance and standardization.</p> <p>Massachusetts Institute of Technology (MIT), through its Research Data Principles, champions the need for researchers to manage data actively and avoid acquiring or generating data that restricts future use and sharing. This principle of \"open by default\" and \"designed for reuse\" informs the design of the our open-source standard and its reliance on the non-proprietary SNFEI.</p> <p>Organizations supporting the Open Data Charter emphasize that data must be comparable and interoperable to enhance governance and accountability. This reflects the global demand for cross-sectoral standards. The existing Legal Entity Identifier (LEI) standard provides the template for a globally harmonized system in the financial sector.</p>"},{"location":"en/concepts/related-domains/#novelty-and-contribution-of-this-standard","title":"Novelty and Contribution of this Standard","text":"<p>This project is novel in three key ways:</p> <ul> <li> <p>Compositional Rigor: We model the civic exchange system as a Category, using Category Theory to formally prove that the SNFEI acts as the Universal Property (Limit) that unifies all messy civic records, helping to guarantee the standard's structural integrity and extensibility.</p> </li> <li> <p>Tiered, Extensible Identity: We address sub-federal identities by explicitly creating the SNFEI (Tier 3) as an open-source bridge to the global LEI (Tier 1) and federal UEI (Tier 2).</p> </li> <li> <p>The Provenance Tag: We enforce a Compositional Provenance Tag that structurally records the Morphism Type (GRANT, CONTRACT_FEE) and the entity hierarchy, enabling automated tracing of the entire funding chain, which goes beyond simple entity deduplication.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/","title":"Research Adoption Landscape","text":"<p>This document outlines how major research communities are likely to view Civic Interconnect (CI) and the Civic Exchange Protocol (CEP). It summarizes why each community might engage, where skepticism might arise, and how CI positions itself for constructive collaboration.</p>"},{"location":"en/concepts/research-adoption/#1-entity-resolution-computer-science-database-theory","title":"1. Entity Resolution (Computer Science / Database Theory)","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage","title":"Why They Might Engage","text":"<ul> <li> <p>Formal Foundations (Category Theory)   CI/CEP models a civic identity system using categorical constructs, where SNFEI behaves like a universal property (a limit over normalized attributes).   This directly addresses a core CS challenge: entity resolution without ad-hoc heuristics.</p> </li> <li> <p>Tiered Identity Architecture   SNFEI (Tier 3) provides a scalable open identity layer that links up to LEI (Tier 1) and SAM UEI (Tier 2).   This multi-tier architecture matches the complexity seen in large, real-world ER problems.</p> </li> <li> <p>Confidence Scoring Integration   The explicit <code>confidenceScore</code> parallels CMU work on data confidence, uncertainty propagation, and probabilistic entity matching.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>Application Rather Than Breakthrough   ER researchers may consider CI's methods to be an application of known techniques (e.g., Splink-style blocking, Fellegi\u2013Sunter logic) rather than a novel algorithm.</p> </li> <li> <p>Governance and Longevity Concerns   They may worry whether CI/CEP will be maintained long-term or become another abandoned identity standard.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement","title":"Engagement","text":"<ul> <li>CI will publish a formal specification of the SNFEI functor, universal property, and resolution logic.  </li> <li>CI will provide benchmark datasets comparing SNFEI performance to LEI/UEI-style inference.  </li> <li>CI is open to collaborating on probabilistic confidence scoring research and error propagation.</li> </ul>"},{"location":"en/concepts/research-adoption/#2-campaign-finance-policy-analysis-political-science","title":"2. Campaign Finance &amp; Policy Analysis (Political Science)","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage_1","title":"Why They Might Engage","text":"<ul> <li>Cross-Domain Linking   Policy researchers excel at analyzing campaign finance data within their silo, but may lack cross-silo tools to connect it to:  </li> <li>procurement  </li> <li>lobbying  </li> <li>nonprofit contributions  </li> <li>grants and contracts  </li> </ul> <p>CEP's <code>EntityRecord</code>, <code>RelationshipRecord</code>, and <code>ExchangeRecord</code> directly enable funding-chain analysis across sectors.</p> <ul> <li>Automated Funding Path Tracing   CTags describing morphism types (GRANT, CONTRACT_FEE, DONATION, PASS-THROUGH, etc.) make automated tracing auditable and reproducible.</li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical_1","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>Loss of Domain-Specific Detail   CEP acts as a structural transport layer. Policy analysts often need extremely granular attributes (committee type, election cycle).   They may worry CI \"abstracts away\" detail.</p> </li> <li> <p>Existing Internal ID Systems   Groups like DIME already maintain elaborate proprietary IDs.   They may ask: Why adopt another ID system until everyone else does?</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement_1","title":"Engagement","text":"<ul> <li>CI provides CEP's interconnect strategy - it does not replace domain standards, it links them.  </li> <li>CI provides worked examples showing how a campaign finance ID maps to SNFEI and survives joining across datasets.  </li> <li>CI develops a Funding Flow Linkage Script demo using Relationships, Exchanges, and CTags.</li> </ul>"},{"location":"en/concepts/research-adoption/#3-open-data-interoperability-global-standards","title":"3. Open Data / Interoperability / Global Standards","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage_2","title":"Why They Might Engage","text":"<ul> <li> <p>Strong Alignment with Open Data Principles   CEP is vendor-neutral, open-source, and schema-driven.   It aligns with the Open Data Charter, W3C PROV, and MIT's research data interoperability frameworks.</p> </li> <li> <p>Explicit Provenance &amp; Trust Layer   The envelope's attestations, timestamps, and CTags are directly relevant to modern data governance, AI transparency, and auditability.</p> </li> <li> <p>Extensible Schema Architecture   CEP's use of <code>$ref</code>, <code>allOf</code>, controlled vocabularies, and stable URIs matches best practices in international standards efforts.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical_2","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>No Global Mandate (Yet)   LEI succeeded because the G20 mandated it.   CEP does not have a regulatory or institutional mandate, making adoption voluntary.</p> </li> <li> <p>Complexity Cost   The envelope structure is comprehensive.   Standards bodies may ask whether the complexity is appropriate for small jurisdictions or lightweight open-data platforms.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement_2","title":"Engagement","text":"<ul> <li>CI provides profiles (minimal subsets) of CEP for lightweight use cases.  </li> <li>CI publishes machine-readable vocabularies following W3C best practices.  </li> <li>CI will define and publish a CEP Lite profile schema (e.g., cep.lite.entity.schema.json) that limits required fields to the absolute minimum (e.g., only verifiableId, recordKind, legalName, jurisdictionIso). This directly addresses the Complexity Cost concern for lightweight platforms.</li> <li>CI will ensure all vocabularies and schemas adhere to W3C best practices (stable URIs, versioning) and that the Attestation model provides a direct path to W3C PROV and Verifiable Credentials compliance.</li> </ul>"},{"location":"en/concepts/research-adoption/#summary-table","title":"Summary Table","text":"Research Community Possible Incentives Possible Concerns CI Contributions Entity Resolution Formal categorical model, canonical identity layer Not a novel algorithm, governance concerns Publish formal proof, provide benchmarks Policy / Campaign Finance Cross-silo linking, automated flow tracing Loss of granularity, existing IDs Show mappings, demos, wrappers Open Data Standards Interoperability, provenance, extensibility No mandate, perceived complexity Provide profiles, pilots, vocabularies"},{"location":"en/concepts/unified-rewriting/","title":"CEP as a Unified Rewriting Framework","text":"<p>CEP (Civic Exchange Protocol) is built on the idea that civic data integration can be understood as a family of rewriting systems glued together by a shared category-theoretic backbone. Instead of treating canonicalization, adapters, graphs, and identity resolution as separate ad-hoc mechanisms, CEP treats them as layers of typed, strategy-governed rewrites.</p> <p>This document explains how the major CEP specifications fit together as a unified rewriting framework.</p>"},{"location":"en/concepts/unified-rewriting/#1-layers-of-rewriting-in-cep","title":"1. Layers of Rewriting in CEP","text":"<p>CEP operates at several semantic layers:</p> <ol> <li>String-level rewriting </li> <li>Normalizing names, codes, abbreviations, and text fields.  </li> <li> <p>Handled by the canonicalization pipeline in conjunction with vocabularies.</p> </li> <li> <p>Record-level rewriting (adapters) </p> </li> <li>Mapping source-specific records into CEP domain schemas and core entities.  </li> <li> <p>Handled by the Adapter Algebra Specification (AAS).</p> </li> <li> <p>Identity-level rewriting (fingerprints) </p> </li> <li>Selecting minimal identity-defining features and constructing stable      fingerprints and verifiable IDs.  </li> <li> <p>Handled by the Entity Fingerprint Specification (EFS).</p> </li> <li> <p>Graph-level rewriting (normalization and merges) </p> </li> <li>Normalizing provenance and entity graphs into canonical forms.  </li> <li> <p>Handled by the Graph Normalization Specification (GNS).</p> </li> <li> <p>Cluster-level rewriting (identity resolution) </p> </li> <li>Merging entities into cross-domain identity clusters based on rule-based      evidence.  </li> <li>Handled by the Cross-Domain Identity Resolution Algorithm (CDIRA).</li> </ol> <p>Each layer is a rewriting system with its own objects, morphisms, and strategies, but all share the same design principles:</p> <ul> <li>determinism  </li> <li>explicit strategy (not implicit commutativity)  </li> <li>clear versioning  </li> <li>explicit provenance  </li> </ul>"},{"location":"en/concepts/unified-rewriting/#2-strategy-governed-rewriting-not-everything-commutes","title":"2. Strategy-Governed Rewriting (Not \u201cEverything Commutes\u201d)","text":"<p>In many practical systems, rewriting rules do not commute:</p> <ul> <li>Expanding \u201cS.A.\u201d into a French corporate form must happen before punctuation   removal, or the pattern disappears.</li> <li>Mapping legacy codes onto controlled vocabularies must happen before schema   validation.</li> <li>Merging records must happen after identifiers and names have been   canonicalized.</li> </ul> <p>CEP does not claim that all rewrite rules can be applied in arbitrary order. Instead, it adopts stratified, strategy-governed rewriting:</p> <ul> <li>Within a stratum (e.g., semantic expansions, then structural simplifications),   rules are associative and confluent on their domain.</li> <li>Across strata, CEP fixes a global evaluation order to preserve meaning.</li> </ul> <p>This mirrors established practice in compilers, NLP pipelines, Unicode normalization, and term-rewriting systems: correctness depends on strategy, not on naive commutativity.</p>"},{"location":"en/concepts/unified-rewriting/#3-core-specifications-in-the-framework","title":"3. Core Specifications in the Framework","text":"<p>The unified framework is realized through a small set of core specifications:</p>"},{"location":"en/concepts/unified-rewriting/#31-canonical-encoding-cec-v1","title":"3.1 Canonical Encoding (CEC v1)","text":"<p>CEC defines a deterministic JSON-level encoding:</p> <ul> <li>lexicographic key ordering  </li> <li>null omission rules  </li> <li>numeric normalization  </li> <li>Unicode NFC  </li> <li>stable list handling  </li> </ul> <p>CEC is the last step before hashing and ensures that semantically identical structures produce identical byte sequences.</p>"},{"location":"en/concepts/unified-rewriting/#32-entity-fingerprints-efs-v1","title":"3.2 Entity Fingerprints (EFS v1)","text":"<p>EFS defines minimal identity:</p> <ul> <li>canonical identifiers (e.g., SNFEI, registry IDs)  </li> <li>canonical names  </li> <li>optional jurisdiction context  </li> </ul> <p>Fingerprints exclude descriptive attributes such as address or status. They are serialized via CEC and hashed to produce <code>verifiableId</code>.</p>"},{"location":"en/concepts/unified-rewriting/#33-adapter-algebra-aas-v1","title":"3.3 Adapter Algebra (AAS v1)","text":"<p>Adapters are typed rewriting morphisms between schemas:</p> <ul> <li>objects: <code>(schemaId, schemaVersion)</code> </li> <li>morphisms: deterministic (possibly partial) adapters  </li> <li>composition: associative function composition  </li> <li>identities: validation-only adapters <code>id_S : S \u2192 S</code></li> </ul> <p>Adapters form the backbone of CEP pipelines from raw sources to core entities and envelopes.</p>"},{"location":"en/concepts/unified-rewriting/#34-graph-normalization-gns-v1","title":"3.4 Graph Normalization (GNS v1)","text":"<p>GNS treats CEP graphs as objects to be normalized:</p> <ul> <li>entity nodes use <code>verifiableId</code> as canonical IDs  </li> <li>non-entity nodes receive canonical local IDs derived from their payload and   incident edges  </li> <li>nodes and edges are sorted deterministically  </li> <li>the result is serialized with CEC and can be hashed for graph-level tags</li> </ul> <p>This ensures that equivalent provenance or entity graphs collapse to the same canonical form.</p>"},{"location":"en/concepts/unified-rewriting/#35-global-integrity-constraints-gic-v1","title":"3.5 Global Integrity Constraints (GIC v1)","text":"<p>GIC defines system-wide invariants:</p> <ul> <li>unique and stable <code>verifiableId</code> per entity  </li> <li>referential integrity for relationships  </li> <li>DAG structure for provenance  </li> <li>idempotent normalization  </li> <li>completeness and temporal coherence of provenance  </li> </ul> <p>These constraints prevent silent corruption and non-deterministic behavior.</p>"},{"location":"en/concepts/unified-rewriting/#36-versioning-governance-vgs-v1","title":"3.6 Versioning Governance (VGS v1)","text":"<p>VGS defines independent semantic versioning for:</p> <ul> <li>CEC  </li> <li>EFS  </li> <li>GNS  </li> <li>Schemas  </li> <li>Vocabularies  </li> <li>Adapters  </li> </ul> <p>Every record carries a version tuple, ensuring that any hashed object can be reinterpreted and revalidated in the future.</p>"},{"location":"en/concepts/unified-rewriting/#37-cross-domain-identity-resolution-cdira-v1","title":"3.7 Cross-Domain Identity Resolution (CDIRA v1)","text":"<p>CDIRA defines a deterministic clustering algorithm:</p> <ul> <li>strong, moderate, and weak evidence  </li> <li>rule-based merge decisions  </li> <li>conflict records when evidence disagrees  </li> <li>cluster identifiers derived from member IDs and versions  </li> </ul> <p>This extends the rewriting perspective to cross-domain identity graphs.</p>"},{"location":"en/concepts/unified-rewriting/#4-category-theoretic-perspective","title":"4. Category-Theoretic Perspective","text":"<p>At a high level, CEP can be viewed as a category (or family of categories) where:</p> <ul> <li>Objects are:</li> <li>schemas and schema versions  </li> <li>graphs (entity/provenance)  </li> <li> <p>identity clusters  </p> </li> <li> <p>Morphisms are:</p> </li> <li>adapters (record-level rewrites)  </li> <li>normalization functions (string-level, graph-level)  </li> <li>cluster merges (identity-level rewrites)</li> </ul> <p>Rewriting systems at each layer are connected via functor-like mappings:</p> <ul> <li>string rewriting feeds into record schemas,  </li> <li>record rewriting feeds into graph construction,  </li> <li>graph-normalized entities feed into identity resolution.</li> </ul> <p>The important point is not the specific categorical formalism, but the fact that CEP treats all of these as typed, compositional morphisms with explicit strategies, rather than unrelated ad-hoc scripts.</p>"},{"location":"en/concepts/unified-rewriting/#5-adding-a-new-domain-as-a-rewriting-testbed","title":"5. Adding a New Domain as a Rewriting Testbed","text":"<p>When CEP is extended to a new domain (e.g., campaign finance, environmental regulation, education), that domain is integrated by defining:</p> <ol> <li>Domain vocabularies </li> <li> <p>entity types, relationship types, codes, statuses.</p> </li> <li> <p>Canonicalization rules for domain-specific strings </p> </li> <li> <p>names, codes, abbreviations, units.</p> </li> <li> <p>Domain schemas </p> </li> <li> <p>entity and relationship records, with required fields and types.</p> </li> <li> <p>Adapters </p> </li> <li>source-specific \u2192 domain schema  </li> <li> <p>domain schema \u2192 core CEP entities/relationships</p> </li> <li> <p>Graph patterns and provenance requirements </p> </li> <li>how filings, permits, inspections, or programs connect to entities.</li> </ol> <p>The unified rewriting framework guarantees that:</p> <ul> <li>canonicalization behaves consistently,  </li> <li>fingerprints and verifiable IDs behave consistently,  </li> <li>graphs normalize consistently,  </li> <li>identity resolution works the same way across domains,  </li> <li>hashes are stable and interpretable over time.</li> </ul> <p>Domains differ in their vocabularies and schemas, not in the foundational mechanics of rewriting and normalization.</p>"},{"location":"en/concepts/unified-rewriting/#6-summary","title":"6. Summary","text":"<p>CEP is not just a collection of schemas and APIs. It is a unified rewriting framework in which:</p> <ul> <li>strings, records, graphs, and identity clusters are all normalized via   deterministic, strategy-governed rewrites;</li> <li>canonical encoding, fingerprints, graphs, and adapters share a consistent   versioning and provenance model;</li> <li>new domains can be added by plugging into the same rewriting architecture.</li> </ul> <p>This framework is what allows CEP to support long-lived, verifiable, and composable civic data across many heterogeneous domains.</p>"},{"location":"en/examples/","title":"CEP Examples: How to Read and Reproduce Them","text":"<p>The CEP repository includes many example records demonstrating the complete entity and relationship pipeline. This page describes how all examples are structured, what each file represents, and how the Rust + Python toolchain produces the final attested CEP record.</p> <p>Each specific example page (e.g., a municipality, nonprofit, PAC, or contractor) includes only the details unique to that case. This file is the canonical reference for the example pipeline.</p>"},{"location":"en/examples/#directory-structure-of-an-example","title":"Directory Structure of an Example","text":"<p>Every example follows the same four-stage layout:</p> <pre><code>01_raw_source.json    = raw input from an upstream system\n02_normalized.json    = adapter-normalized form (NormalizedEntityInput)\n03_canonical.json     = canonicalized form (Normalizing Functor)\n04_entity_record.json = final EntityRecord from the Rust builder\n</code></pre> <p>For relationship or exchange examples, the fourth file will be a <code>RelationshipRecord</code> or <code>ExchangeRecord</code>, but the pipeline stages remain the same.</p>"},{"location":"en/examples/#stage-1-raw-source-normalized-input","title":"Stage 1 \u2014 Raw Source \u2192 Normalized Input","text":"<p>The adapter reads <code>01_raw_source.json</code> and produces <code>02_normalized.json</code>.</p> <p>Normalization ensures:</p> <ul> <li>consistent Unicode handling  </li> <li>consistent whitespace and punctuation cleanup  </li> <li>deterministic field names  </li> <li>structured jurisdiction and entity-type fields  </li> <li>extraction of identifier inputs (e.g., SNFEI, SAM.gov, state vendor IDs)</li> </ul> <p>Normalization is implemented in Python using shared utilities from <code>cep_py</code>.</p>"},{"location":"en/examples/#stage-2-normalized-input-canonical-input","title":"Stage 2 \u2014 Normalized Input \u2192 Canonical Input","text":"<p>The canonicalization stage applies the normalizing functor implemented in Rust (<code>cep_core</code>) and exposed through Python.</p> <p>Canonicalization:</p> <ul> <li>orders fields deterministically  </li> <li>converts complex structures into canonical hash-preimage form  </li> <li>produces a stable <code>to_hash_string()</code> representation</li> </ul> <p>Any two semantically identical civic records must canonicalize to the same string.</p>"},{"location":"en/examples/#stage-3-canonical-input-verifiable-id","title":"Stage 3 \u2014 Canonical Input \u2192 Verifiable ID","text":"<p>From the canonical string, the Rust core computes the Verifiable ID.</p> <p>For entities, this may use:</p> <ul> <li>SNFEI (SHA-256 based)  </li> <li>OR a multi-identifier universal construction  </li> <li>OR a future identifier system  </li> </ul> <p>The Verifiable ID serves as the stable identity of the entity across all revisions.</p> <p>If the example includes additional identifiers, they are incorporated into the <code>identifiers[]</code> block.</p>"},{"location":"en/examples/#stage-4-build-the-final-record-rust-builder","title":"Stage 4 \u2014 Build the Final Record (Rust Builder)","text":"<p>In the final stage, Python calls into the Rust <code>cep_core</code> builder:</p> <pre><code>from cep_py import build_entity_json\nrecord = build_entity_json(normalized_input)\n</code></pre> <p>The builder:</p> <ol> <li>Confirms or computes the Verifiable ID  </li> <li>Creates or extends the non-destructive revision chain </li> <li>Computes <code>recordHash</code> and <code>previousRecordHash</code> </li> <li>Fills required envelope fields (status, timestamps, jurisdiction, type)  </li> <li>Generates a cryptographic attestation using the configured keys</li> </ol> <p>This produces <code>04_entity_record.json</code>.</p> <p>If a prior revision exists, a new one is added without overwriting history.</p>"},{"location":"en/examples/#how-cep-invariants-appear-in-examples","title":"How CEP Invariants Appear in Examples","text":"<p>All examples share these foundational guarantees:</p>"},{"location":"en/examples/#verifiable-id-as-a-universal-construction","title":"Verifiable ID as a Universal Construction","text":"<p>Identity is derived canonically and remains stable across revisions.</p>"},{"location":"en/examples/#non-destructive-revision-chain","title":"Non-Destructive Revision Chain","text":"<p>Every new build creates a new revision linked by <code>previousRecordHash</code>.</p>"},{"location":"en/examples/#immutable-provenance","title":"Immutable Provenance","text":"<p>Hashes guarantee that revision history cannot be altered without detection.</p>"},{"location":"en/examples/#cryptographic-attestation","title":"Cryptographic Attestation","text":"<p>Records are attested using independent keys; verification does not depend on trusting any hosting service.</p>"},{"location":"en/examples/#distributed-verification-implicit","title":"Distributed Verification (implicit)","text":"<p>Examples can be validated locally, offline, or in distributed environments.</p>"},{"location":"en/examples/#regenerating-any-example","title":"Regenerating Any Example","text":"<p>From the repository root:</p> <pre><code>uv run cx generate-example --path examples/.../&lt;example-folder&gt;/\n</code></pre> <p>Or run manually:</p> <pre><code>from cep_py import (\n    normalize_entity_input,\n    canonicalize_entity_input,\n    compute_verifiable_id,\n    build_entity_json,\n)\n</code></pre> <p>(Examples may use <code>compute_snfei</code> or other identifier constructors depending on the schema version.)</p>"},{"location":"en/examples/#template-for-example-specific-pages","title":"Template for Example-Specific Pages","text":"<p>Each example page should include:</p> <pre><code># Example: &lt;Name&gt;\n\n**Purpose:** (What this example highlights \u2014 unique bits only)\n\n**Files:**\n- 01_raw_source.json\n- 02_normalized.json\n- 03_canonical.json\n- 04_entity_record.json\n\n**Highlights:**\n- Unique identifiers\n- Special normalization rules\n- Unusual entityType or jurisdiction\n- Notes on revision history (if multiple revisions)\n\n**Link back to this page:**\nSee [How CEP Examples Work](../README.md) for the full pipeline description.\n</code></pre> <p>This keeps example pages small and consistent.</p>"},{"location":"en/examples/#where-to-find-example-definitions","title":"Where to Find Example Definitions","text":"<p>Examples live under:</p> <pre><code>examples/\n    entity/\n    relationship/\n    exchange/\n</code></pre> <p>Each example folder includes its own markdown page and the four pipeline files.</p> <p>This page is the authoritative description of how CEP examples work. All example pages link back here for more complete information.</p>"},{"location":"en/examples/entity-with-snfei/","title":"Example: CEP EntityRecord with SNFEI","text":"<p>This example demonstrates how a CEP <code>EntityRecord</code> includes a Structured Non-Fungible Entity Identifier (SNFEI) when an entity does not have a national or global registry ID (such as LEI or SAM-UEI). SNFEI provides a deterministic, recomputable identifier for joining datasets across civic, nonprofit, educational, and local-government domains.</p>"},{"location":"en/examples/entity-with-snfei/#input-normalized-entity-payload","title":"Input (Normalized Entity Payload)","text":"<p>This is the minimal normalized payload an adapter or ETL process would emit:</p> <pre><code>{\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"Example School District 123\",\n    \"legalNameNormalized\": \"example school district 123\",\n    \"snfei\": \"34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\",\n    \"entityType\": \"educational-institution\"\n}\n</code></pre> <p>The SNFEI here is the SHA-256 hash of:</p> <pre><code>normalized legal name + jurisdiction\nexample school district 123 + us-mn\n</code></pre>"},{"location":"en/examples/entity-with-snfei/#output-cep-entityrecord","title":"Output (CEP EntityRecord)","text":"<p>After running this normalized input through the CEP builder, the resulting <code>EntityRecord</code> looks like this:</p> <pre><code>{\n    \"recordKind\": \"entity\",\n    \"recordSchemaUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.entity.schema.json\",\n    \"schemaVersion\": \"1.0.0\",\n    \"revisionNumber\": 1,\n\n    \"verifiableId\": \"cep-entity:snfei:34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\",\n    \"recordTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-type.json#educational-institution\",\n\n    \"status\": {\n        \"statusCode\": \"ACTIVE\",\n        \"statusEffectiveDate\": \"1900-01-01\"\n    },\n\n    \"timestamps\": {\n        \"firstSeenAt\": \"1900-01-01T00:00:00.000000Z\",\n        \"lastUpdatedAt\": \"1900-01-01T00:00:00.000000Z\",\n        \"validFrom\": \"1900-01-01T00:00:00.000000Z\"\n    },\n\n    \"attestations\": [\n        {\n            \"attestationTimestamp\": \"1900-01-01T00:00:00.000000Z\",\n            \"attestorId\": \"cep-entity:example:ingest\",\n            \"verificationMethodUri\": \"urn:cep:attestor:cep-entity:example:ingest\",\n            \"proofType\": \"ManualAttestation\",\n            \"proofPurpose\": \"assertionMethod\"\n        }\n    ],\n\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"Example School District 123\",\n    \"legalNameNormalized\": \"example school district 123\",\n\n    \"identifiers\": [\n        {\n            \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-identifier-scheme.v1.0.0.json#snfei\",\n            \"identifier\": \"34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\"\n        }\n    ]\n}\n</code></pre>"},{"location":"en/examples/entity-with-snfei/#key-points","title":"Key Points","text":""},{"location":"en/examples/entity-with-snfei/#deterministic-id","title":"Deterministic ID","text":"<p>The <code>verifiableId</code> incorporates the SNFEI value to create a stable, recomputable entity identifier:</p> <pre><code>cep-entity:snfei:&lt;hash&gt;\n</code></pre>"},{"location":"en/examples/entity-with-snfei/#vocabulary-backed-identifier-scheme","title":"Vocabulary-backed Identifier Scheme","text":"<p>The SNFEI entry references the official vocabulary term:</p> <pre><code>https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-identifier-scheme.v1.0.0.json#snfei\n</code></pre> <p>This ensures consistent identifier semantics across systems.</p>"},{"location":"en/examples/entity-with-snfei/#minimal-but-complete-envelope","title":"Minimal but Complete Envelope","text":"<p>Even in a minimal example, CEP includes:</p> <ul> <li>envelope metadata (<code>recordKind</code>, <code>schemaVersion</code>)</li> <li>timestamps</li> <li>a default attestation block</li> <li>status envelope</li> </ul>"},{"location":"en/examples/entity-with-snfei/#when-to-use-snfei","title":"When to Use SNFEI","text":"<p>Use SNFEI when:</p> <ul> <li>an entity lacks LEI, SAM-UEI, or other authoritative identifiers,</li> <li>datasets need a stable join key,</li> <li>building civic registries,</li> <li>integrating multiple heterogeneous data sources.</li> </ul> <p>SNFEI is a deterministic, transparent identifier that enables cross-dataset linkage without a central registry.</p>"},{"location":"en/examples/entities/municipality/us_il_01/","title":"Example: Municipality Entity (US-IL 01)","text":"<p>This example demonstrates a basic CEP EntityRecord for a municipality in Illinois. It uses the standard four-stage CEP example pipeline described in How CEP Examples Work.</p> <p>Directory:</p> <pre><code>examples/entity/municipality/us_il_01/\n</code></pre> <p>Files:</p> <pre><code>01_raw_source.json\n02_normalized.json\n03_canonical.json\n04_entity_record.json\n</code></pre>"},{"location":"en/examples/entities/municipality/us_il_01/#highlights-of-this-example","title":"Highlights of This Example","text":"<p>What is unique about this particular example:</p> <ul> <li>Demonstrates a minimal viable municipality record.</li> <li>Uses SNFEI as the sole identifier input for constructing the <code>verifiableId</code>.</li> <li>Shows normalization of a plain-text municipal name into a canonical form.</li> <li>Displays the default entity type mapping for municipalities.</li> <li>Includes a single revision (no prior history).</li> </ul> <p>For all pipeline details (normalization \u2192 canonicalization \u2192 identifier construction \u2192 record building), see the master page: How CEP Examples Work.</p>"},{"location":"en/examples/entities/municipality/us_il_01/#pipeline-notes-specific-to-this-example","title":"Pipeline Notes (Specific to This Example)","text":""},{"location":"en/examples/entities/municipality/us_il_01/#normalization-02","title":"Normalization (02)","text":"<p>The adapter extracts:</p> <ul> <li><code>jurisdictionIso: \"US-IL\"</code></li> <li><code>legalName</code> and <code>legalNameNormalized</code></li> <li><code>entityType: municipality</code></li> <li>SNFEI preimage fields (used to generate the hash)</li> </ul> <p>Nothing unusual is required for this example \u2014 Illinois municipalities follow the default normalization pattern.</p>"},{"location":"en/examples/entities/municipality/us_il_01/#canonicalization-03","title":"Canonicalization (03)","text":"<p>The canonical representation includes:</p> <ul> <li>normalized name  </li> <li>jurisdiction code  </li> <li>entity type  </li> <li>deterministic field ordering  </li> </ul> <p>This example canonicalizes cleanly with no special transformations.</p>"},{"location":"en/examples/entities/municipality/us_il_01/#verifiable-id-snfei","title":"Verifiable ID (SNFEI)","text":"<p>SNFEI is computed via:</p> <pre><code>SHA256( canonical.to_hash_string() )\n</code></pre> <p>The resulting value populates:</p> <ul> <li><code>verifiableId = \"cep-entity:snfei:&lt;hash&gt;\"</code></li> <li>an entry in <code>identifiers[]</code> using the SNFEI identifier scheme.</li> </ul> <p>(Example SNFEI value is shown inside the final record.)</p>"},{"location":"en/examples/entities/municipality/us_il_01/#final-entityrecord-04","title":"Final EntityRecord (04)","text":"<p>The Rust builder (<code>build_entity_json</code>) produces:</p> <ul> <li>envelope metadata (status, timestamps)  </li> <li><code>recordHash</code> and <code>previousRecordHash</code> (none for first revision)  </li> <li>cryptographic attestation  </li> <li>canonical <code>entityTypeUri</code> and identifier scheme references  </li> </ul>"},{"location":"en/examples/entities/municipality/us_il_01/#regenerating-this-example","title":"Regenerating This Example","text":"<p>From the repo root:</p> <pre><code>uv run cx generate-example --path examples/entity/municipality/us_il_01/\n</code></pre> <p>Or run the steps manually:</p> <pre><code>from cep_py import build_entity_json\n\nentity_record = build_entity_json(normalized_json)\n</code></pre>"},{"location":"en/examples/entities/municipality/us_il_01/#related-documentation","title":"Related Documentation","text":"<ul> <li>Identifier Schemes </li> <li>Entity Specification </li> <li>Normalization &amp; SNFEI</li> </ul>"},{"location":"en/examples/entities/municipality/us_il_01/#example-files","title":"Example Files","text":"<ul> <li><code>01_raw_source.json</code></li> <li><code>02_normalized.json</code></li> <li><code>03_canonical.json</code></li> <li><code>04_entity_record.json</code></li> </ul>"},{"location":"en/examples/entities/municipality/us_mn_01/","title":"Example: Municipality Entity (US-MN 01)","text":"<p>This example demonstrates a basic CEP EntityRecord for a municipality in Minnesota. It follows the standard four-stage CEP example pipeline described in How CEP Examples Work.</p> <p>Directory:</p> <pre><code>examples/entity/municipality/us_mn_01/\n</code></pre> <p>Files:</p> <pre><code>01_raw_source.json\n02_normalized.json\n03_canonical.json\n04_entity_record.json\n</code></pre>"},{"location":"en/examples/entities/municipality/us_mn_01/#highlights-of-this-example","title":"Highlights of This Example","text":"<p>This example illustrates Minnesota-specific details:</p> <ul> <li>Shows a minimal viable municipality using SNFEI as the identifier input.</li> <li>Demonstrates normalization of a Minnesota municipal name.</li> <li>Applies the standard <code>municipality</code> entityTypeUri.</li> <li>Contains a single revision with no prior history.</li> <li>Follows the canonical CEP entity pipeline with no special adapter rules.</li> </ul> <p>See the master documentation for details of normalization, canonicalization, SNFEI construction, and the Rust builder: How CEP Examples Work.</p>"},{"location":"en/examples/entities/municipality/us_mn_01/#pipeline-notes-specific-to-this-example","title":"Pipeline Notes (Specific to This Example)","text":""},{"location":"en/examples/entities/municipality/us_mn_01/#normalization-02","title":"Normalization (02)","text":"<p>The adapter extracts common core fields:</p> <ul> <li><code>jurisdictionIso: \"US-MN\"</code></li> <li><code>legalName</code></li> <li><code>legalNameNormalized</code></li> <li><code>entityType: municipality</code></li> <li>SNFEI preimage components</li> </ul> <p>Minnesota municipalities typically have clean name formatting, so no special tokenization or alias handling was required.</p>"},{"location":"en/examples/entities/municipality/us_mn_01/#canonicalization-03","title":"Canonicalization (03)","text":"<p>The canonical form contains:</p> <ul> <li>normalized name  </li> <li>Minnesota jurisdiction code  </li> <li>entity type  </li> <li>deterministically ordered fields  </li> </ul> <p>The input canonicalizes without additional preprocessing.</p>"},{"location":"en/examples/entities/municipality/us_mn_01/#verifiable-id-snfei","title":"Verifiable ID (SNFEI)","text":"<p>SNFEI is calculated as:</p> <pre><code>SHA256( canonical.to_hash_string() )\n</code></pre> <p>This value:</p> <ul> <li>populates the <code>verifiableId</code>, and  </li> <li>appears in the <code>identifiers[]</code> array using the SNFEI identifier scheme.</li> </ul>"},{"location":"en/examples/entities/municipality/us_mn_01/#final-entityrecord-04","title":"Final EntityRecord (04)","text":"<p>The Rust builder (<code>build_entity_json</code>) produces:</p> <ul> <li>a complete CEP EntityRecord  </li> <li>default <code>status</code> and <code>statusEffectiveDate</code> </li> <li>revision metadata (<code>revisionNumber</code>, <code>recordHash</code>)  </li> <li>a cryptographic attestation  </li> <li>canonical URIs for identifier scheme and entity type  </li> </ul>"},{"location":"en/examples/entities/municipality/us_mn_01/#regenerating-this-example","title":"Regenerating This Example","text":"<p>From the repository root:</p> <pre><code>uv run cx generate-example --path examples/entity/municipality/us_mn_01/\n</code></pre> <p>Or run the steps manually:</p> <pre><code>from cep_py import build_entity_json\nentity_record = build_entity_json(normalized_json)\n</code></pre>"},{"location":"en/examples/entities/municipality/us_mn_01/#related-documentation","title":"Related Documentation","text":"<ul> <li>Identifier Schemes </li> <li>Entity Specification </li> <li>Normalization &amp; SNFEI</li> </ul>"},{"location":"en/examples/entities/municipality/us_mn_01/#example-files","title":"Example Files","text":"<ul> <li><code>01_raw_source.json</code></li> <li><code>02_normalized.json</code></li> <li><code>03_canonical.json</code></li> <li><code>04_entity_record.json</code></li> </ul>"},{"location":"en/examples/entities/nonprofit/us_ma_01/","title":"Example: Nonprofit Entity (US-MA 01)","text":"<p>This example demonstrates a CEP EntityRecord for a nonprofit organization based in Massachusetts. It uses the standard four-stage CEP example pipeline described in How CEP Examples Work.</p> <p>Directory:</p> <pre><code>examples/entity/nonprofit/us_ma_01/\n</code></pre> <p>Files:</p> <pre><code>01_raw_source.json\n02_normalized.json\n03_canonical.json\n04_entity_record.json\n</code></pre>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#highlights-of-this-example","title":"Highlights of This Example","text":"<p>This example illustrates nonprofit-specific details:</p> <ul> <li>Shows CEP\u2019s handling of nonprofit legal names and their normalized variants.</li> <li>Demonstrates how a nonprofit\u2019s identifier inputs feed into SNFEI-based identity.</li> <li>Applies the nonprofit <code>entityTypeUri</code>.</li> <li>Contains a simple first-revision record with no amendment history.</li> <li>Displays how minimal upstream data can still produce a valid, attested CEP EntityRecord.</li> </ul> <p>For a full explanation of each pipeline stage, see How CEP Examples Work.</p>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#pipeline-notes-specific-to-this-example","title":"Pipeline Notes (Specific to This Example)","text":""},{"location":"en/examples/entities/nonprofit/us_ma_01/#normalization-02","title":"Normalization (02)","text":"<p>The adapter extracts and standardizes:</p> <ul> <li><code>jurisdictionIso: \"US-MA\"</code></li> <li><code>legalName</code> </li> <li><code>legalNameNormalized</code> </li> <li><code>entityType: nonprofit</code></li> <li>SNFEI preimage inputs</li> </ul> <p>Massachusetts nonprofit names often include punctuation, abbreviations (e.g., \u201cInc.\u201d), or suffixes; the normalizer removes or reduces these deterministically.</p>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#canonicalization-03","title":"Canonicalization (03)","text":"<p>The canonical form includes:</p> <ul> <li>normalized legal name  </li> <li>Massachusetts jurisdiction code  </li> <li>nonprofit entity type  </li> <li>deterministically ordered fields  </li> </ul> <p>This example requires no special locale-specific adjustments.</p>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#verifiable-id-snfei","title":"Verifiable ID (SNFEI)","text":"<p>SNFEI is calculated via:</p> <pre><code>SHA256( canonical.to_hash_string() )\n</code></pre> <p>The value is used:</p> <ul> <li>as the basis of <code>verifiableId</code>, and  </li> <li>as an entry in <code>identifiers[]</code> using the SNFEI identifier scheme.</li> </ul>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#final-entityrecord-04","title":"Final EntityRecord (04)","text":"<p>The Rust builder (<code>build_entity_json</code>) constructs:</p> <ul> <li>the canonical EntityRecord  </li> <li><code>status</code> and <code>statusEffectiveDate</code></li> <li><code>recordHash</code> and the first-revision <code>revisionNumber</code> </li> <li>a cryptographic attestation  </li> <li>structured URI references for entity type and identifier scheme  </li> </ul>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#regenerating-this-example","title":"Regenerating This Example","text":"<p>From the repository root:</p> <pre><code>uv run cx generate-example --path examples/entity/nonprofit/us_ma_01/\n</code></pre> <p>Or manually:</p> <pre><code>from cep_py import build_entity_json\nentity_record = build_entity_json(normalized_json)\n</code></pre>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#related-documentation","title":"Related Documentation","text":"<ul> <li>Identifier Schemes </li> <li>Entity Specification </li> <li>Normalization &amp; SNFEI</li> </ul>"},{"location":"en/examples/entities/nonprofit/us_ma_01/#example-files","title":"Example Files","text":"<ul> <li><code>01_raw_source.json</code> </li> <li><code>02_normalized.json</code> </li> <li><code>03_canonical.json</code> </li> <li><code>04_entity_record.json</code></li> </ul>"},{"location":"en/examples/entities/pac/pac_01/","title":"Example: PAC Entity (pac_01)","text":"<p>This example demonstrates a CEP EntityRecord for a Political Action Committee (PAC). It follows the standard four-stage CEP example pipeline described in How CEP Examples Work.</p> <p>Directory:</p> <pre><code>examples/entity/pac/pac_01/\n</code></pre> <p>Files:</p> <pre><code>01_raw_source.json\n02_normalized.json\n03_canonical.json\n04_entity_record.json\n</code></pre>"},{"location":"en/examples/entities/pac/pac_01/#highlights-of-this-example","title":"Highlights of This Example","text":"<p>This example demonstrates PAC-specific characteristics:</p> <ul> <li>Shows normalization of PAC names, which often include financial or campaign-specific suffixes.</li> <li>Illustrates how identifier inputs (e.g., state or federal PAC IDs) contribute to the SNFEI preimage.</li> <li>Applies the <code>pac</code> <code>entityTypeUri</code>.</li> <li>Demonstrates that even highly varied upstream PAC filings normalize into a stable canonical representation.</li> <li>Contains a first-revision EntityRecord with no amendment history.</li> </ul> <p>For a complete explanation of each pipeline stage, see How CEP Examples Work.</p>"},{"location":"en/examples/entities/pac/pac_01/#pipeline-notes-specific-to-this-example","title":"Pipeline Notes (Specific to This Example)","text":""},{"location":"en/examples/entities/pac/pac_01/#normalization-02","title":"Normalization (02)","text":"<p>The adapter extracts:</p> <ul> <li><code>jurisdictionIso</code></li> <li><code>legalName</code></li> <li><code>legalNameNormalized</code></li> <li><code>entityType: pac</code></li> <li>SNFEI preimage components (sometimes including federal or state PAC identifiers)</li> </ul> <p>PAC names often contain uppercase acronyms, campaign references, and punctuation; the normalizer handles these deterministically.</p>"},{"location":"en/examples/entities/pac/pac_01/#canonicalization-03","title":"Canonicalization (03)","text":"<p>The canonical form includes:</p> <ul> <li>normalized PAC name  </li> <li>jurisdiction code  </li> <li>entity type  </li> <li>deterministically ordered fields  </li> </ul> <p>PACs sometimes have complex or lengthy names, but canonicalization treats them uniformly.</p>"},{"location":"en/examples/entities/pac/pac_01/#verifiable-id-snfei","title":"Verifiable ID (SNFEI)","text":"<p>SNFEI is computed via:</p> <pre><code>SHA256( canonical.to_hash_string() )\n</code></pre> <p>The resulting SNFEI:</p> <ul> <li>forms the <code>verifiableId</code>, and  </li> <li>appears in the <code>identifiers[]</code> array under the SNFEI identifier scheme.</li> </ul>"},{"location":"en/examples/entities/pac/pac_01/#final-entityrecord-04","title":"Final EntityRecord (04)","text":"<p>The Rust builder (<code>build_entity_json</code>) produces:</p> <ul> <li>the complete EntityRecord  </li> <li>default <code>status</code> and <code>statusEffectiveDate</code></li> <li>revision metadata (<code>revisionNumber</code>, <code>recordHash</code>)</li> <li>a cryptographic attestation</li> <li>canonical URIs for PAC entity type and SNFEI identifier scheme  </li> </ul>"},{"location":"en/examples/entities/pac/pac_01/#regenerating-this-example","title":"Regenerating This Example","text":"<p>From the repository root:</p> <pre><code>uv run cx generate-example --path examples/entity/pac/pac_01/\n</code></pre> <p>Or manually:</p> <pre><code>from cep_py import build_entity_json\nentity_record = build_entity_json(normalized_json)\n</code></pre>"},{"location":"en/examples/entities/pac/pac_01/#related-documentation","title":"Related Documentation","text":"<ul> <li>Identifier Schemes </li> <li>Entity Specification </li> <li>Normalization &amp; SNFEI</li> </ul>"},{"location":"en/examples/entities/pac/pac_01/#example-files","title":"Example Files","text":"<ul> <li><code>01_raw_source.json</code> </li> <li><code>02_normalized.json</code> </li> <li><code>03_canonical.json</code> </li> <li><code>04_entity_record.json</code></li> </ul>"},{"location":"en/governance/cep-foundational-principles/","title":"CEP Foundational Principles","text":"<p>This document identifies the foundational architectural invariants required for the Civic Exchange Protocol (CEP) to function as a deterministic, compositional, and verifiable system across diverse civic domains.</p>"},{"location":"en/governance/cep-foundational-principles/#1-canonical-serialization-cec","title":"1. Canonical Serialization (CEC)","text":"<p>CEP requires a stable, deterministic canonical encoding for all entities, relationships, and exchanges. This includes:</p> <ul> <li>key ordering</li> <li>omission rules for null/empty fields</li> <li>Unicode normalization</li> <li>numeric normalization</li> <li>canonical list ordering</li> <li>no ambiguity in datatype representation</li> </ul> <p>CEC is mandatory for hashing, deduplication, and cross-system verification.</p>"},{"location":"en/governance/cep-foundational-principles/#2-cross-domain-entity-identity","title":"2. Cross-Domain Entity Identity","text":"<p>All domains must support a common identity model grounded in:</p> <ul> <li>minimal identity-defining attributes</li> <li>domain-agnostic fingerprint rules</li> <li>deterministic merge semantics</li> <li>stable identifier construction</li> </ul> <p>Identity must be consistent across campaigns, environment, education, municipalities, nonprofits, etc.</p>"},{"location":"en/governance/cep-foundational-principles/#3-graph-level-normalization","title":"3. Graph-Level Normalization","text":"<p>Provenance, merges, and entity graphs must have:</p> <ul> <li>canonical ordering of edges</li> <li>deterministic blank-node labeling</li> <li>merge strategy determinism</li> <li>recursion guards during rewriting</li> </ul> <p>This ensures stable cross-domain provenance and reproducible entity histories.</p>"},{"location":"en/governance/cep-foundational-principles/#4-vocabulary-and-schema-versioning","title":"4. Vocabulary and Schema Versioning","text":"<p>CEP vocabularies evolve. Therefore:</p> <ul> <li>each vocabulary entry MUST define a stable URI</li> <li>deprecated terms are never reused</li> <li>canonicalization must state vocabulary version</li> <li>adapters must declare the vocab version they target</li> </ul> <p>Versioning is part of the trust model.</p>"},{"location":"en/governance/cep-foundational-principles/#5-adapter-algebra","title":"5. Adapter Algebra","text":"<p>Adapters form a category of typed rewriting morphisms:</p> <ul> <li>each adapter has a domain and codomain schema</li> <li>composition must be well-defined and deterministic</li> <li>identity adapters must exist for each schema version</li> <li>adapters MUST document partiality (when they can fail)</li> </ul> <p>CEP interoperability relies on predictable adapter composition.</p>"},{"location":"en/governance/cep-foundational-principles/#6-global-integrity-constraints","title":"6. Global Integrity Constraints","text":"<p>All domains must adhere to:</p> <ul> <li>unique verifiable IDs</li> <li>referential integrity for entity relationships</li> <li>attestation timestamps \u2265 dependency timestamps</li> <li>symmetry/antisymmetry rules for relationships as needed</li> </ul> <p>These constraints prevent inconsistent or unverifiable data.</p>"},{"location":"en/governance/cep-foundational-principles/#7-security-and-attestation","title":"7. Security and Attestation","text":"<p>Every CTag (cryptographic tag) must:</p> <ul> <li>commit to a canonical serialization (CEC)</li> <li>state the vocabulary version</li> <li>state the adapter version</li> <li>include attestation metadata</li> <li>guard against canonicalization confusion</li> </ul> <p>Security is inseparable from canonicalization.</p>"},{"location":"en/governance/cep-foundational-principles/#8-minimal-feature-set-for-unique-identification","title":"8. Minimal Feature Set for Unique Identification","text":"<p>Across all domains CEP defines:</p> <ul> <li>minimal identity-defining attributes</li> <li>additional non-identity metadata</li> <li>optional descriptive context</li> </ul> <p>Identity must be explicit and separable from metadata.</p>"},{"location":"en/governance/cep-foundational-principles/#summary","title":"Summary","text":"<p>These eight principles are the architectural backbone of CEP. They define the minimal mathematical and engineering structure necessary for CEP to function as a unified, multi-domain rewriting system supporting canonicalization, hashing, provenance, and exchange.</p>"},{"location":"en/governance/evolution-policy-and-versioning/","title":"Standard Evolution Policy and Versioning","text":"<p>This policy defines the process, requirements, and responsibilities for introducing changes to the Protocol.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#1-versioning-system","title":"1. Versioning System","text":"<p>The standard utilizes Semantic Versioning (MAJOR.MINOR.PATCH). The version number applies to the entire monorepo and its core protocol requirements.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#11-major-version-change-x00","title":"1.1 MAJOR Version Change (X.0.0)","text":"<p>A MAJOR change is reserved for non-backwards-compatible modifications that require all certified nodes to update their serialization logic, otherwise, they will lose hash parity.</p> Change Type Impact Example Data Type Change Changing a field type (e.g., transactionAmount from number to string). Field Order Change Modifying the CANONICAL_FIELD_ORDER. Cryptographic Change Switching from SHA-256 to a new algorithm (e.g., SHA-384). Mandatory Field Addition Adding a new field to the required list in the JSON Schema. <p>Requirement: Requires unanimous approval from the Interconnect Standards Board (ISB) and a mandatory 6-month deprecation period.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#12-minor-version-change-0x0","title":"1.2 MINOR Version Change (0.X.0)","text":"<p>A MINOR change is a backwards-compatible modification that adds new functionality or optional fields. Existing certified nodes maintain hash parity, but new nodes may need to account for new optional data.</p> Change Type Impact Example Optional Field Addition Adding a new field to the end of the CANONICAL_FIELD_ORDER (which is omitted if null). Adding funding_source_project_id (optional). Enum Value Addition Adding a new value to an existing enum (e.g., adding TEMPORARILY_SUSPENDED to transactionStatus). Tooling Upgrade Significant upgrade to the build system (build.sh or testing dependencies). <p>Requirement: Requires simple majority approval from the ISB (2 out of 3 votes).</p>"},{"location":"en/governance/evolution-policy-and-versioning/#13-patch-version-change-00x","title":"1.3 PATCH Version Change (0.0.X)","text":"<p>A PATCH change is a small, fully backwards-compatible correction to documentation, tooling, or non-protocol code.</p> Change Type Impact Example Documentation Fix Correcting a typo in the Governance Charter. Test Data Update Adding a new test vector to /test_data that uses only existing fields. Non-Core Bug Fix Fixing a non-critical bug in a reference implementation's example code. <p>Requirement: Can be approved by the ISB Chair alone.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#2-change-submission-and-review-cycle","title":"2. Change Submission and Review Cycle","text":"<ol> <li> <p>Proposal Submission: The contributor submits a Pull Request (PR) against the main branch.</p> </li> <li> <p>Versioning Assignment: The ISB Chair assigns the PR a tentative version bump (MAJOR, MINOR, or PATCH) based on Section 1.</p> </li> <li> <p>ISB Review and Vote: The ISB reviews the proposal (focusing on need and impact) and votes according to the requirement for the assigned version type.</p> </li> <li> <p>Hash Parity Enforcement: Once the vote passes, the PR is merged, and the automated CI system executes the build.sh script to confirm 100% hash parity across all five certified languages (Python, Rust, Java, C#, TypeScript). No release can occur until 100% parity is confirmed.</p> </li> <li> <p>Release: The new version is tagged, and all certified node operators are notified.</p> </li> </ol>"},{"location":"en/governance/objectives-and-vision/","title":"Objectives and Vision","text":"<p>The Civic Exchange Protocol (CEP) is designed to support incremental integration today and strategic planning without requiring architectural changes. The core philosophy is simple:</p> <ul> <li>Optimize for low-cost, low-friction adoption.</li> <li>Provide cryptographic integrity without requiring blockchain.</li> <li>Support regulatory harmonization across jurisdictions.</li> <li>Preserve openness, interoperability, and vendor neutrality.</li> </ul> <p>At its core, CEP ensures that the same payload always yields the same canonical hash, providing a universal identity and attestation mechanism that can span civic, financial, and administrative systems.</p>"},{"location":"en/governance/objectives-and-vision/#1-objectives","title":"1. Objectives","text":""},{"location":"en/governance/objectives-and-vision/#11-lower-the-cost-of-adoption","title":"1.1 Lower the Cost of Adoption","text":"<p>Most public-sector technology initiatives fail due to the cost and complexity of onboarding. CEP minimizes this by:</p> <ul> <li>Requiring only JSON + SHA-256 + a canonical string rule.</li> <li>Avoiding specialized infrastructure (no distributed ledger, no proprietary middleware).</li> <li>Allowing any language, platform, or agency to participate.</li> <li>Transparency by default: schemas and vocabularies are openly published.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#12-decentralized-provenance-without-blockchain","title":"1.2 Decentralized Provenance Without Blockchain","text":"<p>Unlike blockchain-based solutions, CEP:</p> <ul> <li>Requires no consensus algorithm.</li> <li>Does not impose token economics or distributed nodes.</li> <li>Uses a cryptographically linked attestation chain (previousRecordHash), providing tamper evidence at a fraction of the cost.</li> </ul> <p>This provides a cryptographic audit trail suitable for public-sector systems where full decentralization is either unnecessary or impractical.</p>"},{"location":"en/governance/objectives-and-vision/#13-cost-effective-regulatory-compliance","title":"1.3 Cost-Effective Regulatory Compliance","text":"<p>CEP is designed to satisfy emerging demands in:</p> <ul> <li>Transparency and anti-corruption policy  </li> <li>Cross-jurisdiction financial tracking  </li> <li>Federal reporting (XBRL, GTAS)  </li> <li>Global financial identity standards (UEI, LEI)</li> </ul> <p>By structuring the data model around canonical identifiers, provenance, and hash-bound attestations, CEP can adapt naturally to future regulatory frameworks and programmatic audit requirements.</p>"},{"location":"en/governance/objectives-and-vision/#2-vision","title":"2. Vision","text":"<p>The Civic Exchange Protocol is deliberately designed so that incremental adoption today will not conflict with expected future requirements.</p> <p>Possible evolution includes:</p> <ul> <li>National or state-level directives requiring provenance tagging for grant, contract, or procurement systems.</li> <li>Standardization bodies adopting CEP as a formal schema for intergovernmental reporting.</li> <li>Regulatory requirements for immutable audit trails for public money flows.</li> <li>International harmonization with LEI, XBRL, HSDS, PROV, Popolo, or other standards.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#3-voluntary-integration-vs-possible-future-requirements-matrix","title":"3. Voluntary Integration vs. Possible Future Requirements Matrix","text":"<p>This matrix outlines the anticipated pathway from voluntary use to potential regulatory mandate. The protocol is built to operate seamlessly in both contexts.</p> Aspect Current Voluntary Integration Possible Future Requirements Authority Interconnect Standards Board (ISB) governs versions, vocabularies, and hash rules. Department of Governance and Exchange (DOGE) as regulatory authority for compliance and enforcement. Access Policy Peer-to-peer agreements between participating entities. Standardized Digital Roles and Permissions (SDRP), federally or globally recognized. Public Data Best practice for transparency. Agencies may decide which data to publish. Mandatory global disclosures for specific categories (e.g., grants, contracts, campaign finance). Integrity Proof Entity Hash and canonical string provide voluntary integrity guarantee. Same Entity Hash meets any required SSOT-proof for compliance and audits. <p>CEP ensures that the same proof mechanism works in both cases, with no need for new cryptographic infrastructure should mandated requirements arrive.</p>"},{"location":"en/governance/objectives-and-vision/#4-future-proof-architecture","title":"4. Future-Proof Architecture","text":"<p>CEP is explicitly designed to:</p> <ul> <li>Scale from a few adopters to wider integration.</li> <li>Allow community-driven vocabulary evolution.</li> <li>Support new jurisdictions, formats, and regulatory requirements without schema breakage.</li> <li>Provide a secure, verifiable, and interoperable foundation for multi-sector data exchange.</li> </ul> <p>The vision is an interoperable civic identity and provenance network, offering incremental integration and compatibility with existing systems.</p>"},{"location":"en/governance/objectives-and-vision/#5-stewardship-and-sustainability","title":"5. Stewardship and Sustainability","text":"<p>Sustainability of the ecosystem emphasizes:</p> <ul> <li>Open governance via the Interconnect Standards Board  </li> <li>Versioning discipline to protect downstream adopters  </li> <li>Long-term archival guarantees through schema versioning and stable URIs  </li> <li>Transparency and accountability in vocabulary evolution, attestation practices, and protocol changes  </li> </ul> <p>CEP is designed to be maintainable, publicly governed, and aligned with global interoperability principles.</p>"},{"location":"en/governance/vocabulary-process/","title":"Vocabulary Governance Process","text":"<p>This document defines how controlled vocabularies in the Civic Exchange Protocol (CEP) are created, reviewed, versioned, and published. CEP vocabularies include:</p> <ul> <li><code>entity-type</code></li> <li><code>relationship-type</code></li> <li><code>exchange-type</code></li> <li><code>exchange-role</code></li> <li><code>party-role</code></li> <li><code>identifier-scheme</code></li> <li><code>source-system</code></li> <li><code>resolution-method</code></li> <li><code>value-type</code></li> </ul> <p>These vocabularies provide the stable semantic backbone for CEP interoperability across government systems, academic research, and third-party implementations.</p>"},{"location":"en/governance/vocabulary-process/#1-purpose-of-vocabularies","title":"1. Purpose of Vocabularies","text":"<p>CEP vocabularies serve three critical functions:</p> <ol> <li> <p>Interoperability:    Terms map to external standards (Popolo, Open Civic Data, OCDS, HSDS, Schema.org, XBRL, W3C PROV).</p> </li> <li> <p>Semantic Stability:    Terms provide canonical meaning for entity types, role types, relationship types, exchange types, etc.</p> </li> <li> <p>Verifiable Behavior:    Terms are referenced in canonical URI form inside attested CEP records, affecting hash parity and revision integrity.</p> </li> </ol>"},{"location":"en/governance/vocabulary-process/#2-versioning","title":"2. Versioning","text":"<p>Vocabulary files follow independent semantic versioning:</p> <p><code>&lt;name&gt;.vMAJOR.MINOR.PATCH.json</code></p> <p>Examples:  </p> <pre><code>entity-type.v1.0.0.json\nidentifier-scheme.v1.0.0.json\n</code></pre>"},{"location":"en/governance/vocabulary-process/#21-major","title":"2.1 MAJOR","text":"<p>Changes that break compatibility or reinterpret existing terms: - renaming or removing terms - redefining meanings - altering term URIs - significant structural changes</p> <p>Requires unanimous ISB approval + 6-month deprecation period.</p>"},{"location":"en/governance/vocabulary-process/#22-minor","title":"2.2 MINOR","text":"<p>Backward-compatible enhancements: - adding new terms - adding new mappings - adding optional properties</p> <p>Requires simple majority vote.</p>"},{"location":"en/governance/vocabulary-process/#23-patch","title":"2.3 PATCH","text":"<p>No semantic change: - fixing typos - adding external references in <code>seeAlso</code> - clarifying descriptions</p> <p>May be approved by ISB Chair alone.</p>"},{"location":"en/governance/vocabulary-process/#3-adding-updating-or-deprecating-terms","title":"3. Adding, Updating, or Deprecating Terms","text":"<p>All vocabulary modifications follow this structured workflow:</p>"},{"location":"en/governance/vocabulary-process/#step-1-proposal-submission","title":"Step 1 \u2014 Proposal Submission","text":"<p>A contributor submits a PR that includes: - updated vocabulary file - accompanying rationale - impact assessment on interoperability - references to external standards (if relevant)</p>"},{"location":"en/governance/vocabulary-process/#step-2-technical-review","title":"Step 2 \u2014 Technical Review","text":"<p>The Interconnect Standards Board (ISB) reviews: - term clarity and definition - hierarchy (<code>parentTermUri</code>) - mappings to external standards (SKOS-style) - URI stability - potential namespace collisions - hash-parity implications</p>"},{"location":"en/governance/vocabulary-process/#step-3-vote","title":"Step 3 \u2014 Vote","text":"<p>Version bump category determines voting requirements (Section 2).</p>"},{"location":"en/governance/vocabulary-process/#step-4-merge-release","title":"Step 4 \u2014 Merge &amp; Release","text":"<p>Upon approval: - CI validates JSON format, unique URIs, and mapping integrity - The vocabulary is merged into <code>main</code> - A new tag is created:</p> <p><code>vocab/&lt;name&gt;/vMAJOR.MINOR.PATCH</code></p>"},{"location":"en/governance/vocabulary-process/#step-5-deprecation-notices","title":"Step 5 \u2014 Deprecation Notices","text":"<p>If a term becomes deprecated: - it is retained with <code>\"status\": \"deprecated\"</code> - <code>\"deprecationNote\"</code> must point to its replacement - canonical JSON schemas continue accepting it unless a MAJOR bump occurs</p>"},{"location":"en/governance/vocabulary-process/#4-design-principles-for-vocabulary-terms","title":"4. Design Principles for Vocabulary Terms","text":""},{"location":"en/governance/vocabulary-process/#41-term-uris-must-be-globally-stable","title":"4.1 Term URIs MUST be globally stable","text":"<p>URIs never change after publication.</p>"},{"location":"en/governance/vocabulary-process/#42-labels-are-human-friendly-codes-are-machine-friendly","title":"4.2 Labels are human-friendly; codes are machine-friendly","text":"<p>Examples: - code: <code>prime-contract</code> - label: <code>Prime Contract</code></p>"},{"location":"en/governance/vocabulary-process/#43-definitions-must-be-unambiguous","title":"4.3 Definitions MUST be unambiguous","text":"<p>Definitions MUST avoid jurisdiction-specific assumptions unless explicitly scoped.</p>"},{"location":"en/governance/vocabulary-process/#44-hierarchies-should-be-used-where-meaningful","title":"4.4 Hierarchies SHOULD be used where meaningful","text":"<p>Example: - <code>subgrant</code> \u2192 parent: <code>grant-award</code> - <code>subcontract</code> \u2192 parent: <code>prime-contract</code></p>"},{"location":"en/governance/vocabulary-process/#45-external-mappings-should-be-included","title":"4.5 External mappings SHOULD be included","text":"<p>Supported mapping types: <code>exactMatch</code>, <code>broadMatch</code>, <code>narrowMatch</code>, <code>relatedMatch</code>.</p>"},{"location":"en/governance/vocabulary-process/#5-file-placement-and-structure","title":"5. File Placement and Structure","text":"<p>All vocabulary files live under <code>vocabularies/</code>.</p> <p>Each file follows the canonical <code>cep.vocabulary.schema.json</code>.</p>"},{"location":"en/governance/vocabulary-process/#6-lifecycle-summary","title":"6. Lifecycle Summary","text":"Stage Description Output Proposal Contributor suggests new/updated term Pull Request Review ISB evaluates definition + mappings Comments Vote Approve/reject based on version category Decision Release Publish new vocabulary version New <code>vX.Y.Z</code> tag Deprecation Old terms marked deprecated Maintained until next MAJOR"},{"location":"en/governance/vocabulary-process/#7-guiding-objective","title":"7. Guiding Objective","text":"<p>The primary objective of CEP vocabulary governance is to stabilize meaning, maximize interoperability, and ensure backward compatibility while allowing the ecosystem to grow with new policy types, relationship structures, data standards, and domain models.</p>"},{"location":"en/implementation/casing/","title":"Use Correct Casing","text":""},{"location":"en/implementation/casing/#golden-rule","title":"Golden Rule","text":"<ul> <li>External JSON (schemas + records) use camelCase.</li> <li>Internal code (Rust/Python) uses snake_case + explicit mapping.</li> </ul> <p>Everything hangs off that:</p> <ul> <li>JSON Schemas: legalName, legalNameNormalized, statusEffectiveDate</li> <li>JSON instances: same as schema</li> <li>Rust / Python names: legal_name, legal_name_normalized, status_effective_date</li> </ul> <p>Rust bridges via #[serde(rename_all = \"camelCase\")] (or explicit rename), Python passes dicts whose keys are camelCase while variables stay snake_case.</p>"},{"location":"en/implementation/casing/#rules-by-layer","title":"Rules by Layer","text":"<p>JSON Schema and JSON records</p> <p>Required:</p> <ul> <li>Property names: camelCase</li> <li>legalName, legalNameNormalized, statusEffectiveDate, firstSeenAt</li> <li>Enum values:</li> <li>Use SCREAMING_SNAKE_CASE where they represent codes (e.g. ACTIVE, INACTIVE).</li> <li>$defs object keys: camelCase or lowerCamelCase (your choice, but consistent).</li> <li>No snake_case in public JSON unless it is an external standard we are mirroring (document any exceptions).</li> </ul>"},{"location":"en/implementation/casing/#rust","title":"Rust","text":"<p>For types that serialize to JSON:</p> <ul> <li>Struct names: PascalCase: EntityRecord, StatusEnvelope, CanonicalTimestamp.</li> <li>Field names: snake_case and always decorated with serde to map to camelCase</li> <li>Enum names: PascalCase; variants: PascalCase; #[serde(rename_all = \"SCREAMING_SNAKE_CASE\")] when they are code-ish</li> <li>Internal-only types that never serialize to JSON can be pure Rust style without serde.</li> </ul>"},{"location":"en/implementation/casing/#python","title":"Python","text":"<ul> <li>Module / function / variable names: snake_case.</li> <li>Dataclasses: snake_case attributes, but any dict intended to go over the wire must use camelCase keys matching the schema, even though Python variables are snake_case, e.g.jurisdiction_iso.</li> </ul> <pre><code>normalized_payload: dict[str, Any] = {\n    \"jurisdictionIso\": raw.jurisdiction_iso,\n    \"legalName\": raw.legal_name,\n    \"legalNameNormalized\": normalized_name,\n    \"snfei\": snfei,\n    \"entityType\": \"school_district\",\n}\n</code></pre>"},{"location":"en/implementation/casing/#rules","title":"Rules","text":"<ul> <li>Do not hand-edit generated.rs.</li> <li>If a JSON-facing type is not in generated.rs, it must still use #[serde(rename_all = \"camelCase\")].</li> <li>Ruff/pyright don't know about casing in dict keys, so centralize constants:</li> </ul> <pre><code>LEGAL_NAME = \"legalName\"\nLEGAL_NAME_NORMALIZED = \"legalNameNormalized\"\nJURISDICTION_ISO = \"jurisdictionIso\"\nENTITY_TYPE = \"entityType\"\n\nnormalized_payload = {\n    JURISDICTION_ISO: raw.jurisdiction_iso,\n    LEGAL_NAME: raw.legal_name,\n    LEGAL_NAME_NORMALIZED: normalized_name,\n    \"snfei\": snfei,\n    ENTITY_TYPE: \"school_district\",\n}\n</code></pre>"},{"location":"en/implementation/ctag-integration/","title":"CTag Integration in CEP Record Envelopes","text":"<p>This is provided for implementers of CEP-compliant systems and pipelines.</p>"},{"location":"en/implementation/ctag-integration/#1-purpose","title":"1. Purpose","text":"<p>Context Tags (CTags) are lightweight annotations that attach to a record envelope, not to the internal entity, relationship, or exchange payload.</p> <p>CTags provide interpretive, analytic, or contextual notes that help downstream systems understand how a record is being used, evaluated, or interpreted. They do not affect canonical identity, SNFEI, schema validity, or the meaning of the core data.</p> <p>CTags are:</p> <ul> <li>optional  </li> <li>vocabulary-governed  </li> <li>non-destructive  </li> <li>independent of canonicalization  </li> <li>safe to add, modify, or remove without altering the record\u2019s semantics  </li> </ul> <p>This document defines how CTags integrate with CEP record envelopes.</p>"},{"location":"en/implementation/ctag-integration/#2-record-envelope-overview","title":"2. Record Envelope Overview","text":"<p>All CEP records (entities, relationships, exchanges, p3tags, etc.) share the same envelope structure. The envelope contains:</p> <ul> <li>identity and type information  </li> <li>schema version  </li> <li>lifecycle status  </li> <li>timestamps  </li> <li>attestations  </li> <li>optional ctags </li> </ul> <p>The CTags appear at the envelope level:</p> <pre><code>{\n  \"recordKind\": \"entity\",\n  \"recordSchemaUri\": \"...\",\n  \"schemaVersion\": \"1.0.0\",\n  \"revisionNumber\": 1,\n  \"verifiableId\": \"cep-entity:snfei:...\",\n  \"recordTypeUri\": \"...\",\n  \"status\": { \"...\": \"...\" },\n  \"timestamps\": { \"...\": \"...\" },\n  \"attestations\": [ \"...snip...\" ],\n\n  \"ctags\": [\n    {\n      \"typeUri\": \"https://example.org/vocab/ctag-type#analysis.cluster.membership\",\n      \"value\": \"cluster-12\",\n      \"note\": \"Optional note.\"\n    }\n  ]\n}\n</code></pre> <p>The payload (e.g., entity fields, relationship fields, exchange content) sits beside the envelope fields, not inside CTags.</p>"},{"location":"en/implementation/ctag-integration/#3-why-ctags-live-in-the-envelope","title":"3. Why CTags Live in the Envelope","text":""},{"location":"en/implementation/ctag-integration/#31-separation-of-meaning-vs-interpretation","title":"3.1 Separation of Meaning vs Interpretation","text":"<p>The envelope is the correct location for annotations because:</p> <ul> <li>The payload expresses the factual civic record.</li> <li>The envelope expresses lifecycle context, attestations, and analytic overlays.</li> <li>CTags belong with the latter.</li> </ul> <p>This separation prevents accidental semantic modification of the underlying civic facts.</p>"},{"location":"en/implementation/ctag-integration/#32-safe-for-canonicalization","title":"3.2 Safe for Canonicalization","text":"<p>CTags do not participate in:</p> <ul> <li>normalization  </li> <li>canonical input building  </li> <li>SNFEI hashing or ID derivation  </li> </ul> <p>A record with or without CTags must have the same SNFEI and the same canonical identity.</p> <p>Deterministic pipelines must treat CTags as optional, removable accessories.</p>"},{"location":"en/implementation/ctag-integration/#33-compatible-with-multiple-uses","title":"3.3 Compatible With Multiple Uses","text":"<p>Envelope-level CTags support:</p> <ul> <li>risk flags  </li> <li>data quality indicators  </li> <li>clustering or classification results  </li> <li>editorial highlights  </li> <li>narrative tags used in reports  </li> <li>AI-assisted annotations  </li> </ul> <p>All without polluting the core civic data model.</p>"},{"location":"en/implementation/ctag-integration/#4-ctag-object-structure","title":"4. CTag Object Structure","text":"<p>Each tag references a controlled vocabulary term:</p> <pre><code>{\n  \"typeUri\": \"https://example.org/vocab/ctag-type#quality.issue.incomplete_address\",\n  \"value\": true,\n  \"note\": \"Address missing postal code\"\n}\n</code></pre> <p>Fields:</p> Field Required Description <code>typeUri</code> yes URI of the CTag type from the ctag-type vocabulary <code>value</code> no JSON value (string, boolean, number, object) <code>note</code> no Human-readable explanation <p>Implementations may extend with additional optional fields as long as the vocabulary contract remains intact.</p>"},{"location":"en/implementation/ctag-integration/#5-how-systems-should-use-ctags","title":"5. How Systems Should Use CTags","text":""},{"location":"en/implementation/ctag-integration/#51-ingestion-pipelines","title":"5.1 Ingestion Pipelines","text":"<p>Adapters may add tags such as:</p> <ul> <li>incomplete fields  </li> <li>inconsistent identifiers  </li> <li>address quality issues  </li> </ul> <p>Example:</p> <pre><code>{\n  \"ctags\": [\n    {\n      \"typeUri\": \"https://...#quality.issue.incomplete_address\",\n      \"value\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"en/implementation/ctag-integration/#52-analysis-and-machine-learning-pipelines","title":"5.2 Analysis and Machine Learning Pipelines","text":"<p>Analytic systems may add tags like:</p> <ul> <li>cluster membership  </li> <li>risk classification  </li> <li>anomaly scores  </li> <li>narrative highlights  </li> <li>AI summary categories  </li> </ul> <p>These do not change the core record; they only annotate it.</p> <p>Example:</p> <pre><code>{\n  \"ctags\": [\n    {\n      \"typeUri\": \"https://...#analysis.cluster.membership\",\n      \"value\": \"cluster-7\"\n    },\n    {\n      \"typeUri\": \"https://...#narrative.highlight.key_actor\",\n      \"note\": \"Mentioned in investigative report\"\n    }\n  ]\n}\n</code></pre>"},{"location":"en/implementation/ctag-integration/#53-exchange-and-workflow-systems","title":"5.3 Exchange and Workflow Systems","text":"<p>When a workflow involves document packets, filings, or automated transformations, CTags may indicate:</p> <ul> <li>processing status  </li> <li>triage flags  </li> <li>routing categories  </li> <li>confidence levels from AI models  </li> </ul> <p>Because CTags are non-semantic, they can be applied uniformly across record types.</p>"},{"location":"en/implementation/ctag-integration/#6-validation-rules","title":"6. Validation Rules","text":"<p>A conformant implementation MUST ensure:</p> <ol> <li><code>typeUri</code> is a valid URI and maps to a vocabulary term.  </li> <li>CTags do not modify <code>verifiableId</code>, canonical identity, or payload semantics.  </li> <li><code>value</code> is valid JSON if present.  </li> <li>Adding or removing a CTag must leave the core record unchanged.  </li> <li>CTags must not interfere with schema-required fields.</li> </ol> <p>Best practices:</p> <ul> <li>flag deprecated CTag terms  </li> <li>treat unknown terms as warnings, not fatal errors  </li> <li>keep CTags small and additive  </li> </ul>"},{"location":"en/implementation/ctag-integration/#7-example-entity-record-envelope-with-ctags","title":"7. Example: Entity Record Envelope with CTags","text":"<pre><code>{\n  \"recordKind\": \"entity\",\n  \"recordSchemaUri\": \"https://.../entity.schema.json\",\n  \"schemaVersion\": \"1.0.0\",\n  \"revisionNumber\": 1,\n  \"verifiableId\": \"cep-entity:snfei:...\",\n  \"recordTypeUri\": \"https://...#municipality\",\n  \"status\": { \"statusCode\": \"ACTIVE\", \"statusEffectiveDate\": \"1900-01-01\" },\n  \"timestamps\": { \"firstSeenAt\": \"...\", \"lastUpdatedAt\": \"...\", \"validFrom\": \"...\" },\n  \"attestations\": [ { \"...\": \"...\" } ],\n\n  \"ctags\": [\n    {\n      \"typeUri\": \"https://...#narrative.highlight.key_actor\",\n      \"note\": \"Frequently referenced in planning documents\"\n    }\n  ],\n\n  \"legalName\": \"City of Springfield\",\n  \"jurisdictionIso\": \"US-IL\",\n  \"identifiers\": { \"...\": \"...\" }\n}\n</code></pre>"},{"location":"en/implementation/ctag-integration/#8-summary","title":"8. Summary","text":"<ul> <li>CTags live exclusively in the record envelope, not in core payload structures.  </li> <li>CTags provide non-destructive, optional, vocabulary-driven annotations.  </li> <li>Adding, removing, or modifying CTags does not affect canonicalization or identity.  </li> <li>CTags support analytics, data quality, workflows, and narrative reporting.  </li> <li>CTag infrastructure unifies annotation across all CEP record families.</li> </ul>"},{"location":"en/implementation/implementation-guide/","title":"Implementation Guide","text":"<p>This guide provides a practical overview for developers building Civic Exchange Protocol (CEP) implementations in any language. It complements the formal schemas and the categorical foundations by describing how to validate, construct, serialize, and verify CEP records in a deterministic and interoperable way.</p> <p>CEP defines a stable core specification (CEP-Core). Jurisdictions or systems may optionally adopt additional implementation profiles to support specialized workflows (e.g., AI constraints, legacy onboarding, or extended privacy requirements). Profiles do not alter the core Civic category. For more information, see profiles.md.</p> <p>This implementation guide covers:</p> <ul> <li>how revisions work</li> <li>how to create updates without overwriting</li> <li>what to do about onboarding mistakes</li> <li>how to manage very long chains</li> <li>how to handle bulk imports</li> </ul>"},{"location":"en/implementation/implementation-guide/#technical-assurance","title":"Technical Assurance","text":"<p>CEP ensures technical correctness through two mandatory components:</p>"},{"location":"en/implementation/implementation-guide/#a-the-canonical-string-the-debug-tool","title":"A. The Canonical String (The Debug Tool)","text":"<p>Every implementation must expose a function (e.g., <code>getCanonicalString</code>, <code>to_canonical_string</code>, or <code>generate_canonical_string</code>) that returns the raw, unhashed, deterministic string representation of a CEP record.</p> <ul> <li>Strict field ordering  </li> <li>UTC timestamps with microsecond precision  </li> <li>Deterministic numeric formatting  </li> <li>No locale or OS artifacts  </li> </ul> <p>This is the ground truth for resolving cross-language hash mismatches.</p>"},{"location":"en/implementation/implementation-guide/#b-the-certification-test-suite-the-compliance-gate","title":"B. The Certification Test Suite (The Compliance Gate)","text":"<p>All implementations must pass the cross-language hash-parity suite in <code>/test_vectors</code>.</p> <p>Any system that computes a different SHA-256 hash for a canonical test vector is non-conforming.</p>"},{"location":"en/implementation/implementation-guide/#getting-certified","title":"Getting Certified","text":"<ol> <li>Read <code>/specifications</code>.  </li> <li>Select the implementation folder for your platform (Rust, Python, etc.).  </li> <li>Integrate <code>TransactionRecord</code> and <code>generateValidationHash</code>.  </li> <li>Run tests with <code>/test_vectors</code>.  </li> <li>Use canonical debugging strings to correct mismatch sources.  </li> </ol>"},{"location":"en/implementation/implementation-guide/#logic-organization","title":"Logic Organization","text":"Package Focus Depends On Artifacts core Shared utilities none hashing, canonicalization, timestamps, errors entity Entity records core <code>EntityRecord</code> relationship Bilateral links core, entity <code>RelationshipRecord</code> exchange Flows between entities core, entity, relationship <code>ExchangeRecord</code>"},{"location":"en/implementation/implementation-guide/#1-implementation-goals","title":"1. Implementation Goals","text":"<p>A correct CEP implementation MUST:</p> <ol> <li>Produce canonical JSON matching the schemas  </li> <li>Achieve full hash parity across languages  </li> <li>Verify attestations  </li> <li>Maintain immutable hash-linked revision chains  </li> <li>Support multi-scheme identifiers  </li> <li>Compose provenance deterministically  </li> </ol>"},{"location":"en/implementation/implementation-guide/#2-canonical-serialization","title":"2. Canonical Serialization","text":"<p>CEP uses canonical JSON for:</p> <ul> <li>hash computation  </li> <li>digital signatures  </li> <li>verification  </li> <li>cross-node equality  </li> </ul>"},{"location":"en/implementation/implementation-guide/#21-requirements","title":"2.1 Requirements","text":"<p>Canonical JSON MUST:</p> <ul> <li>Sort all object keys lexicographically  </li> <li>Use UTF-8  </li> <li>Serialize timestamps as UTC with microsecond precision and trailing <code>Z</code> </li> <li>Avoid superfluous whitespace  </li> <li>Use stable ordering inside arrays where applicable  </li> </ul> <p>Example: <code>2025-09-15T14:03:22.500000Z</code></p>"},{"location":"en/implementation/implementation-guide/#22-canonical-field-order","title":"2.2 Canonical Field Order","text":"<p>Field order is enforced via CI and cross-language tests. Any deviation produces a hash mismatch.</p>"},{"location":"en/implementation/implementation-guide/#3-record-model-and-encapsulation-philosophy","title":"3. Record Model and Encapsulation Philosophy","text":"<p>CEP defines record-shaped data, not object-oriented domain objects. The goal is interoperable, predictable, schema-driven structures that behave identically in:</p> <ul> <li>Rust  </li> <li>Python  </li> <li>TypeScript  </li> <li>Java / C#  </li> <li>SQL and NoSQL databases  </li> </ul>"},{"location":"en/implementation/implementation-guide/#31-why-cep-records-use-public-fields","title":"3.1 Why CEP Records Use Public Fields","text":"<p>CEP records are transparent because:</p> <ul> <li>Auditors must inspect them directly  </li> <li>Schemas define their shape exactly  </li> <li>Canonicalization requires predictable visibility  </li> <li>Multi-language parity demands structural simplicity  </li> <li>Hidden or computed fields would break determinism  </li> </ul> <p>Thus CEP avoids private state and getters/setters.</p>"},{"location":"en/implementation/implementation-guide/#32-where-logic-belongs-builders-and-validators","title":"3.2 Where Logic Belongs: Builders and Validators","text":"<p>CEP enforces correctness outside the record struct:</p> <ul> <li>Builders (e.g., <code>EntityBuilder</code>, <code>RelationshipBuilder</code>)  </li> <li>enforce invariants  </li> <li>normalize input  </li> <li>generate identifiers (SNFEI)  </li> <li> <p>ensure field completeness  </p> </li> <li> <p>Validators </p> </li> <li>validate schema compliance  </li> <li>enforce vocabulary correctness  </li> <li>verify signatures  </li> <li> <p>enforce revision chain rules  </p> </li> <li> <p>Canonicalization </p> </li> <li>enforces deterministic ordering  </li> <li>produces canonical strings for hashing  </li> </ul>"},{"location":"en/implementation/implementation-guide/#33-when-methods-are-appropriate","title":"3.3 When Methods Are Appropriate","text":"<p>Methods are acceptable when they:</p> <ul> <li>produce derived values (e.g., <code>canonical_string()</code>)  </li> <li>do not mutate underlying data  </li> <li>increase clarity without altering canonical shape  </li> </ul>"},{"location":"en/implementation/implementation-guide/#34-takeaway","title":"3.4 Takeaway","text":"<p>CEP records are stable public data structures. Builders and validators enforce correctness. Canonicalization enforces determinism. This ensures interoperability, auditability, and future-proof evolution.</p>"},{"location":"en/implementation/implementation-guide/#4-attestation-and-verification","title":"4. Attestation and Verification","text":""},{"location":"en/implementation/implementation-guide/#41-attestation-block","title":"4.1 Attestation Block","text":"<p>Each CEP record includes:</p> <ul> <li><code>attestorId</code> </li> <li><code>attestationTimestamp</code> </li> <li><code>proofType</code> </li> <li><code>proofValue</code> </li> <li><code>verificationMethodUri</code> </li> <li><code>proofPurpose</code> </li> <li><code>anchorUri</code> (optional)  </li> </ul>"},{"location":"en/implementation/implementation-guide/#42-verification-workflow","title":"4.2 Verification Workflow","text":"<ol> <li>Resolve public key from <code>verificationMethodUri</code> </li> <li>Recompute canonical JSON excluding attestation block  </li> <li>Verify signature using <code>proofType</code> </li> <li>Check signature matches the canonical hash  </li> </ol> <p>Failures MUST cause rejection.</p>"},{"location":"en/implementation/implementation-guide/#5-revision-and-hash-chain","title":"5. Revision and Hash Chain","text":""},{"location":"en/implementation/implementation-guide/#51-lifecycle","title":"5.1 Lifecycle","text":"<pre><code>revision 1: previousRecordHash = null\nrevision 2+: previousRecordHash = SHA256(canonical previous)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#52-requirements","title":"5.2 Requirements","text":"<p>Implementations MUST:</p> <ul> <li>Enforce monotonic revision numbers  </li> <li>Reject incorrect previousRecordHash values  </li> <li>Treat any modification as a new revision  </li> </ul> <p>This forms a tamper-evident chain.</p>"},{"location":"en/implementation/implementation-guide/#6-identifier-interoperability","title":"6. Identifier Interoperability","text":"<p>CEP supports:</p> <ul> <li>UEI  </li> <li>LEI  </li> <li>SNFEI  </li> <li>Canadian BN  </li> <li>Additional scheme-based identifiers  </li> </ul>"},{"location":"en/implementation/implementation-guide/#61-best-practices","title":"6.1 Best Practices","text":"<ul> <li>Validate URIs using the identifier-scheme vocabulary  </li> <li>Validate known schemes strictly  </li> <li>Allow unknown schemes if structurally valid  </li> </ul>"},{"location":"en/implementation/implementation-guide/#7-provenance-composition","title":"7. Provenance Composition","text":"<p>Relationships and exchanges form a directed provenance graph.</p> <p>Implementations MUST:</p> <ul> <li>Validate relationship links  </li> <li>Build provenance chains deterministically  </li> <li>Support parent relationships/exchanges  </li> </ul>"},{"location":"en/implementation/implementation-guide/#71-funding-chain-convention","title":"7.1 Funding Chain Convention","text":"<p><code>FEDERAL&gt;STATE&gt;LOCAL</code></p> <p>Segments must be uppercase, separated by <code>&gt;</code>.</p>"},{"location":"en/implementation/implementation-guide/#8-vocabulary-integration","title":"8. Vocabulary Integration","text":"<p>Vocabulary URIs MUST resolve to known terms:</p> <ul> <li>relationship-type  </li> <li>exchange-type  </li> <li>party-role  </li> <li>exchange-role  </li> <li>identifier-scheme  </li> </ul> <p>Implementations SHOULD cache vocabularies locally.</p>"},{"location":"en/implementation/implementation-guide/#9-source-references","title":"9. Source References","text":"<p>Source references link CEP to external datasets.</p> <p>Implementations SHOULD:</p> <ul> <li>validate URI syntax  </li> <li>enforce nonempty IDs  </li> <li>optionally verify URL resolvability  </li> </ul>"},{"location":"en/implementation/implementation-guide/#10-example-implementation-pattern","title":"10. Example Implementation Pattern","text":"<pre><code>load_schemas()\nload_vocabularies()\n\nrecord = parse_input_json()\nvalidate_schema(record)\nvalidate_vocabularies(record)\n\ncanonical = canonicalize_json(record without attestation)\ncheck_revision_chain(canonical, record)\nverify_attestation(canonical, record.attestation)\n\nstore(record)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#11-language-specific-notes","title":"11. Language-Specific Notes","text":""},{"location":"en/implementation/implementation-guide/#python","title":"Python","text":"<p><code>json.dumps(..., separators=(',', ':'), sort_keys=True)</code></p>"},{"location":"en/implementation/implementation-guide/#typescript","title":"TypeScript","text":"<p>Use deterministic-stringify libraries.</p>"},{"location":"en/implementation/implementation-guide/#rust","title":"Rust","text":"<p>Use <code>serde_json::to_writer</code> with sorted maps.</p>"},{"location":"en/implementation/implementation-guide/#java-c","title":"Java / C","text":"<p>Use custom deterministic serializers.</p> <p>All languages MUST yield identical canonical bytes.</p>"},{"location":"en/implementation/implementation-guide/#12-conformance-levels","title":"12. Conformance Levels","text":"Level Meaning Basic Validates schemas + vocabularies Full Validates attestations + revision chains Verifying Node Maintains verified subcategory Authoritative Node Issues new attestations"},{"location":"en/implementation/implementation-guide/#13-revision-mechanics-long-term-operation","title":"13. Revision Mechanics &amp; Long-Term Operation","text":""},{"location":"en/implementation/implementation-guide/#non-destructive-revision-model-practical-implementation","title":"Non-Destructive Revision Model (Practical Implementation)","text":""},{"location":"en/implementation/implementation-guide/#revision-classification-for-error-handling","title":"Revision Classification for Error Handling","text":""},{"location":"en/implementation/implementation-guide/#hash-checkpointing-for-long-chains","title":"Hash-Checkpointing for Long Chains","text":""},{"location":"en/implementation/implementation-guide/#onboarding-legacy-systems-without-violating-invariants","title":"Onboarding Legacy Systems Without Violating Invariants","text":""},{"location":"en/implementation/implementation-guide/#operational-best-practices-for-persisting-large-provenance-graphs","title":"Operational Best Practices for Persisting Large Provenance Graphs","text":""},{"location":"en/implementation/implementation-guide/#summary","title":"Summary","text":"<p>A complete CEP implementation MUST:</p> <p>\u2714 Validate schemas \u2714 Canonicalize deterministically \u2714 Verify cryptographic attestations \u2714 Maintain hash-linked revisions \u2714 Interpret vocabularies correctly \u2714 Support provenance graph construction \u2714 Achieve hash parity across languages  </p> <p>This ensures global interoperability within the Civic Graph.</p>"},{"location":"en/implementation/new-connector/","title":"Building a New Connector","text":"<p>All connectors involve:</p> <ul> <li>Vocab &amp; schemas</li> <li>Core types / builders</li> <li>Validators</li> <li>Adapters</li> <li>Output, tests</li> </ul> <p>Rust handles:</p> <ul> <li>all canonical types,</li> <li>ID rules,</li> <li>validation rules,</li> <li>end-to-end build and validate pipeline.</li> </ul>"},{"location":"en/implementation/new-connector/#logical-development","title":"Logical Development","text":"<ol> <li> <p>Define mapping from source \u2192 CEP core: How do we get: legalName, jurisdiction, entityType, local IDs, etc.?</p> </li> <li> <p>ID logic: How do we detect \"we've seen this entity before\"? How do we generate or look up verifiableId?</p> </li> <li> <p>Fact completeness rules: What can be missing at first ingest (e.g., inceptionDate)? When is a record considered \"provisional\" vs \"solid\"?</p> </li> <li> <p>Validation: What must be true before we can emit a CEP-compliant entity?</p> </li> <li> <p>Attestation: How do we record \"who said this, based on what, and when\"?</p> </li> </ol>"},{"location":"en/implementation/new-connector/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>ID must not depend on entity enception date as it is very often not included in the raw data.</li> </ul>"},{"location":"en/implementation/new-connector/#phase-1-walk-skeleton-for-entity-path","title":"Phase 1: Walk skeleton for entity path","text":"<p>Write a test where an example (e.g. a School District) goes all the way through the process.</p> <p>Example tasks:</p> <ul> <li>Define EntityId, first_seen_date, and minimal Entity struct in core/entity.rs.</li> <li>Implement EntityBuilder with required fields and optional inception_date.</li> <li>Implement simple EntityValidator (e.g., legal_name not empty, jurisdiction present).</li> </ul> <p>Write an end-to-end test:</p> <ul> <li>Input JSON with a raw entity name, e.g. US-MN School District x</li> <li>Run through the builder and validator</li> <li>Assert it gets a stable ID, no panic, and inception_date is None.</li> </ul> <p>At the end of Phase 1, a complete vertical slice that works.</p>"},{"location":"en/implementation/new-connector/#phase-2-add-implementation-notes","title":"Phase 2: Add Implementation Notes","text":"<ul> <li>Note implementation details in docs.</li> </ul>"},{"location":"en/implementation/new-connector/#phase-3-strengthen-reliability","title":"Phase 3: Strengthen reliability","text":"<p>Add more tests:</p> <ul> <li>Invalid input (missing legalName)</li> <li>Duplicate entity</li> <li>Updates when new facts arrive (e.g., add inceptionDate later).</li> </ul> <p>Add CI:</p> <ul> <li>Run tests on push/PR.</li> </ul> <p>Add a couple of property tests or fuzz tests for deserialization.</p>"},{"location":"en/implementation/new-connector/#common-workflow","title":"Common Workflow","text":"<ol> <li>Update the schema in <code>schemas</code>.</li> <li>Run <code>uv run python tools/codegen_rust.py</code> to regen rust types.</li> <li>Update <code>build_identifiers_snfei</code> (or associated build function) in associatied manual.rs.</li> <li>Update the Python fallback builder in the Python <code>api.py</code>.</li> <li>Update all references to associated .json files and tests.</li> </ol>"},{"location":"en/implementation/profiles/","title":"Profiles","text":"<p>Profiles described here:</p> <ul> <li>CEP-Core (required minimal spec)</li> <li>CEP-AI-Constrained (non-destructive AI, audit logging)</li> <li>CEP-Legacy-Import (looser onboarding, revision classification)</li> <li>CEP-Privacy-Extended (stricter CTag limits)</li> <li>CEP-AuditMax (mandatory checkpoints, full verification)</li> </ul>"},{"location":"en/implementation/profiles/#cep-core-required-minimal","title":"CEP-Core (Required, Minimal)","text":""},{"location":"en/implementation/profiles/#cep-ai-constrained-non-destructive-ai-audit-logging","title":"CEP-AI-Constrained (non-destructive AI, audit logging)","text":""},{"location":"en/implementation/profiles/#cep-legacy-import-looser-onboarding-revision-classification","title":"CEP-Legacy-Import (looser onboarding, revision classification)","text":""},{"location":"en/implementation/profiles/#cep-privacy-extended-stricter-ctag-limits","title":"CEP-Privacy-Extended (stricter CTag limits)","text":""},{"location":"en/implementation/profiles/#cep-auditmax-mandatory-checkpoints-full-verification","title":"CEP-AuditMax (mandatory checkpoints, full verification)","text":""},{"location":"en/implementation/record-envelopes/","title":"Common Record Envelope","text":"<p>A shared CEP record envelope is reused for all domains:</p> <ul> <li>Entity</li> <li>Relationship</li> <li>Exchange</li> <li>CTag</li> </ul>"},{"location":"en/implementation/record-envelopes/#attributes","title":"Attributes","text":"<ul> <li>recordKind is the top-level discriminator: \"entity\", \"relationship\", \"exchange\", \"ctag\".</li> <li>verifiableId is the stable key, never changes once assigned.</li> <li>recordTypeUri always points into a vocabulary:</li> <li>entity-type, relationship-type, exchange-type, ctag-type, etc.</li> <li>timestamps are shared so all records can be compared on the same axes.</li> <li>attestations are identical in shape across domains.</li> </ul>"},{"location":"en/implementation/validator/","title":"Validator","text":"<p>Paste a sample Civic Exchange Protocol record below and validate it against one of the official schemas.</p>"},{"location":"en/implementation/validator/#schema-endpoints","title":"Schema Endpoints","text":"<p>The validator checks your JSON against one of the official Civic Exchange Protocol schemas:</p> <ul> <li> <p>Entity Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.entity.schema.json</p> </li> <li> <p>Relationship Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.relationship.schema.json</p> </li> <li> <p>Exchange Schema https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.exchange.schema.json</p> </li> <li> <p>Identifier Scheme vocabularies https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/cep.entity.identifier-scheme.schema.json</p> </li> </ul>"},{"location":"en/implementation/validator/#step-1-choose-schema","title":"Step 1. Choose schema","text":"<p> Entity (cep.entity.schema.json) Relationship (cep.relationship.schema.json) Exchange (cep.exchange.schema.json) <p></p>"},{"location":"en/implementation/validator/#step-2-input-json","title":"Step 2. Input JSON","text":"{   \"schemaVersion\": \"1.0.0\",   \"verifiableId\": \"cep-entity:sam-uei:J6H4FB3N5YK7\",   \"identifiers\": {     \"samUei\": \"J6H4FB3N5YK7\",     \"snfei\": \"d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\",     \"additionalSchemes\": [       {         \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/identifier-scheme.json#us-mn-district-id\",         \"value\": \"ISD-0123\"       },       {         \"schemeUri\": \"https://opencivicdata.org/id/division\",         \"value\": \"ocd-division/country:us/state:mn/school_district:123\"       }     ]   },   \"legalName\": \"Springfield Public School District 123\",   \"legalNameNormalized\": \"springfield public school district 123\",   \"entityTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-type.json#school-district\",   \"jurisdictionIso\": \"US-MN\",   \"status\": {     \"statusCode\": \"ACTIVE\",     \"statusEffectiveDate\": \"2001-07-01\",     \"statusTerminationDate\": null,     \"successorEntityId\": null   },   \"naicsCode\": null,   \"resolutionConfidence\": {     \"score\": 1.0,     \"methodUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/resolution-method.json#authoritative-sam-sync\",     \"sourceRecordCount\": 1   },   \"attestation\": {     \"attestorId\": \"cep-entity:sam-uei:EDFEDERAL0001\",     \"attestationTimestamp\": \"2025-11-28T15:30:45.123456Z\",     \"proofType\": \"Ed25519Signature2020\",     \"proofValue\": \"BASE64_SIGNATURE_VALUE_HERE\",     \"verificationMethodUri\": \"https://keys.civic-interconnect.org/attestors/edfederal-node-1#primary-key\",     \"proofPurpose\": \"assertionMethod\",     \"anchorUri\": null   },   \"previousRecordHash\": null,   \"revisionNumber\": 1 }"},{"location":"en/implementation/validator/#step-3-validation-result","title":"Step 3. Validation Result","text":"(Waiting for input...)"},{"location":"en/reference/compatibility-matrix/","title":"Compatibility Matrix","text":"<p>Alignment of CEP and CTags with Existing Civic Standards and Ecosystems</p> <p>This matrix summarizes how Civic Interconnect integrates with leading civic data standards and common government systems. CEP provides the cross-domain structure; CTags provide the provenance layer.</p>"},{"location":"en/reference/compatibility-matrix/#overview-table","title":"Overview Table","text":"Standard / System What It Covers How CEP Integrates How CTags Integrate Value Added Open Civic Data (OCD) Jurisdictions, political divisions, IDs CEP entities reference OCD division IDs; relationships anchored to geography CTags reference jurisdiction identifiers when provenance is location-based Shared geography layer; consistent identifiers Popolo People, organizations, memberships CEP entities map to Popolo-style person/organization structures CTags reference actors involved in document creation or modification Unified identity layer compatible with many civic tools OCDS (Open Contracting Data Standard) Contracting lifecycle (tender &gt; award &gt; contract &gt; implementation) CEP exchanges wrap OCDS documents or link to specific lifecycle stages CTags attach to RFPs, bids, contracts, amendments End-to-end traceability across procurement W3C PROV General-purpose provenance ontology CEP aligns conceptually via entities/activities CTags act as a lightweight PROV profile Semantic-web compatibility without complexity FOIA / Public Records Vendor Systems Submission, routing, review, redaction, release CEP exchanges represent request/response workflows CTags track document lineage and redactions Zero-friction integration; better audit trails Procurement / ERP Systems Contracts, POs, invoices, amendments CEP structures the entity/relationship context; exchanges represent filings CTags document transformations, OCR, AI assistance Stronger compliance and cross-system linking Grant Reporting Systems Awards, periodic reports, audits CEP models multi-stage reporting as exchanges CTags attach to each submitted artifact Simplified compliance, especially for small jurisdictions AI / LLM Systems Retrieval, summarization, classification, transformation CEP provides structured context and stable IDs CTags record chain-of-transformation for AI outputs Transparent AI workflows; verifiable lineage"},{"location":"en/reference/compatibility-matrix/#notes","title":"Notes","text":"<ul> <li>CEP is intentionally schema-light and integrative, not a replacement for existing domain standards.  </li> <li>CTags remain artifact-level and can be used independently.  </li> <li>Combined, they enable transparent, interoperable, AI-ready civic data pipelines across institutions, vendors, and research ecosystems.</li> </ul>"},{"location":"en/reference/context-tags/","title":"Context Tags (CTags)","text":"<p>Context Tags (CTags) are a new layer in the Civic Exchange Protocol (CEP) that capture interpretive, analytic, or contextual facts about a record, without changing its canonical identity or payload.</p> <p>They are:</p> <ul> <li>Optional</li> <li>Append-only</li> <li>Vocabulary-driven</li> <li>Non-canonical (do not affect SNFEI or verifiableId)</li> <li>Attested (you always know who applied them, when, and why)</li> </ul> <p>CTags live next to a record, not inside the payload.</p>"},{"location":"en/reference/context-tags/#1-why-ctags-exist","title":"1. Why CTags Exist","text":"<p>Most data standards handle:</p> <ul> <li>Payload fields (facts in the record)</li> <li>Envelope metadata (IDs, timestamps, status, attestations)</li> </ul> <p>They do not have a clean place for:</p> <ul> <li>ML-derived classifications</li> <li>Risk or quality flags</li> <li>Narrative context (for example, key actor in investigation X)</li> <li>Cluster membership and similarity-based hints</li> <li>Interpretive statements by analysts or oversight bodies</li> </ul> <p>If you put these inside the payload, they pollute the domain model and can change semantics. If you try to squeeze them into provenance metadata, they become awkward and hard to query.</p> <p>CTags solve this by creating a third layer:</p> <ol> <li>Envelope (identity, timestamps, attestations)</li> <li>Payload (facts)</li> <li>Context (CTags: interpretations, analysis, narrative, risk)</li> </ol>"},{"location":"en/reference/context-tags/#2-relationship-to-ptags-and-w3c-prov","title":"2. Relationship to PTags and W3C PROV","text":"<p>CTags are distinct from both PTags and PROV:</p> <ul> <li> <p>PTags (Privacy Tags for social content)</p> <ul> <li>Describe how a post behaves in a privacy-preserving way (account age bucket, automation flag, client family, etc.).</li> <li>Designed for social media research and platform transparency.</li> <li>Domain: behavior and privacy, attached to posts.</li> </ul> </li> <li> <p>CTags (Context Tags for CEP records)</p> <ul> <li>Describe interpretive facts about civic records: risk, analysis, narrative, quality.</li> <li>Domain: provenance narrative and analytic interpretation.</li> <li>Attached to Entities, Relationships, Exchanges, or aggregates.</li> </ul> </li> <li> <p>W3C PROV</p> <ul> <li>Describes how things came to be: Entities, Activities, Agents, and their causal links.</li> <li>CTags can reference PROV activities via <code>provActivityUri</code>, but they are simpler, operational labels for day-to-day analysis.</li> </ul> </li> </ul> <p>That is:</p> <ul> <li>PROV is the graph of what happened.</li> <li>The CEP envelope is the canonical record of what is.</li> <li>CTags are the commentary layer: what we think about this record, and how we classify or interpret it.</li> </ul>"},{"location":"en/reference/context-tags/#3-ctag-schema-shape","title":"3. CTag Schema Shape","text":"<p>CTags are defined by <code>cep.ctag.schema.json</code> and are typically embedded as an array property <code>ctags</code> in CEP records.</p> <p>Simplified shape:</p> <pre><code>{\n    \"tagTypeUri\": \"https://.../ctag-type.v1.0.0.json#risk.flag.potential_shell\",\n    \"code\": \"risk.flag.potential_shell\",\n    \"value\": \"cluster_07\",\n    \"appliedBy\": \"cep-analysis:snfei-risk-v1\",\n    \"appliedAt\": \"2025-12-07T10:00:00Z\",\n    \"scope\": \"record\",\n    \"confidence\": 0.87,\n    \"note\": \"High-velocity donations across related PACs.\",\n    \"sourceRunId\": \"risk-model-2025-12-07T09-55Z\",\n    \"provActivityUri\": \"urn:prov:activity:snfei-risk-scan:2025-12-07\"\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>tagTypeUri</code> and <code>code</code> tie the tag to a controlled vocabulary term.</li> <li><code>appliedBy</code> and <code>appliedAt</code> make the tag attributable and auditable.</li> <li><code>scope</code> and <code>targetPath</code> let you aim the tag at a full record, a particular field, or an inferred relationship.</li> <li><code>confidence</code> is optional but encouraged for ML-inferred tags.</li> </ul>"},{"location":"en/reference/context-tags/#4-embedding-ctags-in-cep-records","title":"4. Embedding CTags in CEP Records","text":"<p>CTags appear as an optional array at the top level of an Entity, Relationship, or Exchange record.</p> <p>Example (Entity excerpt):</p> <pre><code>{\n    \"verifiableId\": \"cep-entity:snfei:34486b3...\",\n    \"recordKind\": \"Entity\",\n    \"recordTypeUri\": \"https://.../entity-type.v1.0.0.json#municipality\",\n    \"schemaVersion\": \"1.0.0\",\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"City of Springfield\",\n    \"identifiers\": [\n        {\n            \"schemeUri\": \"https://.../entity-identifier-scheme.v1.0.0.json#snfei\",\n            \"identifier\": \"34486b3...\"\n        }\n    ],\n    \"status\": {\n        \"statusCode\": \"ACTIVE\",\n        \"statusEffectiveDate\": \"1900-01-01\"\n    },\n    \"attestations\": [\n        {\n            \"attestationTimestamp\": \"1900-01-01T00:00:00.000000Z\",\n            \"attestorId\": \"cep-entity:example:ingest\",\n            \"proofType\": \"ManualAttestation\"\n        }\n    ],\n    \"ctags\": [\n        {\n            \"tagTypeUri\": \"https://.../ctag-type.v1.0.0.json#risk.flag.potential_shell\",\n            \"code\": \"risk.flag.potential_shell\",\n            \"value\": \"cluster_07\",\n            \"appliedBy\": \"cep-analysis:snfei-risk-v1\",\n            \"appliedAt\": \"2025-12-07T10:00:00Z\",\n            \"scope\": \"record\",\n            \"confidence\": 0.87,\n            \"note\": \"Pattern matches known shell-like structures in state filings.\"\n        },\n        {\n            \"tagTypeUri\": \"https://.../ctag-type.v1.0.0.json#analysis.cluster.membership\",\n            \"code\": \"analysis.cluster.membership\",\n            \"value\": {\n                \"clusterId\": \"mn-muni-cluster-02\",\n                \"method\": \"louvain\",\n                \"graph\": \"snfei-donation-graph-v3\"\n            },\n            \"appliedBy\": \"cep-analysis:graph-cluster-v3\",\n            \"appliedAt\": \"2025-12-07T10:05:00Z\",\n            \"scope\": \"record\",\n            \"confidence\": 0.93\n        }\n    ]\n}\n</code></pre> <p>The record remains valid CEP even if <code>ctags</code> is omitted entirely. CTags are designed to be safe to drop and safe to ignore.</p>"},{"location":"en/reference/context-tags/#5-design-principles","title":"5. Design Principles","text":"<p>CTags obey several key principles:</p> <ol> <li> <p>Non-canonical</p> <ul> <li>CTags never participate in the SNFEI hash or in the canonical string.</li> <li>Changing or adding CTags does not change <code>verifiableId</code>.</li> </ul> </li> <li> <p>Append-only</p> <ul> <li>Systems should treat <code>ctags</code> as append-only.</li> <li>New tags may be added over time as models improve or oversight evolves.</li> <li>Historical tags should be retained for audit and reproducibility.</li> </ul> </li> <li> <p>Attributable</p> <ul> <li>Every tag is tied to <code>appliedBy</code> and <code>appliedAt</code>.</li> <li>Optional <code>sourceRunId</code> and <code>provActivityUri</code> provide deeper reproducibility.</li> </ul> </li> <li> <p>Vocabulary-driven</p> <ul> <li><code>tagTypeUri</code> and <code>code</code> refer to a controlled vocabulary for interoperability.</li> <li>Vocabularies can define enums, allowed shapes, and intended usage.</li> </ul> </li> <li> <p>Interoperable and Optional</p> <ul> <li>Downstream systems may filter, group, or display records based on CTags.</li> <li>Systems that do not understand CTags can ignore them safely.</li> </ul> </li> </ol>"},{"location":"en/reference/context-tags/#6-typical-use-cases","title":"6. Typical Use Cases","text":"<p>Some common patterns where CTags are useful:</p> <ul> <li> <p>Risk analysis</p> <ul> <li>Flags for potential shell entities, pass-through entities, high-risk flows.</li> </ul> </li> <li> <p>Data quality</p> <ul> <li>Indicators of incomplete address, inconsistent identifiers, or duplicate candidates.</li> </ul> </li> <li> <p>Narrative and investigation</p> <ul> <li>Marking key actors, focal relationships, or important funding chains in cases or reports.</li> </ul> </li> <li> <p>Model outputs</p> <ul> <li>ML or heuristic model classifications attached as tags, including confidence scores.</li> </ul> </li> <li> <p>Aggregation and rollup</p> <ul> <li>Indicators that a record participates in an aggregate (for example, rollup-by-grant-program or funding stream).</li> </ul> </li> </ul>"},{"location":"en/reference/context-tags/#7-interaction-with-governance","title":"7. Interaction With Governance","text":"<p>CTags are governed like any other vocabulary-backed component in CEP:</p> <ul> <li>New CTag types are proposed, reviewed, and versioned through the vocabulary governance process.</li> <li>Deprecation of CTag types is handled via vocabulary status flags.</li> <li>Implementations are encouraged to log which CTag types they emit and to document their semantics.</li> </ul> <p>Because CTags are non-canonical and optional, introducing new types does not break existing records. This makes CTags a safe, evolvable layer for emerging analytic and oversight needs.</p>"},{"location":"en/reference/context-tags/#8-summary","title":"8. Summary","text":"<p>CTags give CEP a dedicated layer for:</p> <ul> <li>Interpretive, analytic, or narrative facts</li> <li>Risk and quality signals</li> <li>ML and heuristic outputs</li> <li>Human oversight tagging</li> </ul> <p>They are the missing piece between raw facts (payload) and pure provenance (PROV), allowing researchers, agencies, and tools to enrich records without compromising identity or integrity.</p>"},{"location":"en/reference/entity/","title":"Entity Records","text":"<p>A CEP EntityRecord represents a real-world organization, jurisdiction, or legally recognized actor. It is the foundation for linking civic data across domains such as campaign finance, procurement, grants, education, and nonprofit oversight.</p> <p>EntityRecords combine:</p> <ul> <li>Canonical identity (SNFEI)</li> <li>Domain classifications</li> <li>Provenance and attestations</li> <li>Status lifecycle</li> <li>Cryptographic record integrity</li> </ul>"},{"location":"en/reference/entity/#1-structure","title":"1. Structure","text":"<p>An EntityRecord includes:</p>"},{"location":"en/reference/entity/#11-core-fields","title":"1.1 Core Fields","text":"Field Description <code>verifiableId</code> Cryptographically derived identity (<code>cep-entity:snfei:&lt;hash&gt;</code>) <code>entityTypeUri</code> Vocabulary reference describing entity category <code>jurisdictionIso</code> ISO-like jurisdiction code (e.g., <code>US-MN</code>) <code>legalName</code> Human-readable legal name <code>legalNameNormalized</code> Normalized form used to compute SNFEI <code>identifiers</code> External and internal identifiers (SNFEI, LEI, UEI, EIN, etc.)"},{"location":"en/reference/entity/#12-envelope-fields","title":"1.2 Envelope Fields","text":"<p>EntityRecords inherit the CEP record envelope:</p> <ul> <li><code>schemaVersion</code></li> <li><code>recordSchemaUri</code></li> <li><code>revisionNumber</code></li> <li><code>previousRecordHash</code></li> <li><code>status</code> block (ACTIVE / INACTIVE)</li> <li><code>timestamps</code></li> <li><code>attestations</code></li> <li><code>ctags</code></li> </ul> <p>See <code>/en/implementation/record-envelope.md</code> for details.</p>"},{"location":"en/reference/entity/#2-snfei-in-entity-records","title":"2. SNFEI in Entity Records","text":"<p>The SNFEI identity appears twice:</p> <ol> <li>In identifiers:</li> </ol> <pre><code>\"identifiers\": {\n  \"snfei\": { \"value\": \"3448...\" }\n}\n</code></pre> <ol> <li>In verifiableId:</li> </ol> <pre><code>\"verifiableId\": \"cep-entity:snfei:3448...\"\n</code></pre> <p>This ensures:</p> <ul> <li>Cross-schema consistency  </li> <li>Reproducible identity derivation  </li> <li>Compatibility with external ID systems  </li> </ul>"},{"location":"en/reference/entity/#3-entitytypeuri","title":"3. entityTypeUri","text":"<p>Entity type is resolved via the entity-type vocabulary:</p> <pre><code>https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-type.v1.0.0.json#municipality\n</code></pre> <p>Adapters provide simple labels (<code>\"municipality\"</code>), and the builder expands them to the full URI.</p>"},{"location":"en/reference/entity/#4-example-entityrecord","title":"4. Example EntityRecord","text":"<pre><code>{\n  \"schemaVersion\": \"1.0.0\",\n  \"recordSchemaUri\": \".../schemas/cep.entity.schema.json\",\n  \"verifiableId\": \"cep-entity:snfei:34486b38...\",\n  \"entityTypeUri\": \".../vocabularies/entity-type.v1.0.0.json#municipality\",\n  \"jurisdictionIso\": \"US-MN\",\n  \"legalName\": \"City of Springfield\",\n  \"legalNameNormalized\": \"city springfield\",\n  \"identifiers\": {\n    \"snfei\": { \"value\": \"34486b38...\" }\n  },\n  \"status\": {\n    \"statusCode\": \"ACTIVE\",\n    \"statusEffectiveDate\": \"1900-01-01\"\n  },\n  \"attestations\": [\n    {\n      \"attestationTimestamp\": \"2025-01-01T00:00:00Z\",\n      \"proofType\": \"ManualAttestation\"\n    }\n  ],\n  \"revisionNumber\": 1\n}\n</code></pre>"},{"location":"en/reference/entity/#5-how-entityrecords-are-produced","title":"5. How EntityRecords Are Produced","text":"<ol> <li>Adapter Normalizes Input  </li> <li>Canonicalization builds hash string  </li> <li>SNFEI computed (Rust or Python)  </li> <li>Entity builder constructs full envelope  </li> <li>Record emitted as JSON</li> </ol>"},{"location":"en/reference/entity/#6-usage","title":"6. Usage","text":"<p>EntityRecords are used for:</p> <ul> <li>Linking datasets (campaign finance -&gt; contracts -&gt; lobbying)  </li> <li>Regulatory and financial reporting  </li> <li>Auditable data pipelines  </li> <li>Provenance-aware knowledge graphs  </li> </ul> <p>Entity identity is the backbone of the CI/CEP ecosystem.</p>"},{"location":"en/reference/exchange/","title":"Exchange Records","text":"<p>An ExchangeRecord represents the flow of value between entities. This includes grants, payments, reimbursements, procurement transactions, or any transfer of resources with a defined purpose.</p> <p>Exchanges are fundamental for understanding public spending, contract chains, and money movement across civic systems.</p>"},{"location":"en/reference/exchange/#1-structure","title":"1. Structure","text":"Field Description <code>fromEntityId</code> Sender of value <code>toEntityId</code> Receiver of value <code>exchangeTypeUri</code> Vocabulary classification of the exchange <code>amount</code> Monetary or unit amount <code>currency</code> ISO 4217 currency code <code>timestamps</code> When the exchange occurred <code>attestations</code> Proofs, metadata, or verification <p>The ExchangeRecord inherits the full CEP envelope and hash integrity features.</p>"},{"location":"en/reference/exchange/#2-exchange-types","title":"2. Exchange Types","text":"<p>Common vocabularies include:</p> <ul> <li><code>#grant</code></li> <li><code>#contract-fee</code></li> <li><code>#payment</code></li> <li><code>#reimbursement</code></li> <li><code>#in-kind-support</code></li> </ul> <p>These are governed by CEP vocabulary rules (see <code>/en/governance/vocabulary-process.md</code>).</p>"},{"location":"en/reference/exchange/#3-example-exchangerecord","title":"3. Example ExchangeRecord","text":"<pre><code>{\n  \"recordKind\": \"Exchange\",\n  \"exchangeTypeUri\": \".../exchange-type.json#grant\",\n  \"fromEntityId\": \"cep-entity:snfei:abc...\",\n  \"toEntityId\": \"cep-entity:snfei:def...\",\n  \"amount\": 250000,\n  \"currency\": \"USD\",\n  \"timestamps\": {\n    \"validFrom\": \"2024-01-01\"\n  },\n  \"attestations\": [\n    { \"attestationTimestamp\": \"2024-03-05T00:00:00Z\", \"proofType\": \"ManualAttestation\" }\n  ],\n  \"revisionNumber\": 1\n}\n</code></pre>"},{"location":"en/reference/exchange/#4-use-cases","title":"4. Use Cases","text":"<ul> <li>Federal to State grant flows  </li> <li>School district reimbursements  </li> <li>Contract payments  </li> <li>Campaign to vendor disbursements  </li> <li>Nonprofit expenditure chains  </li> </ul> <p>Exchanges form the backbone of money-flow reconstruction across civic systems.</p>"},{"location":"en/reference/exchange/#5-exchange-provenance","title":"5. Exchange Provenance","text":"<p>Attestations allow:</p> <ul> <li>Auditable approvals  </li> <li>Documentation references  </li> <li>Review dates  </li> <li>Verification status  </li> </ul> <p>This ensures high-trust public data suitable for transparency and analysis.</p>"},{"location":"en/reference/identifier-schemes/","title":"Identifier Schemes","text":"<p>CEP uses a structured approach to identity, allowing multiple identifiers to coexist, link, or be mapped across systems. Identifier schemes define how these IDs are interpreted, validated, and transformed across jurisdictions.</p>"},{"location":"en/reference/identifier-schemes/#1-snfei-structured-non-fungible-entity-identifier","title":"1. SNFEI (Structured Non-Fungible Entity Identifier)","text":"<p>Scheme URI:</p> <pre><code>.../vocabularies/entity-identifier-scheme.v1.0.0.json#snfei\n</code></pre> <p>Characteristics:</p> <ul> <li>Deterministic</li> <li>Canonicalization-based</li> <li>Cryptographic (SHA-256)</li> <li>Stable across datasets and time</li> <li>Designed to bridge to LEI, UEI, and EIN</li> </ul> <p>Usage:</p> <pre><code>\"identifiers\": {\n  \"snfei\": { \"value\": \"&lt;hash&gt;\" }\n}\n</code></pre>"},{"location":"en/reference/identifier-schemes/#2-external-identifier-schemes","title":"2. External Identifier Schemes","text":"<p>CEP supports mapping to external IDs:</p> Scheme Use Case Notes LEI Global financial identity ISO 17442 standard UEI U.S. federal awardees SAM.gov system EIN U.S. nonprofits &amp; IRS filings Numeric tax ID FEC ID Campaign committees U.S. federal election system State IDs Local entities Vary by state and domain <p>Each scheme is represented via:</p> <pre><code>{\n    \"schemeUri\": \"&lt;scheme-uri&gt;\",\n    \"identifier\": \"&lt;id-value&gt;\",\n    \"sourceReference\": null\n}\n</code></pre>"},{"location":"en/reference/identifier-schemes/#3-why-schemes-matter","title":"3. Why Schemes Matter","text":"<p>Identifier schemes enable:</p> <ul> <li>Cross-dataset linking</li> <li>Disambiguation</li> <li>Provenance tracking</li> <li>Confidence scoring</li> <li>Multi-jurisdiction integration</li> </ul> <p>SNFEI is the Tier 3 fallback when LEI/UEI/EIN is missing or ambiguous.</p>"},{"location":"en/reference/identifier-schemes/#4-relationship-to-identity-tiers","title":"4. Relationship to Identity Tiers","text":"<p>See <code>/en/reference/identity-tiers.md</code> for:</p> <ul> <li>Tier 1 - Global IDs (LEI, UEI)</li> <li>Tier 2 - National IDs</li> <li>Tier 3 - SNFEI (canonical fallback)</li> </ul> <p>Identifier schemes provide a common framing for linking these layers.</p>"},{"location":"en/reference/identifier-schemes/#5-mapping-vocabulary-governance","title":"5. Mapping &amp; Vocabulary Governance","text":"<p>Identifier scheme vocabularies are governed through:</p> <ul> <li>Versioned JSON vocabularies</li> <li>Change control via ISB governance</li> <li>Mapping types: exactMatch, broadMatch, narrowMatch, relatedMatch</li> </ul> <p>This ensures that identifier interactions remain stable and interpretable over time.</p>"},{"location":"en/reference/identity-tiers/","title":"Identity Tiers and External IDs","text":"<p>Civic Interconnect is building a unifying model for SNFEI, UEI, LEI, and domain-specific identifiers.</p> <p>Modern civic data ecosystems contain a patchwork of identity systems. Some are globally regulated (LEI), some are national (UEI), and others are local or domain-specific (state vendor IDs, FEC committee IDs, IRS EINs, school district codes). The Civic Exchange Protocol (CEP) models these as Identity Tiers, each with different governance, scope, and persistence guarantees.</p> <p>CEP's identity architecture organizes all IDs into a three-tier model, with the SNFEI (Structured Non-Fungible Entity Identifier) providing a stable, open, globally usable Tier-3 identifier that can employ and coexist with all external identifiers.</p>"},{"location":"en/reference/identity-tiers/#1-the-three-identity-tiers","title":"1. The Three Identity Tiers","text":""},{"location":"en/reference/identity-tiers/#tier-1-global-regulated-identity-lei-isin-etc","title":"Tier 1: Global Regulated Identity (LEI, ISIN, etc.)","text":"<p>Examples:</p> <ul> <li>LEI (Legal Entity Identifier)</li> <li>CUSIP (Committee on Uniform Security Identification Procedures)<ul> <li>Identifies securities in the US and Canada for trading, clearing, and settlement</li> <li>9 characters (alphanumeric)</li> <li>Managed by the CUSIP organization (operated by S&amp;P)</li> </ul> </li> <li>ISIN (International Securities Identification Number)<ul> <li>A universal code for cross-border transactions, identifying securities globally</li> <li>12 alphanumeric characters (2 country, 9 security, 1 check)</li> </ul> </li> <li>IBAN ( International Bank Account Number)<ul> <li>Identifies a specific bank account.</li> <li>A long alphanumeric string (20-34 characters) that includes the country code, checksum, and account number.</li> <li>Used in countries with the IBAN system, primarily in Europe, the Middle East, and parts of the Caribbean and Latin America.</li> </ul> </li> <li>SWIFT (Society for Worldwide Interbank Financial Telecommunication)<ul> <li>Identifies a specific bank.</li> <li>An 8 or 11-character code that includes bank, country, and location codes.</li> <li>Used globally to route transactions between financial institutions.</li> </ul> </li> </ul> <p>Characteristics:</p> <ul> <li>Governed by global bodies (G20, ROC, ISO).</li> <li>Designed for financial regulation, risk management, and reporting.</li> <li>Strong persistence guarantees.</li> <li>Difficult for civic and local entities to obtain.</li> </ul> <p>Fit with CEP:</p> <ul> <li>Tier-1 identifiers are linked via Identifier objects and treated as authoritative when present.</li> <li>CEP never replaces them - it uses them.</li> </ul>"},{"location":"en/reference/identity-tiers/#tier-2-national-or-federal-identity-uei-ein-fec-ids","title":"Tier 2: National or Federal Identity (UEI, EIN, FEC IDs)","text":"<p>Examples:</p> <ul> <li>UEI (U.S. Government's Unique Entity Identifier)</li> <li>EIN (IRS Employer Identification Number)</li> <li>FEC Committee IDs (Federal Election Commission)</li> <li>SAM Vendor IDs (System for Award Management Vendor Identifiers)</li> <li>State corporate registry numbers</li> </ul> <p>Characteristics:</p> <ul> <li>Mandated for federal contracting, tax records, and campaign finance.</li> <li>Highly structured but inconsistent across domains.</li> <li>Often missing for municipalities, school districts, and NGOs.</li> </ul> <p>Fit with CEP:</p> <ul> <li>Tier-2 identifiers appear as authoritative external IDs attached to the Entity record.</li> <li>They improve match confidence but are not universal or canonical.</li> </ul>"},{"location":"en/reference/identity-tiers/#tier-3-open-cross-domain-identity-snfei","title":"Tier 3: Open, Cross-Domain Identity (SNFEI)","text":"<p>The SNFEI is CEP's open identity layer, created from:</p> <ul> <li>normalized legal name</li> <li>optional address</li> <li>country code</li> <li>optional registration date</li> </ul> <p>SNFEI solves the key problem Tier-1 and Tier-2 systems cannot: a single, globally computable identifier for every civic entity, even when no formal identifier exists.</p> <p>Characteristics:</p> <ul> <li>Fully open and reproducible (no central authority needed).</li> <li>Deterministic: same input yields same output.</li> <li>Bridges siloed systems (campaign finance -&gt; procurement -&gt; education -&gt; nonprofits -&gt; municipalities).</li> <li>Coexists with all external IDs; never overrides them.</li> </ul> <p>In the CEP envelope:</p> <ul> <li>SNFEI always appears in the identifiers array and is embedded in the verifiableId.</li> </ul>"},{"location":"en/reference/identity-tiers/#2-why-tiering-matters","title":"2. Why Tiering Matters","text":""},{"location":"en/reference/identity-tiers/#interoperability","title":"Interoperability","text":"<p>Allows systems with different authority models to share a coherent identity graph.</p>"},{"location":"en/reference/identity-tiers/#progressive-enhancement","title":"Progressive Enhancement","text":"<p>Agencies with weak identity data can start with SNFEI and later link regulated IDs.</p>"},{"location":"en/reference/identity-tiers/#auditability-provenance","title":"Auditability &amp; Provenance","text":"<p>All identifiers - Tier-1, Tier-2, and SNFEI - participate in:</p> <ul> <li>provenance chains</li> <li>confidence scoring</li> <li>link reconciliation</li> <li>graph reconstruction</li> </ul>"},{"location":"en/reference/identity-tiers/#avoids-id-fragility","title":"Avoids ID Fragility","text":"<p>If national systems change (UEI replaced the DUNS; EIN rules evolve), CEP identity remains stable.</p>"},{"location":"en/reference/identity-tiers/#3-identifier-objects-in-cep","title":"3. Identifier Objects in CEP","text":"<p>CEP represents all identifiers - internal or external - using a uniform structure:</p> <pre><code>{\n    \"schemeUri\": \"https://.../entity-identifier-scheme.v1.0.0.json#snfei\",\n    \"identifier\": \"34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\",\n    \"sourceReference\": null\n}\n</code></pre> <p>Every identifier has:</p> Field Meaning schemeUri Vocabulary URI specifying the identifier system (SNFEI, LEI, UEI, EIN, FEC, etc.) identifier The actual ID value sourceReference Optional pointer to the authority or document asserting the ID <p>This structure supports:</p> <ul> <li>multiple coexisting IDs per Entity</li> <li>crosswalks between ID ecosystems</li> <li>automated resolution pipelines</li> </ul>"},{"location":"en/reference/identity-tiers/#4-how-snfei-bridges-external-ids","title":"4. How SNFEI Bridges External IDs","text":"<p>SNFEI is designed to:</p> <ul> <li>connect disparate IDs,</li> <li>anchor entities that lack regulated identifiers,</li> <li>resolve duplicates across systems,</li> <li>link historical and modern representations of the same entity,</li> <li>provide a universal identity for graph-based analytics.</li> </ul> <p>External IDs (LEI, UEI, EIN, FEC) are then attached as sibling identifiers.</p> <p>Example:</p> <pre><code>\"identifiers\": [\n  { \"schemeUri\": \"...#snfei\", \"identifier\": \"&lt;hash&gt;\" },\n  { \"schemeUri\": \"...#uei\",   \"identifier\": \"ABC123DEF456\" },\n  { \"schemeUri\": \"...#ein\",   \"identifier\": \"41-1234567\" }\n]\n</code></pre>"},{"location":"en/reference/identity-tiers/#5-summary-table","title":"5. Summary Table","text":"Tier Examples Authority Purpose CEP Role Tier 1 LEI, ISIN, IBAN Global regulators (G20, ROC, ISO) Financial compliance &amp; global KYC Treated as authoritative external IDs Tier 2 UEI, EIN, FEC, State IDs National or domain-specific authorities Program compliance &amp; reporting Supplementary identifiers with confidence attribution Tier 3 SNFEI Open, reproducible Universal identity across domains Canonical internal identifier for CEP records"},{"location":"en/reference/identity-tiers/#6-how-this-helps-the-research-community","title":"6. How This Helps the Research Community","text":"<ul> <li>CS researchers gain a unified identity graph with formal semantics.</li> <li>Policy analysts can follow money and influence across institutions.</li> <li>Open data ecosystems obtain a durable, globally interoperable identifier.</li> <li>Auditors &amp; compliance teams get cryptographically stable provenance.</li> </ul>"},{"location":"en/reference/reference-projects/","title":"Reference Projects: GitHub Data Standards","text":"<p>There are categories of open-source projects on GitHub that offer great examples, particularly concerning common data schemas, multi-language support, and provenance tracking.</p>"},{"location":"en/reference/reference-projects/#1-interoperability-event-specifications-cross-platform","title":"1. Interoperability &amp; Event Specifications (Cross-Platform)","text":"<p>These standards focus on defining a common data format to ensure different systems and languages can communicate seamlessly. They typically define schemas and transport rules.</p>"},{"location":"en/reference/reference-projects/#cloudevents-specification","title":"CloudEvents Specification","text":"<p>This specification describes event data in a common way. It is designed to simplify event declaration and delivery across services, platforms, and languages (e.g., Go, Java, Python, C#).</p> <p>It's a good example of a cross-platform specification managed openly on GitHub. It defines a mandatory set of attributes (like a base entity identifier) that must be present in every data payload.</p> <p>Link: https://github.com/cloudevents/spec</p>"},{"location":"en/reference/reference-projects/#cdevents-specification","title":"CDEvents Specification","text":"<p>This is a popular specification for Continuous Delivery events, extending CloudEvents by introducing purpose and semantics to the event data.</p> <p>It shows how a standard is built on top of another standard (CloudEvents), specializing the common metadata for a specific domain (CI/CD provenance and flow).</p> <p>Link: https://github.com/cdevents/spec</p>"},{"location":"en/reference/reference-projects/#2-provenance-and-data-tracking-standards","title":"2. Provenance and Data Tracking Standards","text":"<p>These projects relate to provenance aspects, focusing on tracking the history, inputs, and derivation of data.</p>"},{"location":"en/reference/reference-projects/#prov-cpl-core-provenance-library","title":"PROV-CPL (Core Provenance Library)","text":"<p>This is the Core Provenance Library for collecting data provenance with multiple language bindings (C/C++, Java, Python, R). It uses the W3C PROV standard as its foundation.</p> <p>It demonstrates a multi-language implementation of a provenance standard, providing APIs to record who/what/when/where data was created, which is central to provenance.</p> <p>Link: https://github.com/ProvTools/prov-cpl</p>"},{"location":"en/reference/reference-projects/#3-general-data-schemas-and-monorepo-structure","title":"3. General Data Schemas and Monorepo Structure","text":"<p>These focus on using JSON Schema to define strict data structures and managing them in a versioned repository.</p>"},{"location":"en/reference/reference-projects/#json-schema-specification","title":"JSON Schema Specification","text":"<p>This is the official specification for JSON Schema, a declarative language used to annotate and validate JSON documents.</p> <p>This foundational tool is by many standards (including CloudEvents) to define specific fields and types. This repo illustrates how a core schema standard is defined and versioned.</p> <p>Link: https://github.com/json-schema-org/json-schema-spec</p>"},{"location":"en/reference/reference-projects/#consumer-data-standards-australian-dsb-schemas","title":"Consumer Data Standards (Australian DSB Schemas)","text":"<p>This repository holds a collection of JSON schema files derived from the Australian Consumer Data Standards, used for robust schema validation in banking and energy sectors.</p> <p>This offers a practical example of a large-scale data standard implementation in a monorepo (single repository), organized by release version, providing strict, enforceable JSON schemas for real-world data exchange.</p> <p>Link: https://github.com/ConsumerDataStandardsAustralia/dsb-schema-tools</p>"},{"location":"en/reference/reference-standards/","title":"Reference Standards","text":""},{"location":"en/reference/reference-standards/#associated-standards","title":"Associated Standards","text":"Standard/Acronym Purpose Why We Interface XBRL (eXtensible Business Reporting Language) The international standard for electronic transmission of business and financial data (e.g., SEC and FDIC filings use it). We map its transactional fields directly to the relevant XBRL taxonomy elements for regulatory compliance reporting. LEI (Legal Entity Identifier) Global standard for identifying parties to financial transactions worldwide. While the UEI is authoritative in the U.S. government space, our protocol needs to contain a field for the LEI if the entity is globally registered, ensuring compliance for any international transactions. W3C PROV (Provenance) The World Wide Web Consortium standard for recording the historical lifecycle and data quality of a piece of information. Our core value is Provenance. We adopt the principles of W3C PROV to formally define how data history, revisions, and sources are timestamped and logged. GTAS (Government-wide Treasury Account Symbol) The framework used by the Treasury for standardized federal financial reporting. Transactional data (e.g., amounts, categories) must be translatable into GTAS fields for seamless reporting up to the Treasury level."},{"location":"en/reference/reference-standards/#bridge","title":"Bridge","text":"<ul> <li>Official U.S UEI: The U.S. government already uses a Unique Entity Identifier (UEI), a 12-character alphanumeric ID assigned by SAM.gov, for all entities receiving federal financial assistance or doing business with the federal government (Source 3.1, 3.2). Often does not appear on state/local campaign finance reports or local school district consultant contracts unless federal funds are directly involved.</li> <li>Open-Source Data Cleaning Tools: Tools like Splink, OpenRefine, and Python/Pandas to manually clean and standardize messy names (\"Acme Consulting, LLC\" vs. \"Acme Consulting\") (Source 2.1, 2.3).</li> </ul>"},{"location":"en/reference/relationship/","title":"Relationship Records","text":"<p>A RelationshipRecord models a connection between two entities. Relationships define structure, governance, control, affiliation, and membership in civic systems.</p> <p>Where EntityRecords describe what something is, RelationshipRecords describe how two things relate.</p>"},{"location":"en/reference/relationship/#1-structure","title":"1. Structure","text":"Field Description <code>fromEntityId</code> Source entity <code>toEntityId</code> Target entity <code>relationshipTypeUri</code> Vocabulary describing the connection <code>timestamps</code> When the relationship is valid <code>attestations</code> Proofs or verification of the relationship <p>Relationships also inherit:</p> <ul> <li>Envelope fields  </li> <li>Canonical schema version  </li> <li>Revision lifecycle  </li> </ul>"},{"location":"en/reference/relationship/#2-common-relationship-types","title":"2. Common Relationship Types","text":"<ul> <li><code>#governs</code> </li> <li><code>#reports-to</code> </li> <li><code>#affiliate-of</code> </li> <li><code>#subsidiary-of</code> </li> <li><code>#vendor-for</code> </li> <li><code>#receives-grant-from</code> </li> <li><code>#board-membership</code> </li> </ul> <p>Each is governed through the Relationship Vocabulary.</p>"},{"location":"en/reference/relationship/#3-example-relationshiprecord","title":"3. Example RelationshipRecord","text":"<pre><code>{\n  \"recordKind\": \"Relationship\",\n  \"relationshipTypeUri\": \".../relationship-type.json#governs\",\n  \"fromEntityId\": \"cep-entity:snfei:aaa...\",\n  \"toEntityId\": \"cep-entity:snfei:bbb...\",\n  \"timestamps\": {\n    \"validFrom\": \"2023-01-01\"\n  },\n  \"attestations\": [\n    { \"attestationTimestamp\": \"2023-04-01T00:00:00Z\", \"proofType\": \"ManualAttestation\" }\n  ],\n  \"revisionNumber\": 1\n}\n</code></pre>"},{"location":"en/reference/relationship/#4-use-cases","title":"4. Use Cases","text":"<ul> <li>School board -&gt; school district relationships  </li> <li>Nonprofit -&gt; fiscal sponsor relationships  </li> <li>Campaign -&gt; committee hierarchy  </li> <li>Government agency -&gt; subdivision governance  </li> <li>Vendor -&gt; contract recipient connections  </li> </ul> <p>Relationship graphs allow CEP to express organizational structure and flow.</p>"},{"location":"en/reference/relationship/#5-provenance","title":"5. Provenance","text":"<p>Relationship provenance tracks:</p> <ul> <li>Source documents  </li> <li>Review authorities  </li> <li>Versions and updates  </li> <li>Verification method  </li> </ul> <p>This ensures that civic relationship networks are high-trust and tamper-evident.</p>"},{"location":"en/reference/snfei/","title":"What is SNFEI?","text":"<p>SNFEI stands for Structured Non-Fungible Entity Identifier. It is a deterministic, recomputable identifier designed for civic, educational, nonprofit, and other public-interest entities that lack a national or global registry identifier such as LEI or SAM-UEI.</p> <p>SNFEI is not a proprietary ID and does not rely on any external registry. Instead, it provides an open, stable, cross-dataset linking key that any system can compute locally.</p>"},{"location":"en/reference/snfei/#why-snfei-exists","title":"Why SNFEI Exists","text":"<p>Many organizations\u2014school districts, conservation districts, townships, cooperatives, special districts, community nonprofits\u2014do not have a canonical global identifier. As a result:</p> <ul> <li>datasets frequently cannot be joined,</li> <li>names vary across sources,</li> <li>entities appear duplicated or fragmented,</li> <li>matching becomes ad-hoc and error-prone.</li> </ul> <p>SNFEI introduces a consistent, transparent, and reproducible identifier that enables reliable linking without a central authority.</p>"},{"location":"en/reference/snfei/#how-snfei-is-computed","title":"How SNFEI Is Computed","text":"<p>An SNFEI is defined as:</p> <p>SHA-256 hash of (normalized legal name + jurisdiction).</p> <p>This produces a fixed, deterministic identifier using inputs that are:</p> <ul> <li>already present in nearly all civic datasets,</li> <li>stable over time,</li> <li>easy to normalize and verify.</li> </ul> <p>Because the process is deterministic, any system can recompute SNFEI and confirm whether two records refer to the same entity.</p>"},{"location":"en/reference/snfei/#example","title":"Example","text":"<p>For an entity with:</p> <ul> <li>legal name = <code>Example School District 123</code> </li> <li>jurisdiction = <code>US-MN</code></li> </ul> <p>The SNFEI is the SHA-256 hash of:</p> <pre><code>example school district 123 + us-mn\n</code></pre> <p>Example output:</p> <pre><code>34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\n</code></pre> <p>This value becomes the entity's SNFEI and forms part of its CEP verifiableId:</p> <pre><code>cep-entity:snfei:&lt;hash&gt;\n</code></pre>"},{"location":"en/reference/snfei/#when-to-use-snfei","title":"When to Use SNFEI","text":"<p>Use SNFEI when:</p> <ul> <li>an entity does not have a recognized national/global identifier (LEI, SAM-UEI, etc.),</li> <li>datasets must be joined or deduplicated,</li> <li>building entity registries for transparency, civic data, or public-interest analytics,</li> <li>ensuring reproducible, provenance-aware entity referencing.</li> </ul> <p>SNFEI complements, and does NOT replace, official identifiers. If a primary ID exists, CEP includes it; if not, SNFEI provides a consistent fallback.</p>"},{"location":"en/reference/snfei/#vocabulary-reference","title":"Vocabulary Reference","text":"<p>The SNFEI scheme is defined in the CEP Identifier Scheme Vocabulary:</p> <pre><code>https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-identifier-scheme.v1.0.0.json#snfei\n</code></pre> <p>This URI is the canonical value used in CEP records under:</p> <pre><code>identifiers[].schemeUri\n</code></pre> <p>SNFEI is versioned, openly described, and governed under the CEP Vocabulary Process.</p>"},{"location":"en/reference/w3c-prov/","title":"W3C PROV Provenance Standard","text":"<p>W3C PROV formalizes provenance as a causal graph that captures how digital or real-world artifacts are produced, modified, and influenced over time. By expressing the relationships among entities, activities, and agents, PROV provides a common framework for tracing lineage, validating data integrity, and supporting auditability across systems. Its simplicity makes it compatible with JSON-based workflows, Linked Data environments, and domain-specific standards such as Civic Interconnect.</p> <p>PROV encourages systems to represent not only what exists but how it came to exist. This enables reproducibility, version tracking, trust assessment, and rigorous reasoning about the origins and transformations of information.</p> <p>There are three fundamental node types:</p> <ol> <li>Entity - a thing in some state (a dataset version, a file, a record, a JSON document)</li> <li>Activity - something that happens over time (an ingestion process, a transformation, a merge)</li> <li>Agent - something responsible (a human, an organization, a software system)</li> </ol> <p>There are three fundamental relation types:</p> <ul> <li>wasGeneratedBy (Entity wasGeneratedBy Activity)</li> <li>used (Activity used prior Entity)</li> <li>wasAttributedTo (Entity wasAttributedTo Agent)</li> </ul> <p>Agent -&gt; performed  -&gt; Activity -&gt; generated -&gt; Entity</p>"},{"location":"en/reference/w3c-prov/#interface-to-civic-interconnect-civic-exchange-protocol","title":"Interface to Civic Interconnect Civic Exchange Protocol","text":"<p>Civic Interconnect mirrors core PROV concepts:</p> <ul> <li>Entities correspond to CEP Entity Records, Relationship Records, Vocab Terms, and transformed dataset snapshots.</li> <li>Activities map cleanly to CEP ingest steps, validation passes, transformations, merges, exports, and publication workflows.</li> <li>Agents align with CEP attestors, ingestion identities, organizations, and software systems that produce or modify records.</li> </ul> <p>CEP's attestation block functions as a structured, PROV-compatible expression of responsibility and origin, capturing who created or updated a record and under what method. By keeping CEP's entity life cycle parallel to PROV's activity graph, implementations gain a clear, interoperable provenance layer that can integrate with open data catalogs, regulatory reporting systems, and scientific reproducibility frameworks.</p> <p>A PROV-compliant layer would formalize:</p> <ul> <li>which steps are activities</li> <li>which outputs are entities</li> <li>which systems or people are agents</li> <li>and the edges connecting them.</li> </ul>"},{"location":"en/reference/w3c-prov/#prov-components","title":"PROV Components","text":""},{"location":"en/reference/w3c-prov/#prov-dm","title":"PROV-DM","text":"<p>Data Model.  The ontology that defines the conceptual graph (entity, activity, agent, and their relations).</p>"},{"location":"en/reference/w3c-prov/#prov-n","title":"PROV-N","text":"<p>A simple human-readable notation (like Turtle). Good for examples, academic papers.</p>"},{"location":"en/reference/w3c-prov/#prov-o","title":"PROV-O","text":"<p>An RDF/OWL ontology. When we express provenance in Linked Data form, use this.</p>"},{"location":"en/reference/w3c-prov/#prov-json-prov-xml","title":"PROV-JSON / PROV-XML","text":"<p>Concrete serializations. Most practical systems use PROV-JSON.</p>"},{"location":"en/reference/w3c-prov/#prov-ecosystem","title":"PROV Ecosystem","text":"<p>PROV works with:</p>"},{"location":"en/reference/w3c-prov/#1-skos","title":"1. SKOS","text":"<p>A vocabulary framework for controlled terms. CEP vocabularies (entity types, relationship types) reference SKOS mappings.</p>"},{"location":"en/reference/w3c-prov/#1-json-schema-xml-schema","title":"1. JSON Schema / XML Schema","text":"<p>Define shape and validation rules. These are not provenance - they are structure contracts. PROV complements them, it does not replace them.</p>"},{"location":"en/reference/w3c-prov/#3-linked-data-rdf-owl","title":"3. Linked Data / RDF / OWL","text":"<p>Semantic frameworks like PROV-O, for when provenance needs to interoperate on the semantic web.</p>"},{"location":"en/reference/w3c-prov/#4-w3c-verifiable-credentials-vc","title":"4. W3C Verifiable Credentials (VC)","text":"<p>Where attestation comes in. When we attach provenance and add cryptographic signatures, you get VCs. The CEP attestation field is parallel to this, just simplified.</p>"},{"location":"en/reference/w3c-prov/#5-prov-extensions-used-in-scientific-computing","title":"5. PROV extensions used in scientific computing","text":"<p>Like PROV-One (workflow-focused). Used to describe complex multi-step pipelines.</p>"},{"location":"en/reference/w3c-prov/#6-data-catalogs-ckan-dcat","title":"6. Data catalogs (CKAN, DCAT)","text":"<p>Metadata catalogs that can store PROV graphs about datasets. When publishing dataset metadata, DCAT is the companion standard. CKAN is an open source data management system used by US data.gov, the government of Canada, and more. </p>"},{"location":"en/specs/","title":"Civic Exchange Protocol \u2013 Specification Suite","text":"<p>This directory contains the formal specifications that define the core behavior of the Civic Exchange Protocol (CEP). These documents together form the normative foundation for interoperability, reproducibility, and provable identity across all CEP domains (public procurement, campaign finance, corporate registries, environment, education, etc.).</p> <p>The specifications are versioned independently. Each one describes a distinct layer or subsystem of the protocol. Collectively they form the basis for:</p> <ul> <li>canonicalization and hashing,</li> <li>entity and relationship modeling,</li> <li>provenance and c-tags,</li> <li>adapter execution,</li> <li>graph normalization,</li> <li>identity resolution,</li> <li>vocabulary governance.</li> </ul>"},{"location":"en/specs/#ordering-of-specifications","title":"Ordering of specifications","text":"<p>CEP has one primary standard, on which all others depend:</p> <ol> <li>CEC v1 \u2014 Canonical Encoding &amp; Canonicalization    Defines the deterministic rewriting and normalization rules used throughout CEP,    including the canonical JSON form, string canonicalization, field ordering,    and the hashing process that yields <code>verifiableId</code> values.</li> </ol> <p>After CEC, all remaining specs are listed alphabetically. This avoids implying a linear or hierarchical dependency structure, since each layer is designed to be modular and composable.</p>"},{"location":"en/specs/#specification-index-alphabetical-after-cec","title":"Specification Index (Alphabetical After CEC)","text":""},{"location":"en/specs/#canonical-encoding-canonicalization","title":"Canonical Encoding &amp; Canonicalization","text":"<ul> <li>CEC v1   Core deterministic encoding and canonicalization rules.   Required by all other CEP standards.</li> </ul>"},{"location":"en/specs/#remaining-standards-a-z","title":"Remaining Standards (A \u2192 Z)","text":"<ul> <li> <p>AAS v1 \u2014 Adapter Architecture Specification   Defines how raw external data is transformed into CEP domain objects.   Includes adapter manifests, APS compatibility, self-test rules, and   standardized envelope formats.</p> </li> <li> <p>CDIRA v1 \u2014 Cross-Domain Identity Resolution &amp; Attestation   Mechanisms for merging and reconciling entities that appear across   independent domains.   Includes identity graphs, similarity models, evidence weighting,   stable reference construction, and conflict handling.</p> </li> <li> <p>EFS v1 \u2014 Entity Fingerprint Specification   Defines how canonicalized entities produce stable fingerprint inputs   for hashing, including domain-specific and cross-domain fingerprint   modules.   Used to derive <code>verifiableId</code> values across CEP.</p> </li> <li> <p>GIC v1 \u2014 Global Integrity Constraints   Cross-entity and cross-relationship constraints applicable to all CEP   graphs, including jurisdictional closure, relationship validation,   entity type compatibility, and temporal consistency.</p> </li> <li> <p>GNS v1 \u2014 Graph Normalization Specification   Defines how transformed domain records are merged into a coherent,   deduplicated, canonical graph.   Includes node merging rules, relationship normalization,   provenance tracing, and conflict resolution.</p> </li> <li> <p>VGS v1 \u2014 Vocabulary Governance Specification   Defines the structure, lifecycle, and evolution rules of controlled   vocabularies used throughout CEP.   Includes term governance, versioning, SKOS-style mappings, and the   relationship between vocabularies and core schemas.</p> </li> </ul>"},{"location":"en/specs/#how-these-specifications-fit-together","title":"How these specifications fit together","text":"<p>A simplified view:</p> <pre><code>Raw Data (external APIs, files, scrapers)\n       |\n       v\nAAS v1 \u2014 Adapters produce domain objects\n       |\n       v\nCEC v1 \u2014 Canonical encoding + deterministic rewriting\n       |\n       v\nEFS v1 \u2014 Fingerprints \u2192 verifiableId creation\n       |\n       v\nGNS v1 \u2014 Graph normalization + merging\n       |\n       v\nCDIRA v1 \u2014 Cross-domain identity resolution\n       |\n       v\nGIC v1 \u2014 Global integrity checks\n       |\n       v\nVGS v1 \u2014 Controlled terms, domain vocabularies, governance\n</code></pre> <p>Each specification is self-contained but interoperable, ensuring that:</p> <ul> <li>any CEP pipeline is reproducible,</li> <li>every entity has a verifiable cryptographic identity,</li> <li>transformations are audit-ready,</li> <li>graphs remain consistent across domains and over time,</li> <li>vocabulary evolution is stable and governed.</li> </ul>"},{"location":"en/specs/#contributing-versioning","title":"Contributing &amp; Versioning","text":"<p>Every spec:</p> <ul> <li>declares a semantic version (e.g., <code>1.0.0</code>),</li> <li>must document all breaking and non-breaking changes,</li> <li>should include examples, diagrams, and reference implementations when possible.</li> </ul> <p>Proposals for changes follow the CEP Evolution Policy, including:</p> <ul> <li>issue creation,</li> <li>discussion period,</li> <li>review by editors,</li> <li>version increment (minor/patch/major),</li> <li>publication to the specs directory.</li> </ul>"},{"location":"en/specs/aas-v1/","title":"Adapter Algebra Specification (AAS v1)","text":"<p>Version: 1.0.0  </p> <p>Status: Draft  </p> <p>Applies to: All CEP adapters (local, domain, core, envelope)  </p> <p>Purpose: Define a deterministic, compositional algebra of adapters as typed rewriting morphisms between CEP schemas.</p>"},{"location":"en/specs/aas-v1/#1-overview","title":"1. Overview","text":"<p>Adapters are the primary way CEP connects heterogeneous data sources to the canonical CEP representation. Each adapter is a typed rewriting morphism between schemas:</p> <ul> <li>from a source schema (e.g., a CSV layout, an API response, a legacy JSON schema)</li> <li>to a target schema (e.g., a CEP domain record, a core CEP entity, an envelope)</li> </ul> <p>This document defines:</p> <ul> <li>the type signature of adapters  </li> <li>determinism and partiality requirements  </li> <li>composition and identity adapters </li> <li>versioning and provenance requirements</li> </ul> <p>The goal is to ensure that adapter pipelines behave predictably and can be reasoned about as a compositional algebra.</p>"},{"location":"en/specs/aas-v1/#2-adapter-types-and-signatures","title":"2. Adapter Types and Signatures","text":""},{"location":"en/specs/aas-v1/#21-schema-objects","title":"2.1 Schema Objects","text":"<p>Every adapter operates between two schemas:</p> <ul> <li>A source schema <code>S</code></li> <li>A target schema <code>T</code></li> </ul> <p>Schemas are identified by stable URIs:</p> <ul> <li><code>schemaId: string</code> (e.g., <code>https://.../schema/cep.entity.municipality.json</code>)</li> <li><code>schemaVersion: semver</code> (e.g., <code>\"1.0.0\"</code>)</li> </ul> <p>The pair <code>(schemaId, schemaVersion)</code> uniquely identifies a schema.</p>"},{"location":"en/specs/aas-v1/#22-adapter-definition","title":"2.2 Adapter Definition","text":"<p>An adapter <code>A</code> is defined by:</p> <ul> <li><code>adapterId: string</code> (stable identifier, e.g., <code>adapter.us_mn_muni_raw_to_domain_v1</code>)</li> <li><code>adapterVersion: semver</code></li> <li><code>sourceSchemaId: string</code></li> <li><code>sourceSchemaVersion: semver</code></li> <li><code>targetSchemaId: string</code></li> <li><code>targetSchemaVersion: semver</code></li> <li><code>adapterKind: \"local\" | \"domain\" | \"core\" | \"envelope\"</code> (classification)</li> <li>rewrite function:</li> <li><code>A: SourceRecord -&gt; Result&lt;TargetRecord, AdapterError&gt;</code></li> </ul> <p>Conceptually:</p> <pre><code>A : Records(S) \u2192 Records(T) \u222a {AdapterError}\n</code></pre> <p>Adapters are pure functions: for fixed input, they must always return the same output or the same error.</p>"},{"location":"en/specs/aas-v1/#3-determinism-and-partiality","title":"3. Determinism and Partiality","text":""},{"location":"en/specs/aas-v1/#31-determinism","title":"3.1 Determinism","text":"<p>For any given input record x that conforms to sourceSchemaId / sourceSchemaVersion:</p> <p>If A(x) succeeds once, it must succeed always with the same TargetRecord.</p> <p>If A(x) fails, it must always fail with the same AdapterError category.</p> <p>Non-deterministic behavior (e.g., depending on current time, external services, randomness) is not allowed in the core adapter function.</p> <p>If time-dependent or context-dependent behavior is needed (e.g., \u201cnow\u201d), it must be pushed into explicit input fields or handled outside the adapter.</p>"},{"location":"en/specs/aas-v1/#32-partiality","title":"3.2 Partiality","text":"<p>Adapters are generally partial:</p> <ul> <li>Not all SourceRecords are necessarily valid or mappable.</li> <li>Failures must be explicit and typed.</li> </ul> <p>We model this using <code>Result&lt;TargetRecord, AdapterError&gt;</code>.</p> <p>AdapterError categories include (but are not limited to):</p> <ul> <li>SchemaViolation (input does not conform to the declared source schema)</li> <li>MissingRequiredField</li> <li>InvalidCode (unknown vocabulary term)</li> <li>CanonicalizationFailure</li> <li>InconsistentIdentifiers</li> <li>UnsupportedVersion</li> <li>InternalInvariantViolation (bug, not data issue)</li> </ul> <p>Adapters must not silently correct or drop records without either:</p> <ul> <li>returning an explicit error, or</li> <li>recording warnings in an attested envelope.</li> </ul>"},{"location":"en/specs/aas-v1/#4-composition-of-adapters","title":"4. Composition of Adapters","text":"<p>Given adapters:</p> <p><code>A: S \u2192 T</code></p> <p><code>B: T \u2192 U</code></p> <p>We can form a composite adapter:</p> <p><code>B \u2218 A : S \u2192 U</code></p> <p>defined by:</p> <pre><code>(B \u2218 A)(x) = \n    match A(x) with\n      | Ok(y)    -&gt; B(y)\n      | Error(e) -&gt; Error(e)\n</code></pre> <p>4.1 Associativity</p> <p>Composition of adapters is associative:</p> <p><code>C \u2218 (B \u2218 A) = (C \u2218 B) \u2218 A</code></p> <p>at the level of the underlying functions, provided they all share compatible schemas and error semantics.</p> <p>This means adapter pipelines behave like morphisms in a category:</p> <ul> <li>Objects: schemas (schemaId, schemaVersion)</li> <li>Morphisms: adapters between schemas</li> </ul>"},{"location":"en/specs/aas-v1/#42-identity-adapters","title":"4.2 Identity Adapters","text":"<p>For every schema (S, v), there MUST exist an identity adapter:</p> <p><code>id_S : S \u2192 S</code></p> <p>such that for all adapters <code>A: S \u2192 T</code> and <code>B: U \u2192 S</code>:</p> <p><code>A \u2218 id_S = A</code></p> <p><code>id_S \u2218 B = B</code></p> <p>The identity adapter performs validation but no transformation:</p> <ul> <li>It may enforce schema conformance.</li> <li>It must not change any field value.</li> </ul>"},{"location":"en/specs/aas-v1/#43-version-aware-composition","title":"4.3 Version-Aware Composition","text":"<p>Adapters are tied to specific (schemaId, schemaVersion) pairs.</p> <p>Composition <code>B \u2218 A</code> is only valid if:</p> <ul> <li><code>A.targetSchemaId == B.sourceSchemaId</code></li> <li><code>A.targetSchemaVersion</code> is compatible with <code>B.sourceSchemaVersion</code></li> </ul> <p>Compatibility rules must be explicit:</p> <ul> <li>Exact match, or</li> <li>Declared compatibility ranges (e.g., &gt;=1.0.0 &lt;2.0.0)</li> </ul> <p>If versions are incompatible, composition is not allowed without an explicit version-bridge adapter.</p>"},{"location":"en/specs/aas-v1/#5-adapter-kinds-and-pipelines","title":"5. Adapter Kinds and Pipelines","text":"<p>Adapters are grouped into kinds to reflect their typical position in a pipeline:</p> <ul> <li> <p>Local adapters: Source-specific \u2192 domain-specific raw</p> </li> <li> <p>Domain adapters: Domain-specific raw \u2192 CEP domain record</p> </li> <li> <p>Core adapters: CEP domain record \u2192 CEP core entity/relationship</p> </li> <li> <p>Envelope adapters: CEP core entity/relationship \u2192 exchange/envelope</p> </li> </ul> <p>A typical pipeline:</p> <pre><code>RawSource\n  \u2192 (Local Adapter)\nDomainRaw\n  \u2192 (Domain Adapter)\nDomainEntity\n  \u2192 (Core Adapter)\nCoreEntity\n  \u2192 (Envelope Adapter)\nEnvelope\n</code></pre> <p>Each step is a morphism of schemas; the full pipeline is the composite morphism.</p>"},{"location":"en/specs/aas-v1/#6-rewriting-semantics","title":"6. Rewriting Semantics","text":"<p>Adapters are typed rewriting functions:</p> <ul> <li>They rewrite structures (records), not just strings.</li> <li>They apply the canonicalization pipeline to relevant fields.</li> <li>They enforce vocabulary mappings and schema constraints.</li> </ul> <p>The adapter algebra is therefore:</p> <ul> <li>structural at the record level</li> <li>compositional under function composition</li> <li>strategy-governed in terms of pipeline order (we do not assume commutativity)</li> </ul>"},{"location":"en/specs/aas-v1/#7-versioning-of-adapters","title":"7. Versioning of Adapters","text":"<p>Each adapter has an explicit adapterVersion (SemVer):</p> <ul> <li>MAJOR: breaking change in output schema or semantics.</li> <li>MINOR: backward-compatible enhancements (additional computed fields, new optional behavior).</li> <li>PATCH: bugfixes that preserve behavior for valid inputs.</li> </ul> <p>Every produced record MUST include:</p> <ul> <li>adapterId</li> <li>adapterVersion</li> </ul> <p>in its provenance / envelope, so that downstream processes and verifiers can reproduce or audit adapter behavior.</p>"},{"location":"en/specs/aas-v1/#8-equivalence-of-adapters","title":"8. Equivalence of Adapters","text":"<p>Two adapters <code>A, B: S \u2192 T</code> are extensionally equivalent if for all valid inputs <code>x</code>:</p> <p><code>A(x) = B(x)</code></p> <p>CEP may treat extensionally equivalent adapters as interchangeable, but they may still differ in:</p> <ul> <li>implementation language</li> <li>performance</li> <li>internal logging or diagnostics</li> </ul> <p>Equivalence is a conceptual notion; practical systems may use tests to approximate it.</p>"},{"location":"en/specs/aas-v1/#9-adapter-provenance-and-attestation","title":"9. Adapter Provenance and Attestation","text":"<p>Adapters are central to trust in CEP data. Therefore:</p> <p>Every adapter invocation SHOULD be recorded in provenance:</p> <ul> <li>adapterId</li> <li>adapterVersion</li> <li>timestamps</li> <li>success or failure</li> </ul> <p>Cryptographic tags (CTags) SHOULD commit to:</p> <ul> <li>adapter identity and version</li> <li>input fingerprint (if applicable)</li> <li>canonical output representation (CEC)</li> </ul> <p>This allows verifiers to:</p> <ul> <li>reconstruct the adapter chain,</li> <li>reproduce transformations,</li> <li>detect tampering or missing pipeline steps.</li> </ul>"},{"location":"en/specs/aas-v1/#10-summary","title":"10. Summary","text":"<p>The adapter algebra defines a category of schemas and adapters:</p> <ul> <li>Objects: versioned schemas</li> <li>Morphisms: deterministic, typed, possibly partial adapters</li> <li>Composition: associative function composition</li> <li>Identities: schema-preserving validators</li> </ul> <p>This algebra underpins cross-domain interoperability, reproducible pipelines, and verifiable transformations in CEP.</p>"},{"location":"en/specs/cdira-v1/","title":"Cross-Domain Identity Resolution Algorithm (CDIRA v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP entities across all domains (campaign finance, environment, education, municipal, etc.)</p> <p>Purpose: Define a deterministic algorithm for resolving when multiple CEP entities (possibly from different domains or sources) represent the same real-world entity.</p>"},{"location":"en/specs/cdira-v1/#1-overview","title":"1. Overview","text":"<p>CEP treats identity as a minimal, canonical fingerprint (EFS v1) plus a rewriting-based normalization strategy. Cross-domain identity resolution is the process of:</p> <ul> <li>detecting when multiple CEP entities refer to the same real entity,</li> <li>assigning them to a shared identity cluster, and</li> <li>ensuring that this process is deterministic, auditable, and versioned.</li> </ul> <p>The Cross-Domain Identity Resolution Algorithm (CDIRA) defines:</p> <ol> <li>The evidence model for identity.</li> <li>The deterministic resolution steps (candidate generation, evidence evaluation, cluster assignment).</li> <li>The relationship between fingerprints, graphs, and identity clusters.</li> <li>Versioning and provenance requirements for the resolution process.</li> </ol> <p>CDIRA is a rewriting system over entity graphs: it rewrites sets of entity nodes into equivalence classes (identity clusters) using strategy-governed rules.</p>"},{"location":"en/specs/cdira-v1/#2-identity-model","title":"2. Identity Model","text":"<p>CDIRA operates on CEP entities that already satisfy:</p> <ul> <li>canonicalization (names, identifiers, vocabularies),</li> <li>fingerprint specification (EFS v1),</li> <li>canonical encoding (CEC v1),</li> <li>graph normalization (GNS v1) where applicable.</li> </ul>"},{"location":"en/specs/cdira-v1/#21-identity-units","title":"2.1 Identity Units","text":"<p>An Identity Unit is a single CEP entity with:</p> <ul> <li>verifiableId</li> <li>fingerprint (EFS object)</li> <li>domain-specific payload</li> <li>provenance</li> </ul>"},{"location":"en/specs/cdira-v1/#22-identity-cluster","title":"2.2 Identity Cluster","text":"<p>An Identity Cluster is a non-empty set of Identity Units believed to refer to the same real-world entity.</p> <p>Each cluster has:</p> <ul> <li>clusterId (stable identifier, see Section 7)</li> <li>members: list of verifiableIds</li> <li>clusterFingerprint: optional aggregated fingerprint summary</li> <li>cdiraVersion: version of the resolution algorithm used</li> <li>provenance for how and when it was formed</li> </ul>"},{"location":"en/specs/cdira-v1/#3-evidence-model","title":"3. Evidence Model","text":"<p>CDIRA uses deterministic, rule-based evidence classes. No probabilistic black-box logic is required in the core spec (implementations may use statistical methods internally, but final decisions must be reproducible).</p> <p>Evidence is grouped into:</p> <ul> <li>Strong evidence</li> <li>Moderate evidence</li> <li>Weak evidence</li> </ul>"},{"location":"en/specs/cdira-v1/#31-strong-evidence","title":"3.1 Strong Evidence","text":"<p>Strong evidence is sufficient to treat two entities as identical:</p> <ul> <li>Exact fingerprint match (same EFS fingerprint, same verifiableId).</li> <li>Shared authoritative identifier under a globally trusted scheme:<ul> <li>same SNFEI, LEI, FEC ID, EPA Facility ID, IPEDS ID, national corporate registry ID, etc., after canonicalization.</li> </ul> </li> </ul> <p>If strong evidence is present, entities must be placed in the same cluster.</p>"},{"location":"en/specs/cdira-v1/#32-moderate-evidence","title":"3.2 Moderate Evidence","text":"<p>Moderate evidence suggests likely identity but is not self-sufficient:</p> <ul> <li>Same canonical name + same jurisdictionUri + same entityTypeUri.</li> <li>Same canonical name + shared external identifier from a mid-confidence registry.</li> <li>Name equivalence plus matching normalized attributes that are relatively stable.</li> </ul> <p>Moderate evidence may trigger clustering if no conflicting evidence exists.</p>"},{"location":"en/specs/cdira-v1/#33-weak-evidence","title":"3.3 Weak Evidence","text":"<p>Weak evidence by itself must not cause a merge:</p> <ul> <li>co-occurrence patterns (same officers, same addresses),</li> <li>shared phone or email,</li> <li>similar but not identical names,</li> <li>proximity in graph structure.</li> </ul> <p>Weak evidence is only used to support moderate evidence or break ties.</p>"},{"location":"en/specs/cdira-v1/#4-deterministic-resolution-strategy","title":"4. Deterministic Resolution Strategy","text":"<p>CDIRA defines a three-phase resolution pipeline:</p> <ol> <li>Candidate Generation</li> <li>Evidence Evaluation</li> <li>Cluster Assignment</li> </ol>"},{"location":"en/specs/cdira-v1/#41-candidate-generation","title":"4.1 Candidate Generation","text":"<p>Candidate generation finds potential matches but does not decide identity.</p> <p>Blocking keys (deterministic):</p> <ul> <li>Identifier-based blocks: entities sharing a canonical value under any identifier scheme.</li> <li>Name + jurisdiction blocks: same legalNameNormalized AND same jurisdictionUri.</li> <li>Domain-specific blocks: e.g., same IPEDS ID, same EPA Registry ID, same FEC ID.</li> </ul> <p>Within each block, consider all unordered pairs as candidates.</p>"},{"location":"en/specs/cdira-v1/#42-evidence-evaluation","title":"4.2 Evidence Evaluation","text":"<p>For each candidate pair (A, B):</p> <ol> <li>Collect evidence of all types.</li> <li>Apply rules in order:</li> </ol>"},{"location":"en/specs/cdira-v1/#rule-1-fingerprint-equality","title":"Rule 1 (Fingerprint Equality).","text":"<p>If A.verifiableId == B.verifiableId, they must be in the same cluster.</p>"},{"location":"en/specs/cdira-v1/#rule-2-strong-identifier-equality","title":"Rule 2 (Strong Identifier Equality).","text":"<p>If they share an authoritative identifier and no explicit conflict exists, they must be merged.</p>"},{"location":"en/specs/cdira-v1/#rule-3-moderate-evidence-rule","title":"Rule 3 (Moderate Evidence Rule).","text":"<p>If:</p> <ul> <li>names, jurisdiction, and entity type match,</li> <li>no contradictory identifier evidence exists,</li> <li>one or more moderate evidence conditions hold,</li> </ul> <p>then A and B should be clustered.</p>"},{"location":"en/specs/cdira-v1/#rule-4-conflict-rule","title":"Rule 4 (Conflict Rule).","text":"<p>If strong identifiers match but identity-defining attributes contradict domain rules, they must not be auto-merged. Emit a conflict record.</p>"},{"location":"en/specs/cdira-v1/#rule-5-default-non-merge","title":"Rule 5 (Default Non-Merge).","text":"<p>If weak evidence only, entities remain separate.</p>"},{"location":"en/specs/cdira-v1/#43-cluster-assignment","title":"4.3 Cluster Assignment","text":"<p>Clusters are formed using transitive closure:</p> <p>If A merges with B, and B merges with C, then all three belong to the same cluster unless forbidden by a conflict rule.</p> <p>Cluster construction is deterministic given:</p> <ul> <li>same input entities,</li> <li>same version tuple,</li> <li>same configuration.</li> </ul>"},{"location":"en/specs/cdira-v1/#5-cdira-as-a-rewriting-system","title":"5. CDIRA as a Rewriting System","text":"<p>Conceptually, CDIRA:</p> <ul> <li>Starts from singleton clusters <code>{A}, {B}, {C}, ...</code></li> <li>Applies merge rewrites based on evidence rules:<ul> <li><code>{A}, {B} \u2192 {A,B}</code></li> </ul> </li> <li>Produces a partition of the entity set.</li> </ul> <p>The merge operation is:</p> <ul> <li>associative,</li> <li>idempotent (re-running CDIRA on identical clusters produces no changes).</li> </ul> <p>The internal merge process need not be commutative; the resulting partition must be independent of evaluation order.</p>"},{"location":"en/specs/cdira-v1/#6-conflict-handling","title":"6. Conflict Handling","text":"<p>CDIRA must produce explicit artifacts for:</p> <ul> <li>conflicting strong identifiers,</li> <li>inconsistent identity-defining attributes,</li> <li>ambiguous clusters with insufficient evidence.</li> </ul> <p>Conflicts are recorded as:</p> <pre><code>{\n  \"conflictType\": \"IdentifierConflict\" | \"FingerprintConflict\" | \"AmbiguousCluster\",\n  \"entities\": [\"verifiableId1\", \"verifiableId2\", \"...\"],\n  \"evidence\": {\n    \"strong\": [],\n    \"moderate\": [],\n    \"weak\": []\n  },\n  \"cdiraVersion\": \"1.0.0\",\n  \"timestamp\": \"...\",\n  \"resolutionStatus\": \"unresolved\" | \"manuallyResolved\" | \"ignored\"\n}\n</code></pre> <p>These become part of provenance and may be resolved later.</p>"},{"location":"en/specs/cdira-v1/#7-cluster-identifiers","title":"7. Cluster Identifiers","text":"<p>Each Identity Cluster receives a stable clusterId.</p> <p>Two allowed strategies:</p> <ol> <li> <p>Derived clusterId (hash-based):</p> </li> <li> <p>Deterministic hash of:</p> <ul> <li>sorted member verifiableIds</li> <li>version tuple</li> </ul> </li> <li> <p>Externally assigned clusterId:</p> </li> <li> <p>Used when authoritative registries assign persistent IDs.</p> </li> </ol> <p>In both cases:</p> <p><code>clusterId = \"cep-cluster:\" || base64url( H( clusterSummary ) )</code></p> <p>Where clusterSummary is a CEC-serialized object including:</p> <ul> <li>sorted member IDs</li> <li>version tuple</li> <li>optional clusterFingerprint</li> </ul>"},{"location":"en/specs/cdira-v1/#8-versioning-and-provenance","title":"8. Versioning and Provenance","text":"<p>CDIRA is versioned:</p> <p><code>cdiraVersion: 1.0.0</code></p> <p>Every cluster and conflict record must include:</p> <pre><code>{\n    \"cdiraVersion\": \"1.0.0\",\n    \"versions\": {\n        \"cec\": \"...\",\n        \"fingerprint\": \"...\",\n        \"schema\": \"...\",\n        \"vocabulary\": {},\n        \"adapter\": \"...\",\n        \"gns\": \"...\"\n    }\n}\n</code></pre> <p>Identity resolution is a provenance activity:</p> <ul> <li>identityResolverId</li> <li>identityResolverVersion</li> <li>timestamp</li> <li>input sets (entity IDs)</li> <li>output clusters and conflicts</li> </ul> <p>This ensures auditability and reproducibility.</p>"},{"location":"en/specs/cdira-v1/#9-determinism-requirements","title":"9. Determinism Requirements","text":"<p>CDIRA must be deterministic:</p> <p>Given the same inputs, versions, and configuration, the resulting clusters and conflicts must be identical.</p> <p>Any use of probabilistic or heuristic methods must:</p> <ul> <li>produce deterministic outputs (e.g., fixed seeds), or</li> <li>be advisory only, not part of final merge decisions.</li> </ul>"},{"location":"en/specs/cdira-v1/#10-summary","title":"10. Summary","text":"<p>CDIRA v1 defines:</p> <ul> <li>a rule-based deterministic approach to cross-domain identity resolution</li> <li>an evidence model (strong, moderate, weak)</li> <li>a rewrite system forming clusters via merge operations</li> <li>explicit conflict handling</li> <li>stable cluster identifiers</li> <li>full versioning and provenance for identity decisions</li> </ul> <p>This specification ties together canonicalization (CEC), fingerprints (EFS), graph normalization (GNS), and adapter semantics (AAS) into a coherent, cross-domain identity resolution framework for CEP.</p>"},{"location":"en/specs/cec-v1/","title":"CEC v1 - Canonical Encoding for CEP","text":"<p>Status: Draft</p> <p>Version: 1.0.0</p> <p>Applies to: CEP Entities, Relationships, Envelopes, CTags</p> <p>Purpose: Ensure deterministic, cross-system, cross-version hashing and verification.</p>"},{"location":"en/specs/cec-v1/#1-overview","title":"1. Overview","text":"<p>CEC (Canonical Encoding for CEP) defines a deterministic, language-independent serialization format for all CEP records. It ensures that two semantically identical CEP structures produce identical byte sequences and therefore identical cryptographic tags.</p> <p>CEC does not replace JSON, but defines the rules for turning a CEP structure into a canonical JSON byte representation.</p> <p>CEC is versioned independently of CEP schemas and vocabularies.</p>"},{"location":"en/specs/cec-v1/#2-goals","title":"2. Goals","text":"<ul> <li>Deterministic across programming languages</li> <li>Deteministic across CEP versions</li> <li>Hash-stable</li> <li>Independent of in-memory ordering</li> <li>Immune to whitespace or pretty-printing differences</li> <li>Explicit about versioning</li> <li>Backwards compatible via declared CEC version</li> </ul>"},{"location":"en/specs/cec-v1/#3-canonicalization-pipeline","title":"3. Canonicalization Pipeline","text":"<p>CEC requires that the following pipeline be applied after CEP canonicalization and before hashing:</p> <p>CEP.Normalization \u2192 CEC.Serialization \u2192 hash()</p> <p>Where:</p> <ul> <li>CEP.Normalization = rewrite pipeline (canonical names, vocabulary terms, identifiers, units, etc.)</li> <li>CEC.Serialization = deterministic JSON encoding defined in this document</li> </ul>"},{"location":"en/specs/cec-v1/#4-canonical-serialization-rules","title":"4. Canonical Serialization Rules","text":""},{"location":"en/specs/cec-v1/#41-key-ordering-deterministic-lexicographic-order","title":"4.1 Key Ordering (Deterministic Lexicographic Order)","text":"<ul> <li>All JSON object keys must be sorted lexicographically by Unicode code point, ascending.</li> <li>Sorting is stable.</li> <li>No domain-specific exceptions.</li> </ul> <p>Example: <code>{\"b\":1, \"a\":2}</code> becomes:</p> <p><code>{\"a\":2,\"b\":1}</code></p>"},{"location":"en/specs/cec-v1/#42-whitespace","title":"4.2 Whitespace","text":"<ul> <li>No whitespace except where required by JSON string literals.</li> <li>No pretty printing.</li> <li>No indentation.</li> <li>No newline required at end of file.</li> </ul> <p>CEC is optimized for hashing, not for readability.</p>"},{"location":"en/specs/cec-v1/#43-null-and-empty-field-omission-rules","title":"4.3 Null and Empty Field Omission Rules","text":"<p>To avoid non-determinism:</p> <ul> <li>Fields with value null MUST be omitted entirely.</li> <li>Empty arrays MUST be encoded as [] (not omitted).</li> <li>Empty objects MUST be encoded as {} (not omitted).</li> </ul> <p>Reason: presence/absence of an empty list has semantic meaning; null does not.</p>"},{"location":"en/specs/cec-v1/#44-numeric-normalization","title":"4.4 Numeric Normalization","text":"<p>Rules:</p> <ol> <li>No scientific notation.</li> <li>No trailing zeros after decimal.</li> <li>No + sign.</li> <li><code>-0</code> must be encoded as <code>0</code>.</li> <li>Integers and floats share the same normalization rules.</li> </ol> <p>Examples:</p> <pre><code>1.0    \u2192 1\n01.50  \u2192 1.5\n-0.000 \u2192 0\n</code></pre>"},{"location":"en/specs/cec-v1/#45-string-normalization","title":"4.5 String Normalization","text":"<ul> <li>All strings must be Unicode NFC after canonicalization.</li> <li>Escaping rules follow RFC8259 strictly.</li> <li>No control characters except via escape sequences.</li> </ul>"},{"location":"en/specs/cec-v1/#46-boolean-normalization","title":"4.6 Boolean Normalization","text":"<p>Booleans are always:</p> <pre><code>true\nfalse\n</code></pre> <p>(lowercase, ASCII).</p>"},{"location":"en/specs/cec-v1/#47-list-normalization","title":"4.7 List Normalization","text":"<p>Lists may be:</p> <ul> <li>order-preserving if the schema defines semantic order</li> <li>sorted lexicographically if order is not semantically meaningful</li> <li>CEC requires each schema field to declare:</li> </ul> <pre><code>\"ordering\": \"preserved\" | \"sorted\"\n</code></pre> <p>Default = <code>\"preserved\"</code>.</p>"},{"location":"en/specs/cec-v1/#48-deterministic-representation-of-nested-structures","title":"4.8 Deterministic Representation of Nested Structures","text":"<p>All rules apply recursively.</p>"},{"location":"en/specs/cec-v1/#5-canonical-envelope-structure-required-metadata","title":"5. Canonical Envelope Structure (Required Metadata)","text":"<p>Every CEP object that participates in hashing MUST include:</p> <ul> <li>\"cecVersion\" \u2014 version string (e.g., \"1.0.0\").</li> <li>\"schemaVersion\" \u2014 version of the CEP schema used.</li> <li>\"vocabularyVersion\" \u2014 list or mapping of vocab versions used.</li> <li>\"adapterVersion\" \u2014 version of the adapter that produced the record.</li> </ul> <p>This ensures hashes remain interpretable even as schemas change.</p>"},{"location":"en/specs/cec-v1/#6-versioning-rules-formal-versioning-structure","title":"6. Versioning Rules (Formal Versioning Structure)","text":"<p>CEC itself must be versioned using SemVer:</p> <ul> <li>MAJOR: breaking changes</li> <li>MINOR: behavior additions that preserve determinism</li> <li>PATCH: clarifications or typo fixes</li> </ul> <p>Every CEP structure hashed MUST include:</p> <ul> <li>\"cecVersion\" \u2014 the version used to transform it into bytes</li> <li>\"schemaVersion\" \u2014 because schemas change</li> <li>\"vocabularyVersion\" \u2014 because vocabularies evolve</li> <li>\"adapterVersion\" \u2014 because adapter logic changes</li> </ul> <p>Guaranteed Property:</p> <p>For any fixed {cecVersion, schemaVersion, vocabularyVersion, adapterVersion}, the hash of a CEP structure is deterministic across all implementations.</p> <p>This is the backbone of verifiable civic data.</p>"},{"location":"en/specs/cec-v1/#7-example-canonical-byte-representation","title":"7. Example Canonical Byte Representation","text":"<p>Input structure:</p> <pre><code>{\n    \"legalName\": \"City of Springfield\",\n    \"identifiers\": {\n        \"snfei\": { \"value\": \"abc123\" },\n        \"localId\": null\n    },\n    \"status\": { \"statusCode\": \"ACTIVE\", \"statusEffectiveDate\": \"1900-01-01\" }\n}\n</code></pre> <p>After CEP canonicalization \u2192 CEC v1 serialization:</p> <pre><code>{\n    \"cecVersion\": \"1.0.0\",\n    \"identifiers\": { \"snfei\": { \"value\": \"abc123\" } },\n    \"legalName\": \"City of Springfield\",\n    \"status\": { \"statusCode\": \"ACTIVE\", \"statusEffectiveDate\": \"1900-01-01\" }\n}\n</code></pre> <p>Observe:</p> <ul> <li>keys sorted</li> <li>null field removed</li> <li>minimal whitespace</li> <li>no formatting differences</li> </ul>"},{"location":"en/specs/efs-v1/","title":"Entity Fingerprint Specification (EFS v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP Entity types across all civic domains</p> <p>Purpose: Define a deterministic, minimal, cross-domain identity model for civic entities.</p>"},{"location":"en/specs/efs-v1/#1-overview","title":"1. Overview","text":"<p>The Entity Fingerprint Specification (EFS) defines the minimal set of canonical features that uniquely identify an entity within CEP. The fingerprint:</p> <ul> <li>is derived after canonicalization (rewriting),</li> <li>is serialized using CEC v1,</li> <li>is hashed to produce the verifiableId,</li> <li>remains stable across domains, sources, adapters, and time.</li> </ul> <p>The fingerprint is domain-agnostic, strategy-governed, and minimal \u2014 no descriptive or non-identity metadata is included.</p>"},{"location":"en/specs/efs-v1/#2-goals","title":"2. Goals","text":"<p>The fingerprint must:</p> <ul> <li>produce identical results across all implementations</li> <li>be stable across adapter versions (unless identity rules change)</li> <li>be independent of source formatting</li> <li>be invariant under non-identity attribute changes (e.g., address, status, phone number)</li> <li>support cross-domain deduplication and linking</li> <li>encode only essential identity-defining attributes</li> </ul> <p>The fingerprint is not a record; it is an identity contract.</p>"},{"location":"en/specs/efs-v1/#3-canonical-fingerprint-object-structure","title":"3. Canonical Fingerprint Object Structure","text":"<p>Every CEP Entity must generate a fingerprint object of the form:</p> <pre><code>{\n    \"entityTypeUri\": \"&lt;URI&gt;\",\n    \"jurisdictionFingerprint\": \"&lt;object | null&gt;\",\n    \"identifierFingerprint\": \"&lt;object&gt;\",\n    \"nameFingerprint\": \"&lt;object&gt;\",\n    \"schemaVersion\": \"&lt;semver&gt;\",\n    \"vocabularyVersion\": \"&lt;mapping of vocab domains&gt;\",\n    \"fingerprintVersion\": \"1.0.0\"\n}\n</code></pre> <p>This object is then CEC-serialized and hashed, yielding:</p> <p><code>verifiableId = CTag(hash(CEC(fingerprintObject)))</code></p> <p>Each sub-fingerprint is defined below.</p>"},{"location":"en/specs/efs-v1/#4-identifier-fingerprint-required","title":"4. Identifier Fingerprint (Required)","text":"<p>Identifiers are the strongest signal of identity.</p> <p>Rules:</p> <ol> <li> <p>Each entityType defines a list of primary identifier schemes    (e.g.,</p> </li> <li> <p>SNFEI (CEP universal entity ID),</p> </li> <li>FEC committee ID,</li> <li>EPA facility ID,</li> <li>IPEDS institution ID,</li> <li>LEI for legal entities,</li> <li> <p>National corporate registry IDs).</p> </li> <li> <p>The fingerprint MUST include all canonical identifiers available, after rewriting.</p> </li> <li> <p>Identifiers MUST be represented as:</p> </li> </ol> <pre><code>{\n    \"&lt;scheme&gt;\": \"&lt;canonicalValue&gt;\"\n}\n</code></pre> <p>4.Identifiers are sorted by key lexicographically (CEC rule).</p> <ol> <li>Absent identifiers are omitted, not null.</li> </ol> <p>Example:</p> <pre><code>{\n    \"snfei\": \"34486b...\",\n    \"fecId\": \"C12345678\"\n}\n</code></pre>"},{"location":"en/specs/efs-v1/#5-name-fingerprint-required-for-entities-with-names","title":"5. Name Fingerprint (Required for entities with names)","text":"<p>Names are rewritten using the full CEP canonicalization pipeline:</p> <ul> <li> <p>lowercase,</p> </li> <li> <p>uniform spacing,</p> </li> <li> <p>punctuation removal (post abbreviation expansion),</p> </li> <li> <p>locale-aware handling of accronyms / corporate forms,</p> </li> <li> <p>Unicode NFC.</p> </li> </ul> <p>The fingerprint includes:</p> <pre><code>{\n    \"legalNameNormalized\": \"&lt;string&gt;\"\n}\n</code></pre> <p>For individuals, this becomes:</p> <pre><code>{\n    \"familyName\": \"...\",\n    \"givenName\": \"...\",\n    \"additionalNames\": \"...\",\n    \"normalizedFullName\": \"...\"\n}\n</code></pre> <p>Names are generally weaker evidence than identifiers but essential when identifiers are missing or unreliable.</p>"},{"location":"en/specs/efs-v1/#6-jurisdiction-fingerprint-optional-but-recommended","title":"6. Jurisdiction Fingerprint (Optional but Recommended)","text":"<p>Many civic entities only make sense within a jurisdictional context (cities, counties, permits, schools, etc.).</p> <p>If the entity has a jurisdiction:</p> <pre><code>{\n    \"jurisdictionUri\": \"&lt;canonical URI&gt;\"\n}\n</code></pre> <p>If jurisdiction is not applicable, then omit.</p>"},{"location":"en/specs/efs-v1/#7-what-is-not-allowed-in-the-fingerprint","title":"7. What is not allowed in the fingerprint","text":"<p>Fingerprint must exclude:</p> <ul> <li>addresses</li> <li>dates</li> <li>statuses</li> <li>revision numbers</li> <li>descriptions</li> <li>contact information</li> <li>provenance</li> <li>relationships</li> <li>email, phone, geo</li> <li>filing history</li> <li>members / officers / associates</li> </ul> <p>These are attributes, not identity.</p> <p>This strict minimalism is what prevents identity drift over time.</p>"},{"location":"en/specs/efs-v1/#8-determinism-requirements","title":"8. Determinism Requirements","text":"<p>The fingerprint MUST be:</p> <ul> <li>constructed after canonicalization</li> <li>stable across all platforms</li> <li>CEC-serialized</li> <li>independent of representation or ordering</li> <li>stable across descriptive changes</li> <li>variant only if identity-defining attributes change</li> </ul> <p>Example:</p> <p>If a municipality changes its address or mayor, the entity\u2019s fingerprint stays the same.</p>"},{"location":"en/specs/efs-v1/#9-fingerprint-versioning-formal-versioning-structure","title":"9. Fingerprint Versioning (Formal Versioning Structure)","text":"<p>Fingerprint rules evolve slowly and must be versioned explicitly.</p> <p>Each fingerprint includes:</p> <pre><code>\"fingerprintVersion\": \"1.0.0\"\n</code></pre> <p>Semantic versioning rules:</p> <ul> <li>MAJOR: changes to identity rules (breaking identity linkage)</li> <li>MINOR: addition of optional fingerprint components</li> <li>PATCH: clarifications or bugfixes</li> </ul> <p>Every hashed verifiableId implicitly commits to:</p> <ul> <li>CEC version</li> <li>Schema version</li> <li>Vocabulary version(s)</li> <li>Fingerprint version</li> </ul> <p>This ensures verifiers can always interpret a fingerprint from any year.</p>"},{"location":"en/specs/efs-v1/#10-example-fingerprint-object-municipality","title":"10. Example Fingerprint Object (Municipality)","text":"<p>Before hashing:</p> <pre><code>{\n    \"entityTypeUri\": \"https://\u2026/entity-type/municipality\",\n    \"jurisdictionFingerprint\": { \"jurisdictionUri\": \"US-IL\" },\n    \"identifierFingerprint\": {\n        \"snfei\": \"34486b...ca5b3\"\n    },\n    \"nameFingerprint\": {\n        \"legalNameNormalized\": \"city of springfield\"\n    },\n    \"schemaVersion\": \"1.0.0\",\n    \"vocabularyVersion\": { \"entityType\": \"1.0.0\" },\n    \"fingerprintVersion\": \"1.0.0\"\n}\n</code></pre> <p>CEC \u2192 hash \u2192 CTag \u2192 verifiableId.</p>"},{"location":"en/specs/efs-v1/#multiple-domains-one-fingerprint-system","title":"Multiple Domains, One Fingerprint System","text":"<ul> <li>Campaign finance \u2192 donors, committees</li> <li>Environmental \u2192 facilities, permits</li> <li>Education \u2192 institutions, programs</li> </ul> <p>All of them use the exact same fingerprint structure.</p> <p>Only the content varies.</p> <p>This unifies CEP across domains and ensures cross-domain linkability.</p>"},{"location":"en/specs/gic-v1/","title":"Global Integrity Constraints (GIC v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP entities, relationships, provenance graphs, adapters, and envelopes</p> <p>Purpose: Define system-wide invariants that must hold for CEP data to be valid, canonicalizable, interoperable, and verifiable.</p>"},{"location":"en/specs/gic-v1/#1-overview","title":"1. Overview","text":"<p>The Civic Exchange Protocol (CEP) unifies multiple rewriting systems across domains (canonicalization, adapters, fingerprints, provenance, graph merging, and hashing). Global Integrity Constraints (GIC) define the cross-cutting rules that govern all CEP data and transformations. They ensure that:</p> <ul> <li>identities remain stable and non-ambiguous</li> <li>relationships are consistent and well-formed</li> <li>provenance is coherent and auditable</li> <li>graph normalization yields deterministic results</li> <li>CTags and fingerprints remain trustworthy</li> <li>versioning is explicit and reproducible</li> </ul> <p>These constraints are mandatory. Any violation indicates an invalid record, invalid adapter output, or corrupted graph.</p>"},{"location":"en/specs/gic-v1/#2-identity-integrity-constraints","title":"2. Identity Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#21-unique-verifiable-identifier","title":"2.1 Unique Verifiable Identifier","text":"<p>Every entity MUST have exactly one <code>verifiableId</code>, produced via:</p> <ol> <li>canonicalization</li> <li>fingerprint construction</li> <li>CEC encoding</li> <li>cryptographic hashing</li> </ol> <p><code>verifiableId</code> MUST be globally unique for entities with distinct fingerprints.</p>"},{"location":"en/specs/gic-v1/#22-stability-under-attribute-change","title":"2.2 Stability Under Attribute Change","text":"<p>An entity\u2019s <code>verifiableId</code> MUST remain unchanged if:</p> <ul> <li>addresses change</li> <li>phone/email change</li> <li>officers or membership change</li> <li>descriptive fields change</li> <li>statuses change (ACTIVE \u2192 INACTIVE)</li> </ul> <p>Only identity-defining attributes may influence the fingerprint.</p>"},{"location":"en/specs/gic-v1/#23-deterministic-cross-domain-identity","title":"2.3 Deterministic Cross-Domain Identity","text":"<p>If entity A in one domain and entity B in another are representing the same real-world entity, then their fingerprints MUST normalize to the same value. If fingerprints differ, entities MUST be treated as distinct.</p>"},{"location":"en/specs/gic-v1/#3-relationship-integrity-constraints","title":"3. Relationship Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#31-referential-integrity","title":"3.1 Referential Integrity","text":"<p>All relationships MUST reference existing entities using their canonical verifiableId. No relationship may point to a:</p> <ul> <li>blank/empty ID</li> <li>temporary/local ID</li> <li>non-existent entity</li> </ul>"},{"location":"en/specs/gic-v1/#32-type-consistency","title":"3.2 Type Consistency","text":"<p>A relationship\u2019s <code>relationshipTypeUri</code> MUST be compatible with the types of the referenced entities. For example:</p> <p>committeeRepresentsCandidate(Committee, Candidate)</p> <p>may not be applied to:</p> <p>committeeRepresentsCandidate(School, City)</p> <p>Type compatibility follows domain vocabulary definitions.</p>"},{"location":"en/specs/gic-v1/#33-cardinality-rules","title":"3.3 Cardinality Rules","text":"<p>Each relationship type MUST specify its cardinality:</p> <ul> <li>one-to-one</li> <li>one-to-many</li> <li>many-to-many</li> </ul> <p>Adapters MUST enforce these constraints.</p>"},{"location":"en/specs/gic-v1/#34-relationship-symmetry-antisymmetry-directionality","title":"3.4 Relationship Symmetry / Antisymmetry / Directionality","text":"<p>If a relationship vocabulary declares:</p> <ul> <li>symmetric</li> <li>antisymmetric</li> <li>directional</li> <li>inverse-of</li> </ul> <p>then every instance MUST satisfy that constraint.</p> <p>Example:</p> <p>If <code>parentOf</code> is antisymmetric, we must forbid:</p> <pre><code>parentOf(A, B)\nparentOf(B, A)\n</code></pre> <p>unless <code>A = B</code> and the vocabulary allows reflexive relations.</p>"},{"location":"en/specs/gic-v1/#4-fingerprint-and-hash-integrity-constraints","title":"4. Fingerprint and Hash Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#41-deterministic-fingerprints","title":"4.1 Deterministic Fingerprints","text":"<p>Fingerprints MUST be reproducible across languages, platforms, and implementations.</p>"},{"location":"en/specs/gic-v1/#42-canonical-encoding-required","title":"4.2 Canonical Encoding Required","text":"<p>Only CEC v1 (or later explicitly declared versions) may be used to produce bytes for hashing.</p>"},{"location":"en/specs/gic-v1/#43-metadata-commitment","title":"4.3 Metadata Commitment","text":"<p>Each hash MUST commit to:</p> <ul> <li><code>cecVersion</code></li> <li><code>schemaVersion</code></li> <li><code>vocabularyVersion</code></li> <li><code>adapterVersion</code></li> <li><code>fingerprintVersion</code></li> </ul> <p>If any of these change, fingerprints may change or be non-interoperable.</p>"},{"location":"en/specs/gic-v1/#44-no-hidden-fields","title":"4.4 No Hidden Fields","text":"<p>No field outside the fingerprint structure may influence the hash.</p>"},{"location":"en/specs/gic-v1/#5-provenance-integrity-constraints","title":"5. Provenance Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#51-provenance-completeness","title":"5.1 Provenance Completeness","text":"<p>Every entity and relationship MUST retain provenance sufficient to answer:</p> <ul> <li>Who created this record?</li> <li>Which adapter(s) produced it?</li> <li>When was the transformation performed?</li> <li>What version of the schema/vocab was used?</li> </ul>"},{"location":"en/specs/gic-v1/#52-temporal-monotonicity","title":"5.2 Temporal Monotonicity","text":"<p>If an activity uses an input and generates an output:</p> <p><code>used(entity) \u2192 activity \u2192 wasGeneratedBy(entity)</code></p> <p>then:</p> <p><code>timestamp(used.input) \u2264 timestamp(activity) \u2264 timestamp(wasGeneratedBy.output)</code></p>"},{"location":"en/specs/gic-v1/#53-activity-determinism","title":"5.3 Activity Determinism","text":"<p>Provenance activities MUST reflect deterministic adapter behavior.</p> <p>No activity may claim a transformation occurred without referencing the adapter that performed it.</p>"},{"location":"en/specs/gic-v1/#6-graph-integrity-constraints","title":"6. Graph Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#61-graph-validity","title":"6.1 Graph Validity","text":"<p>A graph is valid if:</p> <ul> <li>all nodes have canonical IDs</li> <li>all edges connect existing nodes</li> <li>all payloads satisfy schema</li> <li>the graph normalizes correctly under GNS</li> </ul>"},{"location":"en/specs/gic-v1/#62-no-dangling-edges","title":"6.2 No Dangling Edges","text":"<p>Edges MUST not reference deleted or unresolvable nodes.</p>"},{"location":"en/specs/gic-v1/#63-no-cycles-in-provenance-dag","title":"6.3 No Cycles in Provenance DAG","text":"<p>Provenance graphs MUST be directed acyclic graphs.</p> <p>Cycles violate causality.</p>"},{"location":"en/specs/gic-v1/#64-idempotent-graph-normalization","title":"6.4 Idempotent Graph Normalization","text":"<p>Normalizing an already normalized graph MUST yield identical bytes.</p>"},{"location":"en/specs/gic-v1/#7-adapter-integrity-constraints","title":"7. Adapter Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#71-version-declaration","title":"7.1 Version Declaration","text":"<p>All adapters MUST emit:</p> <ul> <li><code>adapterId</code></li> <li><code>adapterVersion</code></li> </ul>"},{"location":"en/specs/gic-v1/#72-total-determinism-for-valid-inputs","title":"7.2 Total Determinism for Valid Inputs","text":"<p>Given valid input <code>x</code>:</p> <p><code>A(x) = y</code></p> <p>must always produce the same <code>y</code>.</p>"},{"location":"en/specs/gic-v1/#73-typed-partiality","title":"7.3 Typed Partiality","text":"<p>Errors MUST be explicit, typed, and reproducible.</p>"},{"location":"en/specs/gic-v1/#74-composition-rules","title":"7.4 Composition Rules","text":"<p>Adapter pipelines MUST respect adapter algebra composition and version-compatibility.</p>"},{"location":"en/specs/gic-v1/#8-cross-version-integrity-constraints","title":"8. Cross-Version Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#81-version-awareness","title":"8.1 Version Awareness","text":"<p>Every CEP record MUST declare:</p> <ul> <li><code>schemaVersion</code></li> <li><code>vocabularyVersion</code></li> <li><code>adapterVersion</code></li> <li><code>cecVersion</code></li> <li><code>fingerprintVersion</code></li> <li><code>gnsVersion</code> (if graph-level)</li> </ul>"},{"location":"en/specs/gic-v1/#82-monotonic-version-evolution","title":"8.2 Monotonic Version Evolution","text":"<p>Adapters MAY target:</p> <ul> <li>the same version</li> <li>or a compatible future version</li> </ul> <p>They MUST NOT mix incompatible versions without a defined version-bridge adapter.</p>"},{"location":"en/specs/gic-v1/#83-consistency-under-updates","title":"8.3 Consistency Under Updates","text":"<p>Updating a schema or vocabulary MUST NOT retroactively break previously valid records. Backwards-compatible evolution requires:</p> <ul> <li>versioned vocabularies</li> <li>explicit deprecation</li> <li>backwards-compatible adapters</li> </ul>"},{"location":"en/specs/gic-v1/#9-summary","title":"9. Summary","text":"<p>These Global Integrity Constraints define the invariants required for CEP to be:</p> <ul> <li>deterministic</li> <li>interoperable</li> <li>identity-stable</li> <li>graph-stable</li> <li>hash-verifiable</li> <li>provenance-complete</li> </ul> <p>Any valid CEP dataset, entity, graph, or exchange MUST satisfy these constraints.</p>"},{"location":"en/specs/gns-v1/","title":"Graph Normalization Specification (GNS v1)","text":"<p>Version: 1.0.0 Status: Draft Applies to: CEP entity graphs, provenance graphs, and merged graphs Purpose: Define a deterministic normal form for CEP graphs so that equivalent graphs produce identical canonical representations and hashes.</p>"},{"location":"en/specs/gns-v1/#1-overview","title":"1. Overview","text":"<p>CEP represents civic data as graphs:</p> <ul> <li>Entity graphs: entities, relationships, and their links.  </li> <li>Provenance graphs: entities, activities, and agents (PROV-style).  </li> <li>Merged graphs: combined views over multiple sources and versions.</li> </ul> <p>The Graph Normalization Specification (GNS) defines how to:</p> <ol> <li>Represent graphs in a uniform structural model.  </li> <li>Canonically label nodes that lack global identifiers.  </li> <li>Order nodes and edges deterministically.  </li> <li>Serialize graphs via CEC v1 for hashing and verification.  </li> <li>Guarantee that semantically equivalent graphs normalize to the same form.</li> </ol> <p>GNS is versioned independently from CEC, schemas, and vocabularies.</p>"},{"location":"en/specs/gns-v1/#2-graph-model","title":"2. Graph Model","text":""},{"location":"en/specs/gns-v1/#21-nodes","title":"2.1 Nodes","text":"<p>Each node has:</p> <ul> <li><code>nodeId</code>: a string identifier (global or canonical local)  </li> <li><code>nodeType</code>: one of  </li> <li><code>entity</code> </li> <li><code>relationship</code> </li> <li><code>activity</code> </li> <li><code>agent</code> </li> <li><code>envelope</code> (optional, for packaging)  </li> <li><code>payload</code>: a CEC-compatible JSON object containing the node\u2019s attributes</li> </ul> <p>Entity nodes should carry their <code>verifiableId</code> (from EFS) in the payload.</p>"},{"location":"en/specs/gns-v1/#22-edges","title":"2.2 Edges","text":"<p>Each edge has:</p> <ul> <li><code>sourceNodeId</code> </li> <li><code>targetNodeId</code> </li> <li><code>edgeType</code>: a label (e.g., <code>used</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, <code>hasRelationship</code>, <code>participatesIn</code>, domain-specific relationship types)  </li> <li><code>edgePayload</code>: optional attributes (e.g., role labels, qualifiers)</li> </ul>"},{"location":"en/specs/gns-v1/#23-graph","title":"2.3 Graph","text":"<p>A graph <code>G</code> is:</p> <pre><code>{\n  \"graphId\": \"&lt;optional, see hashing&gt;\",\n  \"nodes\": [ ... ],\n  \"edges\": [ ... ],\n  \"graphMetadata\": {\n    \"gnsVersion\": \"1.0.0\",\n    \"cecVersion\": \"1.0.0\",\n    \"schemaVersions\": { \"...\": \"...\" },\n    \"vocabularyVersions\": { \"...\": \"...\" }\n  }\n}\n</code></pre> <p>The normalization process produces a canonical graph object of this shape.</p>"},{"location":"en/specs/gns-v1/#3-goals-of-graph-normalization","title":"3. Goals of Graph Normalization","text":"<p>GNS aims to ensure that:</p> <p>Determinism For a fixed input graph semantics and version tuple, every implementation produces the same normalized graph.</p> <p>Idempotence Normalizing an already normalized graph yields the identical graph.</p> <p>Equivalence Graphs that differ only by node-labeling or edge ordering but represent the same structure normalize to the same canonical form.</p> <p>Hash stability The normalized graph can be CEC-serialized and hashed to yield a stable graph-level CTag.</p>"},{"location":"en/specs/gns-v1/#4-node-identity-and-labeling","title":"4. Node Identity and Labeling","text":""},{"location":"en/specs/gns-v1/#41-entity-nodes","title":"4.1 Entity Nodes","text":"<p>Entity nodes have stable global identifiers.</p> <p>The payload MUST include:</p> <ul> <li><code>verifiableId</code> (from the Entity Fingerprint Specification)  </li> <li><code>entityTypeUri</code></li> </ul> <p>The <code>nodeId</code> for entity nodes MUST be set to <code>verifiableId</code>.</p> <p>No relabeling is required for entity nodes.</p>"},{"location":"en/specs/gns-v1/#42-non-entity-nodes-activities-agents-relationships-envelopes","title":"4.2 Non-Entity Nodes (Activities, Agents, Relationships, Envelopes)","text":"<p>Non-entity nodes may not have globally stable IDs. For such nodes, GNS defines a canonical local ID computed from:</p> <ul> <li>The node\u2019s type  </li> <li>A deterministic summary of its payload  </li> <li>The multiset of incident edges (types + endpoint identifiers)  </li> <li>Optional timestamps where present  </li> </ul> <p>Canonical local ID:</p> <pre><code>canonicalLocalId = \"gns:\" || base64url( H( summary(node) ) )\n</code></pre> <p>Where <code>summary(node)</code> is a CEC-serialized JSON object:</p> <ul> <li><code>nodeType</code> </li> <li><code>payload</code> (CEC-normalized)  </li> <li><code>incidentEdges</code>: a sorted list of <code>{ edgeType, direction, otherNodeId }</code></li> </ul> <p>Hash function <code>H</code> is typically SHA-256.</p> <p><code>base64url</code> is standard URL-safe Base64 encoding.</p> <p>incidentEdges sorting order:</p> <ol> <li><code>edgeType</code> </li> <li><code>direction</code> (\"in\" or \"out\")  </li> <li><code>otherNodeId</code></li> </ol>"},{"location":"en/specs/gns-v1/#43-labeling-procedure-and-fixed-point","title":"4.3 Labeling Procedure and Fixed Point","text":"<p>Because non-entity node labels depend on incident edges and incident edges depend on node labels, GNS defines a fixed-point procedure:</p> <p>Initial labeling</p> <ul> <li>Entity nodes: <code>nodeId = verifiableId</code> </li> <li>Non-entity nodes: temporary IDs (internal indices)</li> </ul> <p>Procedure</p> <ol> <li>Compute summaries for all non-entity nodes using current IDs.  </li> <li>Compute canonicalLocalId for each non-entity node.  </li> <li>Replace temporary IDs with canonicalLocalId.  </li> <li>Rebuild edges with updated sourceNodeId / targetNodeId.</li> </ol> <p>This converges in one iteration because:</p> <ul> <li>entity IDs are stable  </li> <li>each non-entity ID depends only on:</li> <li>node type  </li> <li>payload  </li> <li>incident edges with stable entity IDs and previously computed local IDs  </li> </ul> <p>Implementations MUST perform at least one full pass. A second pass MUST produce identical results (idempotence).</p>"},{"location":"en/specs/gns-v1/#5-edge-normalization","title":"5. Edge Normalization","text":"<p>After node IDs are canonical:</p> <p>For each edge:</p> <ul> <li>Ensure <code>sourceNodeId</code> and <code>targetNodeId</code> use canonical IDs.  </li> <li>Canonicalize <code>edgePayload</code> via CEP normalization + CEC.  </li> </ul> <p>Sort edges by:</p> <ol> <li><code>edgeType</code> </li> <li><code>sourceNodeId</code> </li> <li><code>targetNodeId</code> </li> <li><code>CEC(edgePayload)</code> </li> </ol> <p>If <code>edgePayload</code> is absent, treat it as <code>{}</code> for CEC.</p>"},{"location":"en/specs/gns-v1/#6-node-list-normalization","title":"6. Node List Normalization","text":"<p>After node IDs are canonical:</p> <ul> <li>Canonicalize each <code>payload</code> via CEP normalization + CEC.  </li> <li> <p>Sort nodes by:</p> </li> <li> <p><code>nodeType</code> </p> </li> <li><code>nodeId</code> </li> <li><code>CEC(payload)</code> </li> </ul>"},{"location":"en/specs/gns-v1/#7-canonical-graph-serialization","title":"7. Canonical Graph Serialization","text":"<p>Construct the graph object:</p> <pre><code>{\n  \"graphMetadata\": {\n    \"gnsVersion\": \"1.0.0\",\n    \"cecVersion\": \"&lt;cecVersion used&gt;\",\n    \"schemaVersions\": { ... },\n    \"vocabularyVersions\": { ... }\n  },\n  \"nodes\": [ ... ],\n  \"edges\": [ ... ]\n}\n</code></pre> <p>Serialize via CEC v1:</p> <ul> <li>lexicographic key ordering  </li> <li>omit <code>null</code> values  </li> <li>normalize numbers, strings, lists per CEC  </li> </ul> <p>The result is the canonical graph JSON.</p>"},{"location":"en/specs/gns-v1/#8-graph-hash-and-graph-level-ctag","title":"8. Graph Hash and Graph-Level CTag","text":"<pre><code>graphHash = H( CEC(graphObject) )\ngraphTag  = \"cep-graph:\" || base64url(graphHash)\n</code></pre> <p>Uses:</p> <ul> <li>as a <code>graphId</code> </li> <li>as a provenance reference  </li> <li>for caching and deduplication  </li> </ul>"},{"location":"en/specs/gns-v1/#9-recursion-guards-and-idempotence","title":"9. Recursion Guards and Idempotence","text":"<p>Implementations MUST ensure:</p> <ul> <li>Idempotence: normalizing a normalized graph yields identical output.  </li> <li>No recursive expansion: do not re-run canonicalization or adapters.  </li> <li>Finite behavior: normalization must terminate for all finite graphs.  </li> <li>Order of operations: all canonicalization must occur before graph normalization begins.</li> </ul>"},{"location":"en/specs/gns-v1/#10-relationship-to-other-cep-specifications","title":"10. Relationship to Other CEP Specifications","text":"<p>GNS builds upon:</p> <ul> <li>Canonical Encoding (CEC v1) </li> <li>Entity Fingerprint Specification (EFS v1) </li> <li>Adapter Algebra Specification (AAS v1) </li> </ul> <p>GNS ensures graph-level determinism and hashing; it does not redefine canonicalization or adapter semantics.</p>"},{"location":"en/specs/gns-v1/#11-versioning","title":"11. Versioning","text":"<p>Semantic versioning:</p> <ul> <li>MAJOR: breaking changes  </li> <li>MINOR: backward-compatible additions  </li> <li>PATCH: clarifications, editorial fixes  </li> </ul> <p>Every normalized graph MUST include:</p> <pre><code>\"graphMetadata\": {\n  \"gnsVersion\": \"1.0.0\",\n  ...\n}\n</code></pre>"},{"location":"en/specs/gns-v1/#12-summary","title":"12. Summary","text":"<p>GNS v1 defines:</p> <ul> <li>a uniform CEP graph model  </li> <li>canonical labeling for non-entity nodes  </li> <li>deterministic node and edge ordering  </li> <li>CEC-based canonical serialization  </li> <li>a graph-level CTag mechanism  </li> </ul> <p>These together provide a stable foundation for provenance, merges, cross-source entity graphs, and higher-level CEP reasoning.</p>"},{"location":"en/specs/vgs-v1/","title":"Versioning Governance Specification (VGS v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: CEP schemas, vocabularies, adapters, fingerprints, canonical encoding, graph normalization</p> <p>Purpose: Provide a coherent and formal approach to versioning in CEP, ensuring stability, backward compatibility, and long-term reproducibility.</p>"},{"location":"en/specs/vgs-v1/#1-overview","title":"1. Overview","text":"<p>CEP consists of several interacting specifications:</p> <ul> <li>Canonical encoding (CEC)</li> <li>Entity fingerprints (EFS)</li> <li>Adapter algebra (AAS)</li> <li>Graph normalization (GNS)</li> <li>Controlled vocabularies</li> <li>Domain schemas</li> <li>Adapters</li> </ul> <p>Each of these evolves over time. Versioning Governance Specification (VGS) defines:</p> <ul> <li>how each component is versioned  </li> <li>what kinds of changes are allowed in each version class  </li> <li>how components reference one another  </li> <li>how backward compatibility is maintained  </li> <li>how verifiable IDs remain interpretable over time  </li> </ul> <p>This is essential for the long-term stability of CEP data, hashes, and interoperability.</p>"},{"location":"en/specs/vgs-v1/#vocabulary-identification","title":"Vocabulary Identification","text":"<p>Each CEP vocabulary is a JSON document identified by its <code>$id</code> field.</p> <ul> <li>The canonical URI for a vocabulary is the value of <code>$id</code>.</li> <li>All references to a vocabulary (in schemas, adapters, and documentation) MUST use this URI.</li> <li>Vocabulary documents MUST include a <code>$schema</code> field pointing to <code>cep.vocabulary.schema.json</code>.</li> <li>No additional field (such as <code>vocabularyUri</code>) is required or permitted for the canonical URI.</li> </ul> <p>Tools MAY assert that <code>$id</code> is unique within a CEP deployment and SHOULD treat the <code>$id</code> value as the stable identifier for versioning, governance, and dependency resolution.</p>"},{"location":"en/specs/vgs-v1/#2-versioning-design-principles","title":"2. Versioning Design Principles","text":"<p>CEP versioning follows five principles:</p> <ol> <li>Explicitness: Every versionable artifact declares its version using Semantic Versioning (SemVer).</li> <li>Locality: Each artifact (schema, vocab, adapter, CEC, EFS, GNS) versions independently.</li> <li>Composability: Records embed a complete version tuple so verifiers can reconstruct semantics exactly.</li> <li>Backward Compatibility: New versions must not invalidate previously valid records except via clearly documented major version changes.</li> <li>Non-Interference: Changes in descriptive metadata must not affect identity or hashes.</li> </ol>"},{"location":"en/specs/vgs-v1/#3-semantic-versioning-model","title":"3. Semantic Versioning Model","text":"<p>CEP uses Semantic Versioning (SemVer):</p> <p>MAJOR.MINOR.PATCH</p>"},{"location":"en/specs/vgs-v1/#major","title":"MAJOR","text":"<p>Breaking changes:</p> <ul> <li>identity rules change (fingerprint rules)  </li> <li>canonicalization strategy changes in a way that affects output  </li> <li>renaming or removing vocabulary terms  </li> <li>schema structural changes  </li> <li>canonical encoding (CEC) incompatibility  </li> <li>graph normalization rule changes  </li> <li>adapter output semantics change  </li> </ul> <p>MAJOR versions should be rare.</p>"},{"location":"en/specs/vgs-v1/#minor","title":"MINOR","text":"<p>Backward-compatible changes:</p> <ul> <li>new optional fields  </li> <li>new vocabulary terms (non-breaking)  </li> <li>new adapters or extended adapter behavior that preserves old semantics  </li> <li>new relationship types  </li> <li>clarifications that do not change meaning  </li> </ul>"},{"location":"en/specs/vgs-v1/#patch","title":"PATCH","text":"<p>Non-semantic fixes:</p> <ul> <li>typos  </li> <li>documentation clarifications  </li> <li>test coverage changes  </li> <li>reformatting of examples  </li> </ul> <p>Hashes must not change across patches.</p>"},{"location":"en/specs/vgs-v1/#4-versioned-components","title":"4. Versioned Components","text":"Component Version Field Independent? Notes Canonical Encoding cecVersion Yes Must be stable across ecosystems Fingerprint Rules fingerprintVersion Yes Identity-critical Graph Normalization gnsVersion Yes Affects graph-level hashes Domain Schemas schemaVersion Yes Structural constraints Controlled Vocabularies vocabularyVersion Yes Must provide deprecation paths Adapters adapterVersion Yes Reproducibility of transformations <p>Every CEP record, fingerprint, and graph must carry all applicable version tags.</p>"},{"location":"en/specs/vgs-v1/#5-version-tuples-in-records","title":"5. Version Tuples in Records","text":"<p>Each CEP object (entity, relationship, envelope, graph) must embed:</p> <pre><code>{\n  \"versions\": {\n    \"cec\": \"1.0.0\",\n    \"fingerprint\": \"1.0.0\",\n    \"schema\": \"1.0.0\",\n    \"vocabulary\": { \"...\": \"1.0.0\" },\n    \"adapter\": \"1.0.0\",\n    \"gns\": \"1.0.0\"\n  }\n}\n</code></pre> <p>This version tuple makes it possible for a verifier to:</p> <ul> <li>reconstruct canonicalization  </li> <li>rebuild the fingerprint  </li> <li>normalize the graph  </li> <li>verify relationships  </li> <li>recreate the hash  </li> </ul> <p>for any record at any time in history.</p>"},{"location":"en/specs/vgs-v1/#6-version-compatibility-rules","title":"6. Version Compatibility Rules","text":""},{"location":"en/specs/vgs-v1/#61-schema-compatibility","title":"6.1 Schema Compatibility","text":"<p>A schema version may accept records from earlier MINOR/PATCH versions. MAJOR schema changes must include a migration adapter. Backfilling or reinterpretation is forbidden \u2014 migration must be explicit.</p>"},{"location":"en/specs/vgs-v1/#62-vocabulary-compatibility","title":"6.2 Vocabulary Compatibility","text":"<p>New vocabulary terms must not break existing records. Deprecated terms must not be reused. Vocabulary upgrades must specify:</p> <ul> <li>mappings for deprecated terms  </li> <li>migration semantics if necessary  </li> </ul>"},{"location":"en/specs/vgs-v1/#63-adapter-compatibility","title":"6.3 Adapter Compatibility","text":"<p>Composition remains valid only if target and source schema versions are compatible. Adapter upgrades may alter output formats only in MINOR or MAJOR versions. No adapter may silently target a new schema version without declaring it.</p>"},{"location":"en/specs/vgs-v1/#7-versioned-provenance","title":"7. Versioned Provenance","text":"<p>Each adapter activity must record:</p> <ul> <li>adapterId  </li> <li>adapterVersion  </li> <li>schemaVersions  </li> <li>vocabularyVersions  </li> <li>timestamp  </li> <li>optional inputFingerprint  </li> </ul> <p>Provenance must be version-stable: the same pipeline version tuple must always reconstruct the same output from the same input.</p>"},{"location":"en/specs/vgs-v1/#8-effects-on-hashes-and-identity","title":"8. Effects on Hashes and Identity","text":""},{"location":"en/specs/vgs-v1/#81-hash-interpretation","title":"8.1 Hash Interpretation","text":"<p>A hash is valid only in the context of the version tuple used to generate it. A verifier must use:</p> <ul> <li>cecVersion  </li> <li>fingerprintVersion  </li> <li>schemaVersion  </li> <li>vocabularyVersion  </li> <li>adapterVersion  </li> <li>gnsVersion  </li> </ul> <p>to re-derive the canonical bytes.</p>"},{"location":"en/specs/vgs-v1/#82-identity-stability","title":"8.2 Identity Stability","text":"<p>A change to:</p> <ul> <li>vocabulary labels  </li> <li>schema descriptive fields  </li> <li>adapter metadata  </li> <li>optional attributes  </li> </ul> <p>must not affect fingerprints or verifiable IDs.</p> <p>Only MAJOR fingerprint changes may alter identities.</p>"},{"location":"en/specs/vgs-v1/#9-version-migration-requirements","title":"9. Version Migration Requirements","text":"<p>Whenever a MAJOR version increases, VGS requires:</p> <ul> <li>migration adapters  </li> <li>mapping tables (old vocabulary \u2192 new vocabulary)  </li> <li>canonicalization compatibility notes  </li> <li>hash interpretation notes  </li> </ul> <p>Records must be convertible through deterministic, auditable, versioned adapters.</p> <p>Backward compatibility is achieved through:</p> <ul> <li>version-bridge adapters  </li> <li>provenance annotations  </li> <li>dual-version compatibility modes (optional)</li> </ul>"},{"location":"en/specs/vgs-v1/#10-long-term-guarantees","title":"10. Long-Term Guarantees","text":"<p>VGS ensures that:</p> <ul> <li>A CEP record from 2030 can still be verified in 2050.  </li> <li>A hash published today remains interpretable forever.  </li> <li>New domains (campaign finance, environmental, education) remain interoperable.  </li> <li>Schema/vocabulary evolution does not undermine reproducibility.  </li> <li>Fingerprints and graph-level hashes remain stable under descriptive changes.  </li> </ul>"},{"location":"en/specs/vgs-v1/#11-summary","title":"11. Summary","text":"<p>VGS v1 defines:</p> <ul> <li>independent versioning of major CEP components  </li> <li>explicit version tuples in records  </li> <li>semantic rules for MAJOR/MINOR/PATCH  </li> <li>backward-compatibility constraints  </li> <li>migration paths for incompatible updates  </li> </ul> <p>This versioning framework ensures CEP remains a reproducible, extensible, and audit-ready civic data infrastructure.</p>"},{"location":"en/vocabulary/overview/","title":"Domain-Specific Vocabularies in CEP","text":"<p>Domain-specific vocabularies extend the core CEP vocabulary layer with additional semantic detail for particular civic and regulatory domains. They provide structured, stable identifiers for the concepts that matter within a domain while remaining compatible with CEP\u2019s shared graph model.</p> <p>These vocabularies do not redefine CEP data structures. Instead, they supply specialized labels that domain adapters, schemas, and analysis tools can use to describe:</p> <ul> <li>the types of entities present in a domain  </li> <li>the types of relationships that meaningfully link them  </li> <li>the terms used to classify events, roles, statuses, processes, or outcomes</li> </ul> <p>This allows each domain to speak its own language without fragmenting the global model.</p>"},{"location":"en/vocabulary/overview/#why-domain-vocabularies-exist","title":"Why Domain Vocabularies Exist","text":"<p>A single \u201cuniversal\u201d vocabulary cannot capture the detail required across all civic domains. Campaign finance, environmental regulation, education, procurement, elections, nonprofit filings, and transportation each involve:</p> <ul> <li>different classes of actors  </li> <li>different forms of interaction  </li> <li>different regulatory structures  </li> <li>different types of documents, permits, filings, or transactions</li> </ul> <p>Domain vocabularies allow CEP to represent these differences without changing the underlying schemas. Every domain can introduce terms that matter locally while still interoperating globally.</p>"},{"location":"en/vocabulary/overview/#relationship-to-core-cep-vocabularies","title":"Relationship to Core CEP Vocabularies","text":"<p>Domain vocabularies refine the core vocabulary, not replace it.</p> <ul> <li> <p>Core vocabularies define fundamental concepts: <code>PERSON</code>, <code>ORGANIZATION</code>, <code>PROGRAM</code>, <code>PROCESS</code>, <code>EVENT</code>, <code>AGREEMENT</code>, <code>RELATIONSHIP_TYPE</code>, etc.</p> </li> <li> <p>Domain vocabularies introduce more specific versions:   campaign finance committees, procurement buyers, educational institutions, environmental permits, and so on.</p> </li> </ul> <p>Each domain term maps back to a parent core term, which ensures:</p> <ul> <li>cross-domain interoperability  </li> <li>consistent canonicalization and graph normalization  </li> <li>unified search, analytics, and reasoning across datasets  </li> <li>compatibility with shared identity resolution frameworks</li> </ul> <p>This \u201crefinement but not divergence\u201d structure is central to CEP\u2019s ability to unify heterogeneous civic data ecosystems.</p>"},{"location":"en/vocabulary/overview/#how-domain-vocabularies-are-used","title":"How Domain Vocabularies Are Used","text":"<p>Adapters, schemas, and validation logic may rely on domain vocabularies to:</p> <ul> <li>label entities and relationships with precise semantics  </li> <li>standardize classification across jurisdictions  </li> <li>ensure that normalized output follows a consistent, governed taxonomy  </li> <li>enable automated reasoning or validation (e.g., \u201conly these entity types may appear in this schema\u201d)  </li> <li>support crosswalks and interoperability with external standards</li> </ul> <p>CEP itself does not prescribe which vocabularies must be used. Domains evolve independently through the Vocabulary Governance Specification (VGS) and may add or refine vocabularies over time.</p>"},{"location":"en/vocabulary/overview/#principles-for-domain-vocabulary-design","title":"Principles for Domain Vocabulary Design","text":"<p>To ensure long-term usability and stability, domain vocabularies follow several principles:</p> <ul> <li>Stability \u2014 vocabularies are versioned and immutable once released  </li> <li>Minimality \u2014 include terms only when they serve identifiable modeling needs  </li> <li>Extensibility \u2014 new terms can be safely introduced without breaking existing data  </li> <li>Interoperability \u2014 domain terms map cleanly to CEP core and, when applicable, to external standards  </li> <li>Clarity \u2014 definitions aim to be domain-neutral, jurisdiction-neutral, and implementation-independent  </li> </ul> <p>This keeps the vocabulary ecosystem manageable while allowing each domain to grow as needed.</p>"},{"location":"en/vocabulary/overview/#when-to-introduce-a-new-domain-vocabulary","title":"When to Introduce a New Domain Vocabulary","text":"<p>A new domain vocabulary is appropriate when:</p> <ul> <li>a domain contains entities or relationships not naturally expressible using only core vocabulary terms  </li> <li>adapters require finer-grained semantics to represent or normalize source data  </li> <li>a regulatory or analytical community uses a specialized taxonomy that merits a structured representation  </li> <li>interoperability with external standards benefits from explicit mappings  </li> </ul> <p>CEP encourages domain vocabularies where they add real semantic value\u2014and avoids them where core vocabularies suffice.</p>"},{"location":"en/vocabulary/overview/#summary","title":"Summary","text":"<p>Domain-specific vocabularies allow CEP to remain:</p> <ul> <li>flexible enough to model any civic domain  </li> <li>stable enough to maintain interoperability across domains  </li> <li>extensible enough to incorporate new sectors, jurisdictions, and standards  </li> <li>coherent as a unified rewriting and canonicalization framework</li> </ul> <p>By refining rather than rewriting the core model, domain vocabularies keep CEP grounded in a single, shared semantic foundation while empowering rich domain-specific modeling.</p>"},{"location":"en/vocabulary/using/","title":"Using Domain Vocabularies in CEP Schemas","text":"<p>Domain vocabularies play a central role in how CEP schemas represent civic data. They provide governed identifiers for entity types, relationship types, roles, statuses, and other semantic categories that appear within domain schemas and adapters.</p> <p>This document summarizes how domain vocabularies integrate with CEP schemas without listing any specific files, ensuring the guidance remains valid as domains evolve.</p>"},{"location":"en/vocabulary/using/#1-entities-in-domain-schemas","title":"1. Entities in Domain Schemas","text":"<p>When defining or normalizing entities in a domain schema:</p> <ul> <li>Assign an entity type URI from the appropriate domain vocabulary  </li> <li>Ensure each domain entity type maps to a parent core entity type </li> <li>Use the domain vocabulary to disambiguate between similar classes of entities that require distinct normalization or identity rules  </li> </ul> <p>This allows schemas to remain domain-specific in meaning while structurally consistent across CEP.</p>"},{"location":"en/vocabulary/using/#2-relationships-in-domain-schemas","title":"2. Relationships in Domain Schemas","text":"<p>Domain schemas use relationship type URIs to express how entities connect. Using vocabulary-governed relationship types ensures:</p> <ul> <li>relationship meaning is unambiguous  </li> <li>analytical systems can group or reason about relationships consistently  </li> <li>graph normalization (GNS) can enforce allowed structures  </li> <li>adapters avoid inventing ad-hoc or inconsistent names  </li> </ul> <p>Domain relationships inherit from core CEP relationship categories, supporting both specificity and interoperability.</p>"},{"location":"en/vocabulary/using/#3-avoiding-hard-coded-strings","title":"3. Avoiding Hard-Coded Strings","text":"<p>Schemas and adapters should never introduce arbitrary new strings to represent types. Instead:</p> <ul> <li>import term URIs from the domain vocabulary  </li> <li>reference them in JSON Schemas, model definitions, and adapter logic  </li> <li>rely on governance processes to introduce new terms when needed  </li> </ul> <p>This prevents drift, reduces validation failures, and keeps domain logic aligned with CEP core rules.</p>"},{"location":"en/vocabulary/using/#4-using-vocabularies-in-normalization-pipelines","title":"4. Using Vocabularies in Normalization Pipelines","text":"<p>Normalization steps typically:</p> <ol> <li>Classify source records using domain vocabulary terms  </li> <li>Rewrite or canonicalize values into stable term URIs  </li> <li>Validate the result against domain and core schemas  </li> <li>Construct canonical entities and relationships using vocabulary-driven types  </li> </ol> <p>Because vocabulary terms are globally known and versioned, normalized data becomes:</p> <ul> <li>portable across jurisdictions  </li> <li>comparable across datasets  </li> <li>durable over time  </li> </ul> <p>This is essential for CEP\u2019s multi-domain crosswalking and identity-resolution capabilities.</p>"},{"location":"en/vocabulary/using/#5-domain-vocabularies-and-adapter-design","title":"5. Domain Vocabularies and Adapter Design","text":"<p>Adapters should:</p> <ul> <li>import vocabulary terms directly  </li> <li>enforce vocabulary selection rules  </li> <li>avoid emitting entities or relationships without an assigned vocabulary-based type  </li> </ul> <p>Adapter manifests may declare which domain vocabularies they rely on, enabling:</p> <ul> <li>automated validation  </li> <li>compatibility checks  </li> <li>dependency resolution in multi-adapter pipelines  </li> </ul> <p>Domain schemas remain concise because semantics live in the vocabularies, not in the schema structure.</p>"},{"location":"en/vocabulary/using/#6-domain-vocabularies-and-canonicalization","title":"6. Domain Vocabularies and Canonicalization","text":"<p>CEP\u2019s canonicalization rules (CEC, GNS, EFS, GIC, etc.) rely on stable term URIs. Domain vocabularies support canonicalization by:</p> <ul> <li>constraining allowable entity and relationship types  </li> <li>enabling cross-domain reasoning (\u201cthis entity is a subtype of ORGANIZATION\u201d)  </li> <li>giving canonicalization functions predictable input categories  </li> <li>informing identity rules (e.g., a PP_SUPPLIER and CF_CONTRIBUTOR may share identity logic as ORGANIZATION types)  </li> </ul> <p>Canonicalization becomes domain-aware without losing global coherence.</p>"},{"location":"en/vocabulary/using/#7-schema-stability-through-vocabulary-versioning","title":"7. Schema Stability Through Vocabulary Versioning","text":"<p>Because vocabulary files:</p> <ul> <li>are versioned  </li> <li>immutable once released  </li> <li>governed through VGS</li> </ul> <p>domain schemas can remain stable even as domains evolve. Schema definitions rarely require modification; instead, vocabularies grow via:</p> <ul> <li>new term additions  </li> <li>deprecations (rare, carefully governed)  </li> <li>mappings to external standards  </li> </ul> <p>This separation of concerns protects schemas from churn while allowing domain communities to refine semantics over time.</p>"},{"location":"en/vocabulary/using/#summary","title":"Summary","text":"<p>Domain vocabularies enable CEP schemas to express rich, domain-specific semantics while preserving the structural, canonical, and graph-theoretic integrity of the core model.</p> <p>By relying on vocabulary-governed identifiers:</p> <ul> <li>schemas stay stable  </li> <li>adapters stay compatible  </li> <li>canonicalization stays predictable  </li> <li>cross-domain analytics become possible  </li> </ul> <p>Domain vocabularies are the key to extending CEP without fragmenting it.</p>"}]}